<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    
<script src="/js/less.min.js"></script>

    
    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/prettify/tomorrow.css">

    
<script src="/js/jquery-2.1.4.min.js"></script>

    
<script src="/js/raphael-min.js"></script>

    
<script src="/js/underscore-min.js"></script>

    
<script src="/js/sequence-diagram-min.js"></script>

    
<script src="/js/flowchart-latest.js"></script>

    
<script src="/prettify/prettify.js"></script>

    
<script src="/js/common.js"></script>

    
<script src="/js/gitment.browser.js"></script>

    
<link rel="stylesheet" href="/css/default.css">

    
<link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.css">


    
<script src="/lib/fancybox/dist/jquery.fancybox.js"></script>


    
<link rel="stylesheet" href="/css/style.css">


    
    
    <script>
        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
        ga('create', 'UA-71897482-1', 'auto');
        ga('send', 'pageview');
    </script>
    
    
    <title>读书笔记:JNI和NDK编程</title>
    <meta name="viewport" content="width=device-width, initial-scale=0.8, maximum-scale=0.8, user-scalable=no">
<meta name="generator" content="Hexo 6.3.0"></head>
<body>

<h3 id="Android开发艺术探索-JNI和NDK编程"><a href="#Android开发艺术探索-JNI和NDK编程" class="headerlink" title="Android开发艺术探索:JNI和NDK编程"></a><a target="_blank" rel="noopener" href="http://www.amazon.cn/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E4%BB%BB%E7%8E%89%E5%88%9A/dp/B014HV1X3K/ref=sr_1_1?ie=UTF8&amp;qid=1451616304&amp;sr=8-1&amp;keywords=Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2">Android开发艺术探索</a>:JNI和NDK编程</h3><p>NDK是Android所提供的工具集合，通过NDK可以方便地通过JNI来访问本地代码，还提供交叉编译器，开发人员只需要简单的修改mk文件就可以生成特定CPU平台的动态库。</p>
<p>NDK好处:</p>
<ul>
<li>提高代码安全性</li>
<li>方便使用已有C/C++开源库</li>
<li>提高程序在某些情形下的执行效率，但是并不能明显提升Android程序的性能</li>
</ul>
<h4 id="JNI开发流程-Java工程"><a href="#JNI开发流程-Java工程" class="headerlink" title="JNI开发流程(Java工程)"></a>JNI开发流程(Java工程)</h4><p><strong>1.在Java中声明native方法</strong></p>
<pre><code>package com.wujingchao.hellojni;


public class HelloJni &#123;

    static &#123;
            System.loadLibrary(&quot;hello-jni&quot;); 
    &#125;

    public native static String sendAndReceive(String msg) ;

        public static void main(String [] args) &#123;
            String result  = sendAndReceive(&quot;Hello&quot;);
            System.out.println(result);
        &#125;
&#125;
</code></pre><p>so库的名称为libhello-jni.so，这是加载so库的规范。</p>
<p><strong>2.编译Java源文件得到class文件，javah命令导出JNI的头文件</strong></p>
<p>编译class文件:</p>
<pre><code>javac com/wujingchao/hellojni/HelloJni.java
</code></pre><p>结果:</p>
<pre><code>└── com
    └── wujingchao
        └── hellojni
            ├── HelloJni.class
            └── HelloJni.java
</code></pre><p>导出Jni头文件:</p>
<pre><code>javah com.wujingchao.hellojni.HelloJni
</code></pre><p>结果:</p>
<pre><code>├── com
│   └── wujingchao
│       └── hellojni
│           ├── HelloJni.class
│           └── HelloJni.java
└── com_wujingchao_hellojni_HelloJni.h

</code></pre><p>生成的.h文件:</p>
<pre><code>/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class com_wujingchao_hellojni_HelloJni */

#ifndef _Included_com_wujingchao_hellojni_HelloJni
#define _Included_com_wujingchao_hellojni_HelloJni
#ifdef __cplusplus
extern &quot;C&quot; &#123;
#endif
/*
 * Class:     com_wujingchao_hellojni_HelloJni
 * Method:    sendAndReceive
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_wujingchao_hellojni_HelloJni_sendAndReceive
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
&#125;
#endif
#endif

</code></pre><p>函数名规则:Java_包名_类名_方法名<br>JNIEnv*:表示一个指向JNI环境的指针，可以通过它来访问JNI提供的接口方法<br>jobject:表示Java对象本身即this<br>JNIEXPORT和JNICALL:JNI定义的宏，可以在java.h这个头文件里面找到</p>
<p>extern “C” 采用C语言的命名风格来编译。</p>
<p><strong>3.实现JNI方法</strong></p>
<p>实现JNI方法可以选择C++或者C来实现。</p>
<p>在工程目录下新建文件夹jni(名字不固定），将生成的头文件放到jni目录下面，将实现的.c或者.cpp文件放到jni目录下。</p>
<p>HelloJni.c:</p>
<pre><code>#include &quot;com_wujingchao_hellojni_HelloJni.h&quot;
#include &lt;stdio.h&gt;

JNIEXPORT jstring JNICALL Java_com_wujingchao_hellojni_HelloJni_sendAndReceive
  (JNIEnv *env, jclass thiz, jstring str) &#123;
    char* message = (char*)(*env)-&gt;GetStringUTFChars(env,str,NULL);
    printf(&quot;receive message = %s\n&quot;,message);
    return (*env)-&gt;NewStringUTF(env,&quot;Bye!&quot;);
&#125;
</code></pre><p>或者HelloJni.cpp:</p>
<pre><code>#include &quot;com_wujingchao_hellojni_HelloJni.h&quot;
#include &lt;stdio.h&gt;

JNIEXPORT jstring JNICALL Java_com_wujingchao_hellojni_HelloJni_sendAndReceive
  (JNIEnv *env, jclass thiz, jstring str) &#123;
    char* message = (char*)env-&gt;GetStringUTFChars(str,NULL);
    printf(&quot;receive message = %s\n&quot;,message);
    return  env-&gt;NewStringUTF(&quot;Bye!&quot;);
&#125;
</code></pre><p>主要区别集中在对env的操作上。</p>
<p><strong>4.编译so库在Java中调用</strong></p>
<pre><code>gcc -shared -I /usr/lib/jvm/java-7-openjdk-amd64/include -fPIC HelloJni.c -o libhello-jni.so
</code></pre><p>或者</p>
<pre><code>gcc -shared -I /usr/lib/jvm/java-7-openjdk-amd64/include -fPIC HelloJni.cpp -o libhello-jni.so
</code></pre><p>制定so库的路径执行Java程序，-Djava.library.path为so库的路径:</p>
<pre><code>java -Djava.library.path=../jni com.wujingchao.hellojni.HelloJni

</code></pre><p>C和C++的调用结果是一样的:</p>
<pre><code>wujingchao@N4050:~/WorkSpace/Java/HelloJNI/src$ java -Djava.library.path=../jni com.wujingchao.hellojni.HelloJni
receive message = Hello
Bye!
</code></pre><h4 id="NDK开发流程-Android-Studio"><a href="#NDK开发流程-Android-Studio" class="headerlink" title="NDK开发流程(Android Studio)"></a>NDK开发流程(Android Studio)</h4><p>在HelloJni/local.properties里声明ndk的路径:</p>
<pre><code>ndk.dir=/home/wujingchao/Android/android-ndk-r10e
sdk.dir=/home/wujingchao/Android/Sdk
</code></pre><p>定义本地方法，编译之后生成HelloJni/app/build/intermediates/classes/debug/com/wujingchao/android/hellojni/NDKUtils.class:</p>
<pre><code>package com.wujingchao.android.hellojni;

public class NDKUtils &#123;

    static &#123;
        System.loadLibrary(&quot;hello-jni&quot;);
    &#125;

    public native static String sendAndReceive(String message);
&#125;

</code></pre><p>然后在debug目录下导出头文件:</p>
<pre><code>javah com.wujingchao.android.hellojni.NDKUtils

├── com
│   └── wujingchao
│       └── android
│           └── hellojni
│               ├── BuildConfig.class
│               ├── MainActivity$1.class
│               ├── MainActivity.class
│               ├── NDKUtils.class
|                /....
└── com_wujingchao_android_hellojni_NDKUtils.h

</code></pre><p>将其复制到app/src/main/jni，然后新建.c或者.cpp实现方法:</p>
<pre><code>#include &quot;com_wujingchao_android_hellojni_NDKUtils.h&quot;
#include &lt;stdio.h&gt;

JNIEXPORT jstring JNICALL Java_com_wujingchao_android_hellojni_NDKUtils_sendAndReceive
        (JNIEnv *env, jclass clazz, jstring s)&#123;
    const char* str = (*env)-&gt;GetStringUTFChars(env,s,NULL);
    printf(&quot;%s&quot;,str);
    return (*env)-&gt;NewStringUTF(env,&quot;Hello,Bye&quot;);
&#125;

</code></pre><p>然后在build.gradle声明生成so:</p>
<pre><code>defaultConfig &#123;
    applicationId &quot;com.wujingchao.android.hellojni&quot;
    minSdkVersion 9
    targetSdkVersion 23
    versionCode 1
    versionName &quot;1.0&quot;

     ndk &#123;
        moduleName &quot;hello-jni&quot; //和System.loadLibrary(&quot;hello-jni&quot;)；里面加载的一致
        abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot; //可以不写，那么就是全平台
     &#125;
&#125;
</code></pre><h4 id="JNI的数据类型和类型签名"><a href="#JNI的数据类型和类型签名" class="headerlink" title="JNI的数据类型和类型签名"></a>JNI的数据类型和类型签名</h4><p>JNI的数据类型基本数据类型和引用数据类型。</p>
<p>基本数据类型:</p>
<table>
<thead>
<tr>
<th>JNI类型</th>
<th>Java类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>jboolean</td>
<td>boolean</td>
<td><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/2f663dc820d0">######</a></td>
</tr>
<tr>
<td>jbyte</td>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>jint</td>
<td>int</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>..</td>
</tr>
<tr>
<td>void</td>
<td>void</td>
<td>..</td>
</tr>
</tbody>
</table>
<p>引用数据类型:</p>
<table>
<thead>
<tr>
<th>JNI类型</th>
<th>Java类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>jobject</td>
<td>Object</td>
<td></td>
</tr>
<tr>
<td>jclass</td>
<td>Class</td>
<td></td>
</tr>
<tr>
<td>jobjectArray</td>
<td>Object[]</td>
<td></td>
</tr>
<tr>
<td>jstring</td>
<td>String</td>
<td></td>
</tr>
<tr>
<td>jintArray</td>
<td>int[]</td>
<td></td>
</tr>
<tr>
<td>jthrowable</td>
<td>Throwable</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>..</td>
</tr>
</tbody>
</table>
<p>JNI的类型签名标识了Java类型，可以是类，方法，数据类型。</p>
<p>类的签名采用 “L + 包名 + 类名 +;”，例如java.lang.String，签名为 Ljava/lang/String;</p>
<p>基本数据类型采用大写字母表示:</p>
<table>
<thead>
<tr>
<th>JNI类型</th>
<th>签名</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Z</td>
</tr>
<tr>
<td>byte</td>
<td>B</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
</tr>
<tr>
<td>short</td>
<td>S</td>
</tr>
<tr>
<td>int</td>
<td>I</td>
</tr>
<tr>
<td>Long</td>
<td>J</td>
</tr>
<tr>
<td>float</td>
<td>F</td>
</tr>
<tr>
<td>double</td>
<td>D</td>
</tr>
<tr>
<td>void</td>
<td>V</td>
</tr>
</tbody>
</table>
<p>对象的签名就是所属类名的签名，数组签名为 [ + 类型签名，比如:<br>int [] : [I<br>float[] : [F<br>int[][] : [[I</p>
<p>方法的签名为 (参数类型签名) + 返回值类型签名，例如:<br>boolean fun1(int a,double b,int[] c) : (ID[C)Z<br>boolean fun2(int a,String b,int[] c) : (ILjava/lang/String;[I)Z<br>void fun3(int i) : (I)V</p>
<h4 id="JNI调用Java方法的流程"><a href="#JNI调用Java方法的流程" class="headerlink" title="JNI调用Java方法的流程"></a>JNI调用Java方法的流程</h4><p>JNI调用Java方法的流程是先通过类名找到类，然后在根据方法名找到方法的id。非构造方法需要构造类的对象才能调用，或者使用已有的对象。</p>
<p>调用静态方法:</p>
<pre><code>jclass clazz = (*env)-&gt;FindClass(&quot;com/wujingchao/android/NDKUtils&quot;);
if(clazz == NULL)&#123;
    //...
    return;
&#125;

jmethodId id = (*env)-&gt;GetStaticMethodID(clazz,&quot;testStaticJni&quot;,&quot;()V&quot;);//第三个参数为方法签名
if(id == NULL) &#123;
    //...
    return;
&#125;

(*env)-&gt;CallStaticVoidMethod(clazz,id,NULL);//第三个参数为方法参数

</code></pre><p>调用对象方法:</p>
<pre><code>    jclass clazz = (*env)-&gt;FindClass(env, &quot;com/wujingchao/android/NDKUtils&quot;);  
    if (clazz == NULL) &#123;  
        //...
        return;  
    &#125;  

    jmethodId construct = (*env)-&gt;GetMethodID(env,clazz, &quot;&lt;init&gt;&quot;,&quot;()V&quot;);  
    if (mid_construct == NULL) &#123;  
        //...
        return;  
    &#125;  

    jmethodId testJniMethod = (*env)-&gt;GetMethodID(env, clazz, &quot;testJni&quot;, &quot;(Ljava/lang/String;I)V&quot;);  
    if (testJniMethod == NULL) &#123;  
        //...
        return;  
    &#125;  

    jobject jobj = (*env)-&gt;NewObject(env,clazz,mid_construct);  
    if (jobj == NULL) &#123;  
        //...
        return;  
    &#125;  
    jstring arg = (*env)-&gt;NewStringUTF(env,&quot;Hello,Bye&quot;);

    (*env)-&gt;CallVoidMethod(env,jobj,testJniMethod,arg);  
</code></pre>



</body>
</html>