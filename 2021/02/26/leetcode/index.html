<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    
<script src="/js/less.min.js"></script>

    
    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/prettify/tomorrow.css">

    
<script src="/js/jquery-2.1.4.min.js"></script>

    
<script src="/js/raphael-min.js"></script>

    
<script src="/js/underscore-min.js"></script>

    
<script src="/js/sequence-diagram-min.js"></script>

    
<script src="/js/flowchart-latest.js"></script>

    
<script src="/prettify/prettify.js"></script>

    
<script src="/js/common.js"></script>

    
<script src="/js/gitment.browser.js"></script>

    
<link rel="stylesheet" href="/css/default.css">

    
<link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.css">


    
<script src="/lib/fancybox/dist/jquery.fancybox.js"></script>


    
<link rel="stylesheet" href="/css/style.css">


    
    
    <script>
        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
        ga('create', 'UA-71897482-1', 'auto');
        ga('send', 'pageview');
    </script>
    
    
    <title>Leetcode Kotlin 解题记录</title>
    <meta name="viewport" content="width=device-width, initial-scale=0.8, maximum-scale=0.8, user-scalable=no">
<meta name="generator" content="Hexo 6.3.0"></head>
<body>

<h3 id="Leetcode-Kotlin-解题记录"><a href="#Leetcode-Kotlin-解题记录" class="headerlink" title="Leetcode Kotlin 解题记录"></a>Leetcode Kotlin 解题记录</h3><h5 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.Two Sum"></a>1.Two Sum</h5><p>[HashTable | Array ]</p>
<p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>
<p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the <em>same</em> element twice.</p>
<p>You can return the answer in any order.</p>
<pre><code class="kotlin">fun twoSum(nums: IntArray, target: Int): IntArray &#123;
    val map = mutableMapOf&lt;Int, Int&gt;()
    for ((index, i) in nums.withIndex()) &#123;
        val complement = target - i
        if (map[complement] != null) &#123;
            return intArrayOf(index, map[complement]!!)
        &#125;
        map[i] = index
    &#125;
    return intArrayOf()
&#125;
</code></pre>
<p>NOTE：反向思维，通过和来找另一个加数 ，为了不用遍历且更快地找到，将元素的值和位置保存在map里面，空间换时间</p>
<h5 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h5><p><u>[Linked List | Math]</u></p>
<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<pre><code class="kotlin">fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? &#123;
    val head = ListNode()
    var headCur = head
    var l1Cur = l1
    var l2Cur = l2
    while (true) &#123;
        if (l1Cur != null) &#123;
            headCur.`val` += l1Cur.`val`
            l1Cur = l1Cur.next
        &#125;
        if (l2Cur != null) &#123;
            headCur.`val` += l2Cur.`val`
            l2Cur = l2Cur.next
        &#125;
        if (headCur.`val` &gt; 9) &#123;
            headCur.`val` %= 10
            headCur.next = ListNode(1)
        &#125;
        if (l1Cur == null &amp;&amp; l2Cur == null) &#123;
            break
        &#125;
        if (headCur.next == null) &#123;
            headCur.next = ListNode()
        &#125;
        headCur = headCur.next!!
    &#125;
    return head
&#125;
</code></pre>
<p>NOTE:  同时遍历两个列表，注意进位操作</p>
<h5 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h5><p>[Hash Table | Two Pointers | String | Sliding Window]</p>
<p>Given a string s, find the length of the longest substring without repeating characters.</p>
<pre><code class="kotlin">fun lengthOfLongestSubstring(s: String): Int &#123;
    var result = 0
    val cPosition = mutableMapOf&lt;Char, Int&gt;()
    var i = 0
    var j = 0
    while (j &lt; s.length) &#123;
        val pos = cPosition[s[j]]
        if (pos != null &amp;&amp; pos &gt;= i) &#123;
            i++
        &#125; else &#123;
            result = Math.max(result, j - i + 1)
            cPosition[s[j]] = j
            j++
        &#125;
    &#125;
    return result
&#125;
</code></pre>
<p>NOTE: 双指针，一个不断往前移动，判断是否有重复的字符，用Hash Table加速查询，不满足条件移动后面指针</p>
<h5 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h5><p>[Array | Binary Search | Divide Conquuer ]</p>
<p>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.</p>
<p>Follow up: The overall run time complexity should be O(log (m+n)).</p>
<pre><code class="kotlin">fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double &#123;
    val totalLen = nums1.size + nums2.size
    val center:Int
    val even = totalLen % 2 == 0
    if (even) &#123;
        center = (totalLen + 1) / 2
    &#125; else &#123;
        center = totalLen / 2
    &#125;
    var index1 = 0
    var index2 = 0
    var result = 0.0
    var last = 0
    for (i in 0 .. (totalLen - 1)) &#123;
        var cur = 0
        if (index1 &lt; nums1.size &amp;&amp; index2 &lt; nums2.size) &#123;
            if (nums1[index1] &lt; nums2[index2]) &#123;
                cur = nums1[index1]
                index1++
            &#125; else&#123;
                cur = nums2[index2]
                index2++
            &#125;
        &#125; else if (index1 &lt; nums1.size) &#123;
            cur = nums1[index1]
            index1++
        &#125; else if (index2 &lt; nums2.size)&#123;
            cur = nums2[index2]
            index2++
        &#125;
        if (i == center) &#123;
            if (even) &#123;
                result = (last + cur) / 2.0
            &#125; else &#123;
                result = cur.toDouble()
            &#125;
            break
        &#125;
        last = cur;

    &#125;
    return result
&#125;
</code></pre>
<p>NOTE:  归并排序的方式对两个数组进行遍历，记录上一个值与当前值，到达中间的位置直接求出结果</p>
<h4 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h4><p>[String | Dynamic Programing ]</p>
<p>Given a string s, return the longest palindromic substring in s.</p>
<pre><code class="kotlin">fun longestPalindrome(s: String): String &#123;
    if (s.length &lt; 2) &#123;
        return s
    &#125;
    var max = 1
    var start = 0;
    val dp = Array(s.length) &#123; BooleanArray(s.length) &#125;
    for (j in 1 until s.length) &#123;
        for (i in 0 until j) &#123;
            if (s[i] == s[j]) &#123;
                dp[i][j] = j - i + 1 &lt;= 3 ||  dp[i + 1][j - 1]
            &#125; else &#123;
                dp[i][j] = false
            &#125;

            if (dp[i][j] &amp;&amp; j - i + 1 &gt; max) &#123;
                max = j - i + 1
                start = i
            &#125;
        &#125;
    &#125;
    return s.substring(start, start + max)
&#125;
</code></pre>
<p>NOTE: 从前往后遍历，用dp[][]记录计算过的回文串区间，避免重复计算</p>
<h4 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a>6. ZigZag Conversion</h4><p>[String]</p>
<p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<p>P   A   H   N<br>A P L S I I G<br>Y   I   R</p>
<p>And then read line by line: “PAHNAPLSIIGYIR”</p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<p>string convert(string s, int numRows);</p>
<pre><code class="kotlin">fun convert(s: String, numRows: Int): String &#123;
    if (numRows == 1) return s
    val sbuilderArr = Array(numRows) &#123; StringBuilder() &#125;
    var switchIndex = 0
    var verticalIndex = 0
    s.forEachIndexed &#123; index, c -&gt;
                      if (switchIndex != 0) &#123;
                          sbuilderArr[switchIndex--].append(c)
                      &#125; else &#123;
                          sbuilderArr[verticalIndex++].append(c)
                          if (verticalIndex == numRows) &#123;
                              switchIndex = numRows - 2
                              verticalIndex = 0
                          &#125;
                      &#125;
                     &#125;
    val result = StringBuilder()
    sbuilderArr.forEach &#123;
        result.append(it)
    &#125;
    return result.toString()
&#125;
</code></pre>
<p>NOTE: 每一行用一个StringBuilder保存，然后顺序遍历，根据行数切换保存的位置，然后合并结果</p>
<h4 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h4><p>[Math]</p>
<p>Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.</p>
<p>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</p>
<pre><code class="kotlin">fun reverse(x: Int): Int &#123;
    var ret = 0
    var y = x
    var pop = 0
    while (y != 0) &#123;
        pop = y % 10

        if (ret &gt; 0 &amp;&amp; Integer.MAX_VALUE - ret * 10 &lt; pop) &#123;
            return 0
        &#125; else if (ret &lt; 0 &amp;&amp; (Integer.MIN_VALUE - ret * 10) &gt; pop ) &#123;
            return 0
        &#125;

        ret = ret * 10 + pop
        y /= 10
    &#125;
    return ret
&#125;
</code></pre>
<p>NOTE:  求余数得到各位，除以10消除个位，计算前先判断是否溢出，溢出的判断方法为先列不等式，然后变换不等式消除不等式计算两端移除的可能</p>
<h4 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h4><p>[Math | String]</p>
<p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++’s <code>atoi</code> function).</p>
<p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p>
<ol>
<li>Read in and ignore any leading whitespace.</li>
<li>Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final  result is negative or positive respectively. Assume the result is  positive if neither is present.</li>
<li>Read in next the characters until the next non-digit charcter or  the end of the input is reached. The rest of the string is ignored.</li>
<li>Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</li>
<li>If the integer is out of the 32-bit signed integer range <code>[-2^31, 2^31 - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-231</code> should be clamped to <code>-231</code>, and integers greater than <code>2^31 - 1</code> should be clamped to <code>2^31 - 1</code>.</li>
<li>Return the integer as the final result.</li>
</ol>
<pre><code class="kotlin">fun myAtoi(s: String): Int &#123;
    var ret = 0
    var neg = false
    var invalid = false
    for (c in s) &#123;
        if (c == &#39;-&#39; || c == &#39;+&#39;) &#123;
            if (invalid) &#123;
                break
            &#125;
            if (c == &#39;-&#39;) &#123;
                neg = true
            &#125; else if (c == &#39;+&#39;) &#123;
                neg = false
            &#125;
            invalid = true

        &#125; else if ((c == &#39; &#39;)) &#123;
            if (invalid) &#123;
                break
            &#125;
            continue
        &#125; else if (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &#123;
            break
        &#125; else &#123;
            val bit = c.toInt() - &#39;0&#39;.toInt()
            if (!neg &amp;&amp; ret &gt; (Integer.MAX_VALUE - bit) / 10) &#123;
                ret = Integer.MAX_VALUE
                break
            &#125; else if (neg &amp;&amp; -ret &lt; (Integer.MIN_VALUE + bit) / 10) &#123;
                ret = Integer.MIN_VALUE
                break
            &#125;
            ret = ret * 10 + bit
            invalid = true
        &#125;

    &#125;
    return if (neg) -ret else ret
&#125;
</code></pre>
<p>NOTE: 用 invalid来判断是否还可以出入其他的字符，当开始输入数字或者已经输入符号就再能在输入其他符号</p>
<h4 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h4><p>An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.</p>
<p>[Math]</p>
<pre><code class="kotlin">fun isPalindrome(x: Int): Boolean &#123;
    if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;
        return false
    &#125;
    var x = x
    var ret = 0
    while (x &gt; ret) &#123;
        val pop = x % 10
        ret = ret * 10 + pop
        x /= 10
    &#125;
    return x == ret || x == ret / 10
&#125;
</code></pre>
<p>NOTE: 隐含条件  : 计算反转数字的时候只用计算一半即可</p>
<h4 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h4><p>[String]</p>
<p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’ where: </p>
<ul>
<li>‘.’ Matches any single character.​​​​</li>
<li>‘*’ Matches zero or more of the preceding element.</li>
</ul>
<p>The matching should cover the entire input string (not partial).</p>
<pre><code class="kotlin">fun isMatch(s: String, p: String): Boolean &#123;
  if (p.isEmpty()) &#123;
    return s.isEmpty()
  &#125;
  val firstCharMatch = s.isNotEmpty() &amp;&amp; (s[0] == p[0] || p[0] == &#39;.&#39;)
  val firstStarMatch = p.length &gt; 1 &amp;&amp; p[1] == &#39;*&#39;

  if (firstCharMatch &amp;&amp; firstStarMatch) &#123;
    return isMatch(s.substring(1), p) || isMatch(s, p.substring(2))
  &#125; else if (firstStarMatch) &#123;
    return isMatch(s, p.substring(2))
  &#125; else if (firstCharMatch) &#123;
    return isMatch(s.substring(1), p.substring(1))
  &#125;else &#123;
    return false
  &#125;
&#125;

//DP:
fun isMatch(s: String, p: String): Boolean &#123;
  val pLen = p.length
  val sLen = s.length
  val dp = Array(pLen + 1)&#123;BooleanArray(sLen + 1)&#125;
  dp[0][0] = true
  for (i in 1 .. pLen - 1 step 2) &#123;
    if (p[i] == &#39;*&#39;) &#123;
      dp[i][0] = true
      dp[i + 1][0] = true
    &#125; else &#123;
      break
    &#125;
  &#125;

  for (i in 0 .. pLen - 1) &#123;
    for (j in 0 .. sLen - 1) &#123;
      if (p[i] == &#39;*&#39;) &#123;
        dp[i + 1][j + 1] = dp[i][j + 1]
      &#125; else if (p[i] == &#39;.&#39; || p[i] == s[j]) &#123;
        if (i + 1 &lt; pLen &amp;&amp; p[i + 1] == &#39;*&#39;) &#123;
          dp[i + 1][j + 1] = dp[i][j + 1] || dp[i + 1][j]
        &#125; else &#123;
          dp[i + 1][j + 1] = dp[i][j]
        &#125;
      &#125; else &#123;
        if (i + 1 &lt; pLen &amp;&amp; p[i + 1] == &#39;*&#39;) &#123;
          dp[i + 1][j + 1] = dp[i][j + 1]
        &#125;
      &#125;
    &#125;
  &#125;
  return dp[pLen][sLen]
&#125;

</code></pre>
<p>NOTE: 递归逐字符对比，根据模式字符串与被匹配字符的前两个字符的匹配结果不断地向前移动字符串，如果模式字符串为空了，那么被匹配的字符串也要为空才能正确地匹配。DP解法注意初始的条件。</p>
<h4 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h4><p>[Two Pointers | Array]</p>
<p>Given <code>n</code> non-negative integers <code>a1, a2, ..., an</code> , where each represents a point at coordinate <code>(i, ai)</code>. <code>n</code> vertical lines are drawn such that the two endpoints of the line <code>i</code> is at <code>(i, ai)</code> and <code>(i, 0)</code>. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Notice</strong> that you may not slant the container.</p>
<pre><code class="kotlin">fun maxArea(height: IntArray): Int &#123;
  var start = 0
  var end = height.size - 1
  var max = 0
  while (start &lt; end) &#123;
    val area = Math.min(height[start], height[end]) * (end - start)
    if (area &gt; max) &#123;
      max = area
    &#125;
    if (height[start] &gt; height[end]) &#123;
      end--
    &#125; else &#123;
      start++
    &#125;
  &#125;
  return max
&#125;
</code></pre>
<p>NOTE:  面积大小取决于最矮高度， min(x, y) * width,  宽度一定只能尽可能地增加高度才能让面积最大</p>
<h4 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a>12. Integer to Roman</h4><p>[Math]</p>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>
<p>For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<ul>
<li>I can be placed before V (5) and X (10) to make 4 and 9. </li>
<li>X can be placed before L (50) and C (100) to make 40 and 90. </li>
<li>C can be placed before D (500) and M (1000) to make 400 and 900.</li>
</ul>
<p>Given an integer, convert it to a roman numeral.</p>
<pre><code class="kotlin">fun intToRoman(num: Int): String &#123;
  val ret = StringBuilder()
  val romanInt = intArrayOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)
  val romanStr = arrayOf(&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;)
  var num = num
  var i = 0
  while (num &gt; 0) &#123;
    if (num - romanInt[i] &gt;= 0) &#123;
      num -= romanInt[i]
      ret.append(romanStr[i])
    &#125; else &#123;
      i++
    &#125;
  &#125;
  return ret.toString()
&#125;
</code></pre>
<p>NOTE:  罗马数字的特征，尽可能优先使用较大数值对应的字符，最后转换的结果字符最少，理由贪心算法思想，从最高位开始匹配，就能保证字符串最少。最开始想到的是另外一种方法查表法，将罗马数字的所有个位，十位..组合罗列出来，取低位的值不断地加，列表的时候较烦琐。  </p>
<h4 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h4><p>[Math]</p>
<pre><code class="kotlin">fun romanToInt(s: String): Int &#123;
    var ret = 0
    val romanMap = mapOf(&quot;M&quot; to 1000, &quot;CM&quot; to 900, &quot;D&quot; to 500, &quot;CD&quot; to 400,
                         &quot;C&quot; to 100, &quot;XC&quot; to 90, &quot;L&quot; to 50, &quot;XL&quot; to 40, &quot;X&quot; to 10, &quot;IX&quot; to 9,
                         &quot;V&quot; to 5, &quot;IV&quot; to 4, &quot;I&quot; to 1)
    var romanStr = s
    while (romanStr.isNotEmpty()) &#123;
        if (romanStr.length &gt; 1 &amp;&amp; romanMap[romanStr.substring(0, 2)] != null) &#123;
            ret += romanMap[romanStr.substring(0, 2)]!!
            romanStr = romanStr.substring(2)
        &#125; else &#123;
            ret += romanMap[romanStr.substring(0, 1)]!!
            romanStr = romanStr.substring(1)
        &#125;
    &#125;
    return ret
&#125;
</code></pre>
<p>NOTE: 思路同12，利用贪心算法。罗马数字高位就包含了位置信息只需从高位得到阿拉伯数字的值加上低位即可。</p>
<h4 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h4><p>[String]</p>
<pre><code class="kotlin">fun longestCommonPrefix(strs: Array&lt;String&gt;): String &#123;
    if (strs.isEmpty()) return &quot;&quot;

    var ret = strs[0]
    for (i in 1 until strs.size) &#123;
        ret = computeCommonPrefix(ret, strs[i])
        if (ret.isEmpty()) &#123;
            return &quot;&quot;
        &#125;
    &#125;
    return ret
&#125;

private fun computeCommonPrefix(s1: String, s2: String): String &#123;
    var i = 0
    var j = 0
    while (i &lt; s1.length &amp;&amp; j &lt; s2.length) &#123;
        if (s1[i] == s2[j]) &#123;
            i++
            j++
        &#125; else &#123;
            break
        &#125;
    &#125;
    return s1.substring(0, i)
&#125;
</code></pre>
<h4 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h4><p>[Array | Two Pointer]</p>
<p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<pre><code class="kotlin">fun threeSum(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;
    if (nums.size &lt; 3) &#123;
        return listOf()
    &#125;
    nums.sort()
    val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()
    for ((index, value) in nums.withIndex()) &#123;
        if (index != 0 &amp;&amp; nums[index] == nums[index - 1]) &#123;
            continue
        &#125;
        var start = index + 1
        var end = nums.size - 1
        while (start &lt; end) &#123;
            if (start != (index + 1) &amp;&amp; nums[start] == nums[start - 1]) &#123;
                start++;
                continue;
            &#125;
            val threeSum = value + nums[start] + nums[end]
            if (threeSum == 0) &#123;
                ret.add(listOf(value, nums[start], nums[end]))
                end--
                start++
            &#125; else if (threeSum &gt; 0) &#123;
                end--
            &#125; else &#123;
                start++
            &#125;
        &#125;
    &#125;
    return ret
&#125;
</code></pre>
<p>NOTE: 排序，去重，利用双指针特性</p>
<h4 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h4><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<pre><code class="kotlin">fun threeSumClosest(nums: IntArray, target: Int): Int &#123;
    nums.sort()
    var closest = 0
    var distance = Integer.MAX_VALUE
    for ((index, value) in nums.withIndex()) &#123;
        if (index != 0 &amp;&amp; nums[index] == nums[index - 1]) &#123;
            continue
        &#125;

        var start = index + 1
        var end = nums.size - 1
        while (start &lt; end) &#123;
            if (start != index + 1 &amp;&amp; nums[start - 1] == nums[start]) &#123;
                start++
                continue
            &#125;

            val treeSum = value + nums[start] + nums[end]
            val curDistance = treeSum - target
            if (curDistance == 0) &#123;
                return target
            &#125; else if (curDistance &gt; 0) &#123;
                end--
            &#125; else if (curDistance &lt; 0) &#123;
                start++
            &#125;
            val absDis = Math.abs(curDistance)
            if (absDis &lt; distance) &#123;
                closest = treeSum
                distance = absDis
            &#125;
        &#125;
    &#125;
    return closest
&#125;
</code></pre>
<h4 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h4><p>[String | Backtracking | Depth-first Search | Recursion] </p>
<p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<pre><code>//使用数组记录进位信息
fun letterCombinations(digits: String): List&lt;String&gt; &#123;
    val ret = mutableListOf&lt;String&gt;()
    val numberStrList = mutableListOf&lt;String&gt;()
    for (c in digits) &#123;
        numberStrList.add(letterTable(c))
    &#125;
    val arrIndex = Array(numberStrList.size) &#123;0&#125;
    while (true) &#123;
        val strBuilder = StringBuilder()
        for ((index, numStr) in numberStrList.withIndex()) &#123;
            strBuilder.append(numStr[arrIndex[index]])
        &#125;
        if (strBuilder.isNotEmpty()) &#123;
            ret.add(strBuilder.toString())
        &#125;

        var carry = 1
        for (i in arrIndex.size - 1 downTo 0) &#123;
            if (carry == 0) &#123;
                break
            &#125;
            if (arrIndex[i] + carry == numberStrList[i].length) &#123;
                carry = 1
                arrIndex[i] = 0
            &#125; else &#123;
                arrIndex[i] += carry
                carry = 0
            &#125;
        &#125;
        if (carry == 1) &#123;
            break
        &#125;
    &#125;

    return ret
&#125;

fun letterTable(char: Char) = when (char) &#123;
    &#39;2&#39; -&gt; &quot;abc&quot;
    &#39;3&#39; -&gt; &quot;def&quot;
    &#39;4&#39; -&gt; &quot;ghi&quot;
    &#39;5&#39; -&gt; &quot;jkl&quot;
    &#39;6&#39; -&gt; &quot;mno&quot;
    &#39;7&#39; -&gt; &quot;pqrs&quot;
    &#39;8&#39; -&gt; &quot;tuv&quot;
    &#39;9&#39; -&gt; &quot;wxyz&quot;
    else -&gt; &quot;&quot;
&#125;


val ret = mutableListOf&lt;String&gt;()

fun letterCombinations(digits: String): List&lt;String&gt; &#123;
    if (digits.length == 0) &#123;
        return ret
    &#125;
    val numberStrList = mutableListOf&lt;String&gt;()
    for (c in digits) &#123;
        numberStrList.add(letterTable(c))
    &#125;
    internalLetterCombination(0, numberStrList, StringBuilder())
    return ret
&#125;

fun internalLetterCombination(index: Int, numberStrList:List&lt;String&gt;, sb:StringBuilder) &#123;
    if (index == numberStrList.size) &#123;
        ret.add(sb.toString())
        return
    &#125;
    for (c in numberStrList[index]) &#123;
        sb.append(c)
        internalLetterCombination(index + 1, numberStrList, sb)
        sb.deleteCharAt(sb.length - 1)
    &#125;
&#125;
</code></pre><p>NOTE：两种方法，递归与迭代</p>
<h4 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h4><p>[Two Pointer | HashTable]</p>
<p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Notice that the solution set must not contain duplicate quadruplets.</p>
<pre><code class="kotlin">fun fourSum(nums: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123;
    val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()
    nums.sort()
    for (i in 0..nums.size - 1) &#123;
        if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;
            continue
        &#125;
        for (j in i + 1..nums.size - 1) &#123;
            if (j != i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;
                continue
            &#125;
            var start = j + 1
            var end = nums.size - 1
            while (start &lt; end) &#123;
                val tmp = nums[i] + nums[j] + nums[start] + nums[end]
                if (target == tmp) &#123;
                    ret.add(listOf(nums[i], nums[j], nums[start], nums[end]))
                    start++
                    end--
                &#125; else if (tmp &gt; target) &#123;
                    end--
                &#125; else &#123;
                    start++
                &#125;
            &#125;
        &#125;
    &#125;
    return ret
&#125;
</code></pre>
<p>NOTE：时间复杂度(o^3)</p>
<h4 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h4><p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p>
<p>Follow up: Could you do this in one pass?</p>
<pre><code class="kotlin">fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? &#123;
    val dummyHead = ListNode(0)
    dummyHead.next = head
    val recordList = mutableListOf&lt;ListNode&gt;()
    var tmp: ListNode? = dummyHead
    while (tmp != null) &#123;
        recordList.add(tmp)
        tmp = tmp.next
    &#125;
    val toRemove = recordList[recordList.size - n]
    val preToRemove = recordList[recordList.size - n - 1]

    preToRemove.next = toRemove.next

    return dummyHead.next
&#125;
</code></pre>
<p>NOTE: 构造Dummy节点就不用对头部单独处理； toRemove.next不用判断空；如果不用列表记录位置信息那么需要先遍历一遍算长度</p>
<h4 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h4><p>Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ul>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ul>
<pre><code class="kotlin">fun isValid(s: String): Boolean &#123;
    val stack = LinkedList&lt;Char&gt;()
    for (c in s) &#123;
        val opposite = convertRight(c)
        if (opposite != &#39; &#39;) &#123;
            if (stack.isEmpty() || stack.pop() != opposite) &#123;
                return false
            &#125;
        &#125; else &#123;
            stack.push(c)
        &#125;
    &#125;
    return stack.isEmpty()
&#125;

fun convertRight(c: Char) = when(c) &#123;
    &#39;)&#39; -&gt; &#39;(&#39;
    &#39;]&#39; -&gt; &#39;[&#39;
    &#39;&#125;&#39; -&gt; &#39;&#123;&#39;
    else -&gt; &#39; &#39;
&#125;
</code></pre>
<p>NOTE: 注意stack.isEmpty()判断顺序</p>
<h4 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h4><p>[LinkedList | Recursion]</p>
<p>Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.</p>
<pre><code class="kotlin">fun mergeTwoLists(l1: ListNode?, l2: ListNode?): ListNode? &#123;
    if (l1 == null) &#123;
        return l2
    &#125; else if (l2 == null) &#123;
        return l1
    &#125; else if (l1.`val` &lt; l2.`val`) &#123;
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    &#125; else &#123;
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
    &#125;
&#125;
</code></pre>
<p>Note: 递归简洁</p>
<h4 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h4><p>[String | Backtracking]</p>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<pre><code class="kotlin">val ret1 = mutableListOf&lt;String&gt;()

fun generateParenthesis(n: Int): List&lt;String&gt; &#123;
    generateParenthesisInternal(n, n , StringBuilder())
    return ret1
&#125;

fun generateParenthesisInternal(leftBracket: Int, rightBracket: Int, sb: StringBuilder) &#123;
    if (leftBracket == 0 &amp;&amp; rightBracket == 0) &#123;
        ret1.add(sb.toString())
        return
    &#125; else if (leftBracket &gt; rightBracket) &#123;
        return
    &#125; else if (leftBracket &lt; 0) &#123;
        return
    &#125;
    sb.append(&#39;(&#39;)
    generateParenthesisInternal(leftBracket - 1, rightBracket, sb)
    sb.deleteCharAt(sb.length - 1)

    sb.append(&#39;)&#39;)
    generateParenthesisInternal(leftBracket, rightBracket - 1, sb)
    sb.deleteCharAt(sb.length - 1)
&#125;
</code></pre>
<p>Note: 回溯结束条件</p>
<h4 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h4><p>[LinkedList | Divide and Conquer | Heap]</p>
<p>You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.</p>
<p>Merge all the linked-lists into one sorted linked-list and return it.</p>
<pre><code class="kotlin">fun mergeKLists(lists: Array&lt;ListNode?&gt;): ListNode? &#123;
    return mergeKListsIntern(lists)
&#125;

fun mergeKListsIntern(lists: Array&lt;ListNode?&gt;): ListNode? &#123;
    if (lists.size == 1) &#123;
        return lists[0]
    &#125; else if (lists.isEmpty()) &#123;
        return null
    &#125;
    val leftListNode = mergeKListsIntern(lists.sliceArray(0 .. lists.size / 2 - 1))
    val rightListNode = mergeKListsIntern(lists.sliceArray(lists.size / 2 .. lists.size - 1))
    return mergeTwoListNode(leftListNode, rightListNode)
&#125;

fun mergeTwoListNode(l1: ListNode?, l2: ListNode?): ListNode? &#123;
    if (l1 == null) &#123;
        return l2
    &#125; else if (l2 == null) &#123;
        return l1
    &#125; else if (l1.`val` &lt; l2.`val`) &#123;
        l1.next = mergeTwoListNode(l1.next, l2)
        return l1
    &#125; else &#123;
        l2.next = mergeTwoListNode(l1, l2.next)
        return l2
    &#125;
&#125;
</code></pre>
<h4 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a>24. Swap Nodes in Pairs</h4><p>[LinkedList | ]</p>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<pre><code class="kotlin">fun swapPairs(head: ListNode?): ListNode? &#123;
    val dummyListNode = ListNode()
    dummyListNode.next = head
    var ihead = head
    var pre = dummyListNode
    while (ihead != null &amp;&amp; ihead.next != null) &#123;
        val node1: ListNode = ihead
        val node2: ListNode = ihead.next!!
        pre.next = node2
        node1.next = node2.next
        node2.next = node1
        ihead = node1.next
        pre = node1
    &#125;
    return dummyListNode.next
&#125;


fun  swapPairs(head: ListNode?): ListNode? &#123;
    if (head == null || head.next == null) &#123;
        return head
    &#125;
    val newHead: ListNode = head.next!!
    head.next = swapPairs(newHead.next)
    newHead.next = head
    return newHead
&#125;
</code></pre>
<p>NOTE：同时遍历两个节点；递归版本!!!</p>
<h3 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h3><p>[LinkedList]</p>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</p>
<p>Follow up:</p>
<ul>
<li>Could you solve the problem in O(1) extra memory space?</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ul>
<pre><code class="kotlin">fun reverseKGroup(head: ListNode?, k: Int): ListNode? &#123;
    val dummyHead = ListNode()
    dummyHead.next = head
    var ihead = head
    var cur = head
    var cnt = 1
    var preCur: ListNode? = dummyHead
    while (ihead != null) &#123;
        if (k == cnt) &#123;
            //reverse from cur ...
            val newTail = cur
            var curN = cur?.next
            var curNN:ListNode? = null
            while (cnt &gt; 1) &#123;
                curNN = curN?.next
                curN?.next = cur

                cur = curN
                curN = curNN
                cnt--
            &#125;
            newTail?.next = curN
            preCur?.next = cur
            cur = curN

            preCur = newTail
            ihead = newTail?.next
            //cnt = 1
        &#125; else &#123;
            cnt++
            ihead = ihead.next
        &#125;
    &#125;

    return dummyHead.next
&#125;
</code></pre>
<p>NOTE: 利用三个指针反转链表到达空间复杂度O(1)</p>
<h4 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h4><p>[Array | Two Pointer]</p>
<p>Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<pre><code class="kotlin">fun removeDuplicates(nums: IntArray): Int &#123;
    if (nums.isEmpty()) &#123;
        return 0
    &#125;
    var i = 0
    for (j in 1 .. nums.size - 1) &#123;
        if (nums[i] != nums[j]) &#123;
            i++
            nums[i] = nums[j]
        &#125;
    &#125;
    return i + 1
&#125;
</code></pre>
<p>NOTE: 快慢指针移动赋值补位，不用移动后面的所有元素..</p>
<h4 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h4><p>[Array | Two Pointer]</p>
<p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<pre><code class="kotlin">fun removeElement(nums: IntArray, `val`: Int): Int &#123;
    var i = -1
    for (j in 0 .. nums.size - 1) &#123;
        if (nums[j] != `val`) &#123;
            i++
            nums[i] = nums[j]
        &#125;
    &#125;
    return i + 1
&#125;
</code></pre>
<h4 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a>28. Implement strStr()</h4><p>Implement strStr().</p>
<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<pre><code class="kotlin">fun strStr(haystack: String, needle: String): Int &#123;
  val m = haystack.length
  val n = needle.length
  if (n == 0) return 0
  if (n &gt; m) &#123;
    return -1
  &#125;
  for (i in 0 .. m - n) &#123;
    for (j in 0 .. n - 1) &#123;
      if (haystack[i + j] != needle[j]) break
      if (j == n - 1) &#123;
        return i
      &#125;
    &#125;
  &#125;
  return -1
&#125;
</code></pre>
<h4 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29. Divide Two Integers"></a>29. Divide Two Integers</h4><p>[Math]</p>
<p>Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.</p>
<p>Return the quotient after dividing dividend by divisor.</p>
<p>The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.</p>
<p>Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For this problem, assume that your function returns 2^31 − 1 when the division result overflows.</p>
<pre><code class="kotlin">fun divide(dividend: Int, divisor: Int): Int &#123;
    if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123;
        return Integer.MAX_VALUE;
    &#125;
    val positive = (dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0)
    val absDividend = Math.abs(dividend)
    val absDivisor = Math.abs(divisor)
    var toDec = absDivisor
    var total = absDividend
    var ret = 0
    var cnt = 1
    while (total - toDec &gt;= 0) &#123;
        total -= toDec
        ret += cnt
        if (total &lt;=0 ) &#123;
            break
        &#125;
        if (total - (toDec shl 1) &lt; 0) &#123;
            toDec = absDivisor
            cnt = 1
        &#125; else &#123;
            if (toDec  &lt; Int.MAX_VALUE - toDec) &#123;
                toDec = (toDec shl 1)
                cnt += cnt
            &#125;
        &#125;
    &#125;
    if (positive) &#123;
        return ret
    &#125; else &#123;
        return -ret
    &#125;
&#125;
</code></pre>
<p>NOTE: 加法和就绝对值都可能溢出</p>
<h4 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30. Substring with Concatenation of All Words"></a>30. Substring with Concatenation of All Words</h4><p>[HashTable]</p>
<p>You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.</p>
<p>You can return the answer in any order.</p>
<pre><code class="kotlin">fun findSubstring(s: String, words: Array&lt;String&gt;): List&lt;Int&gt; &#123;
    val ret = mutableListOf&lt;Int&gt;()
    val wordCountMap = mutableMapOf&lt;String, Int&gt;()
    for (word in words) &#123;
        wordCountMap.put(word, wordCountMap.getOrDefault(word, 0) + 1)
    &#125;
    val wordLen = words[0].length
    val totalWorldLen = words.sumBy &#123; it.length &#125;
    for (i in 0 .. s.length - totalWorldLen) &#123;
        val subStrMap = mutableMapOf&lt;String, Int&gt;()
        var matchedCnt = 0
        for (j in i .. i + totalWorldLen - 1 step wordLen) &#123;
            val subStr = s.substring(j, j + wordLen)
            val cnt = subStrMap.getOrDefault(subStr, 0) + 1
            if (cnt &gt; wordCountMap.getOrDefault(subStr, 0)) &#123;
                break
            &#125;
            matchedCnt++
            subStrMap.put(subStr, cnt)
        &#125;
        if (matchedCnt == words.size) &#123;
            ret.add(i)
        &#125;
    &#125;
    return ret
&#125;
</code></pre>
<p>NOTE：使用HashMap加速匹配</p>
<h4 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. Next Permutation</h4><p>[Array]</p>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).</p>
<p>The replacement must be in place and use only constant extra memory.</p>
<pre><code class="kotlin">fun nextPermutation(nums: IntArray): Unit &#123;
  var end = nums.size - 1
  var i = -1
  var j = -1
  //find i
  for (k in end downTo 1) &#123;
    if (nums[k] &gt; nums[k - 1]) &#123;
      i = k - 1
      break
    &#125;
  &#125;

  //find j
  if (i != -1) &#123;
    for (k in end downTo i) &#123;
      if (nums[k] &gt; nums[i]) &#123;
        j = k
        break
      &#125;
    &#125;
  &#125;

  //swap i and j
  if (i != -1 &amp;&amp; j != -1) &#123;
    swap(nums, i, j)
  &#125;

  //reverse i .. tail
  var start = i + 1
  while (start &lt; end) &#123;
    swap(nums, start++, end--)
  &#125;
&#125;

fun swap(arr: IntArray, i: Int, j: Int) &#123;
  val tmp = arr[i]
  arr[i] = arr[j]
  arr[j] = tmp
&#125;
</code></pre>
<p>NOTE: 要让数变大-&gt;将右边较大的数与左边较小的数交换，要想使变化的幅度最小，要在较大的数里面找到最小的</p>
<h4 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a>32. Longest Valid Parentheses</h4><p>[String | Dynamic Program]</p>
<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<pre><code class="kotlin">fun longestValidParentheses(s: String): Int &#123;
    val dp = IntArray(s.length)
    var ret = 0
    for ((index, value) in s.withIndex()) &#123;
        if (value == &#39;)&#39;) &#123;
            if (index &gt; 0) &#123;
                if (s[index - 1] == &#39;(&#39;) &#123;
                    dp[index] = (if (index - 2 &gt;= 0) dp[index - 2] else 0) + 2
                &#125; else if (s[index - 1] == &#39;)&#39; &amp;&amp; index - dp[index - 1] - 1 &gt;= 0 &amp;&amp; s[index - dp[index - 1] - 1] == &#39;(&#39;) &#123;
                    dp[index] = dp[index - 1] + 2 + if (index - dp[index - 1] - 2 &gt;= 0) dp[index - dp[index - 1] - 2] else 0
                &#125;
                ret = Math.max(dp[index], ret)
            &#125;
        &#125;
    &#125;
    return ret
&#125;
</code></pre>
<p>NOTE: 使用例子列状态转移方程，尾部存在两张情况 “()”， “(…XX))”</p>
<h4 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h4><p>[Binary Search]</p>
<p>There is an integer array nums sorted in ascending order (with distinct values).</p>
<p>Prior to being passed to your function, nums is rotated at an unknown pivot index k (0 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].</p>
<p>Given the array nums after the rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</p>
<pre><code class="kotlin">fun search(nums: IntArray, target: Int): Int &#123;
    var left = 0
    var right = nums.size - 1
    while (left &lt;= right) &#123;
        val mid = (left + right) / 2
        if (target == nums[mid]) &#123;
            return mid
        &#125;
        if (nums[left] &lt;= nums[mid]) &#123;//left sorted， 注意这里的等号，left与mid在两个数的时候相等
            if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;
                right = mid - 1
            &#125; else &#123;
                left = mid + 1
            &#125;
        &#125; else &#123;//right sorted
            if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;
                left = mid + 1
            &#125; else &#123;
                right = mid - 1
            &#125;
        &#125;

    &#125;
    return -1
&#125;
</code></pre>
<p>Note: 二分法，有一边肯定是有序的，判断是否在有序的返回以内，如果在，那么就可以在这个范围查找，不在的话肯定在另外一边</p>
<h4 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a>34. Find First and Last Position of Element in Sorted Array</h4><p>[Binary Search]</p>
<p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>If target is not found in the array, return [-1, -1].</p>
<p>Follow up: Could you write an algorithm with O(log n) runtime complexity?</p>
<pre><code class="kotlin">fun searchRange(nums: IntArray, target: Int): IntArray &#123;
    var l = 0
    var r = nums.size - 1
    var retL = -1
    var retR = -1

    //search left bound
    while (l &lt;= r) &#123;
        val mid = (l + r) / 2
        if (nums[mid] == target) &#123;
            retL = mid
            r = mid - 1
        &#125; else if (nums[mid] &gt; target) &#123;
            r = mid - 1
        &#125; else &#123;
            l = mid + 1
        &#125;
    &#125;

    //search right bound
    l = 0
    r = nums.size - 1
    while (l &lt;= r) &#123;
        val mid = (l + r) / 2
        if (nums[mid] == target) &#123;
            retR = mid
            l = mid + 1
        &#125; else if (nums[mid] &gt; target) &#123;
            r = mid - 1
        &#125; else &#123;
            l = mid + 1
        &#125;
    &#125;
    return intArrayOf(retL, retR)
&#125;
</code></pre>
<p>Note: 二分法核心是确定搜索区间</p>
<h4 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h4><p>[Binary Search]</p>
<p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<pre><code class="kotlin">fun searchInsert(nums: IntArray, target: Int): Int &#123;
    var l = 0
    var r = nums.size - 1
    while (l &lt;= r) &#123;
        val mid = (l + r) / 2
        if (nums[mid] == target) &#123;
            return mid
        &#125; else if (nums[mid] &gt; target) &#123;
            r = mid - 1
        &#125; else if (nums[mid] &lt; target) &#123;
            l = mid + 1
        &#125;
    &#125;
    return l
&#125;
</code></pre>
<h4 id="36-Valid-Sudoku"><a href="#36-Valid-Sudoku" class="headerlink" title="36. Valid Sudoku"></a>36. Valid Sudoku</h4><p>[Array | HashTable]</p>
<p>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<ul>
<li>Each row must contain the digits 1-9 without repetition.</li>
<li>Each column must contain the digits 1-9 without repetition.</li>
<li>Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li>
</ul>
<p>Note:</p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
</ul>
<pre><code class="kotlin">fun isValidSudoku(board: Array&lt;CharArray&gt;): Boolean &#123;
    val rowMap = Array(10) &#123;IntArray(10)&#125;
    val colMap = Array(10) &#123;IntArray(10)&#125;
    val subBoxMap = Array(10) &#123;IntArray(10)&#125;

    var row = 0
    while (row &lt; board.size) &#123;
        var col = 0

        while (col &lt; board[row].size) &#123;

            if (board[row][col] == &#39;.&#39;) &#123;
                col++
                continue
            &#125;

            val digits = board[row][col] - &#39;0&#39;
            //row exists
            if (rowMap[row][digits] != 0) &#123;
                return false
            &#125; else &#123;
                rowMap[row][digits] = 1
            &#125;
            //col exists
            if (colMap[col][digits] != 0) &#123;
                return false
            &#125; else &#123;
                colMap[col][digits] = 1
            &#125;

            //subbox exists
            if (subBoxMap[(row / 3) * 3 + col / 3][digits] != 0) &#123;
                return false
            &#125; else &#123;
                subBoxMap[(row / 3) * 3 + col / 3][digits] = 1
            &#125;

            col++
        &#125;
        row++
    &#125;

    return true
&#125;
</code></pre>
<p>NOTE: 逐个遍历，然后使用表加速查找</p>
<h4 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a>37. Sudoku Solver</h4><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>A sudoku solution must satisfy all of the following rules:</p>
<ul>
<li>Each of the digits 1-9 must occur exactly once in each row.</li>
<li>Each of the digits 1-9 must occur exactly once in each column.</li>
<li>Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.</li>
</ul>
<p>The ‘.’ character indicates empty cells.</p>
<pre><code class="kotlin">fun solveSudoku(board: Array&lt;CharArray&gt;): Unit &#123;
    val rowTable = Array(10) &#123; IntArray(10) &#123; 0 &#125; &#125;
    val colTable = Array(10) &#123; IntArray(10) &#123; 0 &#125; &#125;
    val subTable = Array(10) &#123; IntArray(10) &#123; 0 &#125; &#125;

    for (row in 0..board.size - 1) &#123;
        for (col in 0..board[0].size - 1) &#123;
            if (board[row][col] != &#39;.&#39;) &#123;
                val digit = board[row][col] - &#39;0&#39;
                rowTable[row][digit] = 1
                colTable[col][digit] = 1
                subTable[3 * (row / 3) + col / 3][digit] = 1
            &#125;
        &#125;
    &#125;
    solveSudoku(board, rowTable, colTable, subTable, 0, 0)
&#125;

fun solveSudoku(board: Array&lt;CharArray&gt;, rowTable: Array&lt;IntArray&gt;, colTable: Array&lt;IntArray&gt;, subTable: Array&lt;IntArray&gt;, row: Int, col: Int): Boolean &#123;
    if (row == board.size) &#123;
        return true
    &#125;
    var ret: Boolean = false
    if (board[row][col] == &#39;.&#39;) &#123;
        for (i in 1..9) &#123;
            if (rowTable[row][i] != 1 &amp;&amp; colTable[col][i] != 1 &amp;&amp; subTable[3 * (row / 3) + col / 3][i] != 1) &#123;
                rowTable[row][i] = 1
                colTable[col][i] = 1
                subTable[3 * (row / 3) + col / 3][i] = 1

                board[row][col] = &#39;0&#39; + i
                if (col == board[0].size - 1) &#123;
                    ret = solveSudoku(board, rowTable, colTable, subTable, row + 1, 0)
                &#125; else &#123;
                    ret = solveSudoku(board, rowTable, colTable, subTable, row, col + 1)
                &#125;
                if (ret) &#123;
                    return true
                &#125;
                board[row][col] = &#39;.&#39;
                rowTable[row][i] = 0
                colTable[col][i] = 0
                subTable[3 * (row / 3) + col / 3][i] = 0
            &#125;
        &#125;
    &#125; else &#123;
        if (col == board[0].size - 1) &#123;
            ret = solveSudoku(board, rowTable, colTable, subTable, row + 1, 0)
        &#125; else &#123;
            ret = solveSudoku(board, rowTable, colTable, subTable, row, col + 1)
        &#125;
    &#125;
    return ret
&#125;
</code></pre>
<p>Note: 万能的回溯..</p>
<h4 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38. Count and Say"></a>38. Count and Say</h4><p>[String]</p>
<p>The count-and-say sequence is a sequence of digit strings defined by the recursive formula:</p>
<ul>
<li>countAndSay(1) = “1”</li>
<li>countAndSay(n) is the way you would “say” the digit string from countAndSay(n-1), which is then converted into a different digit string.</li>
</ul>
<p>To determine how you “say” a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.</p>
<pre><code class="kotlin">fun countAndSay(n: Int): String &#123;
    var ret = StringBuilder()
    for (i in 1..n) &#123;
        if (ret.isEmpty()) &#123;
            ret.append(i)
        &#125; else &#123;
            val tmp = StringBuilder()
            var lastChar = &#39;x&#39;
            var cnt = 1
            for ((index, c) in ret.withIndex()) &#123;
                if (index == 0) &#123;
                    tmp.append(c)
                &#125; else &#123;
                    if (lastChar == c) &#123;
                        cnt++
                    &#125; else &#123;
                        tmp.append(cnt)
                        tmp.append(c)
                        cnt = 1
                    &#125;
                &#125;
                lastChar = c
            &#125;
            tmp.append(cnt)
            ret = tmp
        &#125;
    &#125;
    return ret.reverse().toString()
&#125;
</code></pre>
<h4 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h4><p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</p>
<p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>
<p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p>
<pre><code class="kotlin">val ret5 = mutableListOf&lt;List&lt;Int&gt;&gt;()

fun combinationSum(candidates: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123;
    //candidates.sort()
    internalCombinationSum(candidates,  target, mutableListOf(), 0)
    return ret5
&#125;

fun internalCombinationSum(candidates: IntArray, target: Int, tracer: MutableList&lt;Int&gt;, startIndex: Int) &#123;
    val sum = tracer.sum()
    if (sum == target) &#123;
        ret5.add(ArrayList(tracer))
        return
    &#125; else if (sum &gt; target) &#123;
        return
    &#125;

    for (i in startIndex..candidates.size - 1) &#123;
        tracer.add(candidates[i])
        internalCombinationSum(candidates, target, tracer, i)
        tracer.removeAt(tracer.size - 1)
    &#125;
&#125;
</code></pre>
<p>Note: 可不排序，排序后减少回溯分支</p>
<h4 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h4><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.</p>
<p>Each number in candidates may only be used once in the combination.</p>
<p>Note: The solution set must not contain duplicate combinations.</p>
<pre><code class="kotlin">val ret6 = mutableListOf&lt;List&lt;Int&gt;&gt;()

fun combinationSum2(candidates: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123;
    candidates.sort()
    combinationSum2Recur(candidates, target, 0, mutableListOf())
    return ret6
&#125;

fun combinationSum2Recur(candidates: IntArray, target: Int, startIndex: Int, tracer: MutableList&lt;Int&gt;) &#123;
    val sum = tracer.sum()
    if (sum == target) &#123;
        ret6.add(ArrayList(tracer))
        return
    &#125; else if (sum &gt; target) &#123;
        return
    &#125;

    for (i in startIndex..candidates.size - 1) &#123;
        if (i != startIndex &amp;&amp; candidates[i] == candidates[i - 1]) &#123;
            continue
        &#125;
        tracer.add(candidates[i])
        combinationSum2Recur(candidates, target, i + 1, tracer)
        tracer.removeAt(tracer.size - 1)
    &#125;

&#125;
</code></pre>
<p>Note: 排序去重</p>
<h4 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a>41. First Missing Positive</h4><p>Given an unsorted integer array nums, find the smallest missing positive integer.</p>
<pre><code class="kotlin">fun firstMissingPositive(nums: IntArray): Int &#123;
    val len = nums.size + 1
    val hash = Array(len)&#123;-1&#125;
    for ((index, value) in nums.withIndex()) &#123;
        if (value &gt; 0  &amp;&amp; value &lt; len) &#123;
            hash[value] = index
        &#125;
    &#125;

    for (i in  1 .. nums.size) &#123;
        if (hash[i] == -1) &#123;
            return i
        &#125;
    &#125;
    return nums.size + 1
&#125;
</code></pre>
<p>Note: 利用哈希表加速查找</p>
<h4 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h4><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p>
<pre><code class="kotlin">//DP:

fun trap(height: IntArray): Int &#123;
    if (height.size &lt;= 2) &#123;
        return 0
    &#125;
    var ret = 0
    val maxLefts = Array(height.size)&#123;0&#125;
    val maxRights = Array(height.size)&#123;0&#125;

    var tmpMax = 0
    for (i in 0 .. height.size - 1) &#123;
        maxLefts[i] = Math.max(height[i], tmpMax)
        tmpMax = maxLefts[i]
    &#125;

    tmpMax = 0
    for (i in height.size - 1 downTo 0) &#123;
        maxRights[i] = Math.max(height[i], tmpMax)
        tmpMax = maxRights[i]
    &#125;

    for (i in 1 .. (height.size - 2)) &#123;
        val area = Math.min(maxLefts[i], maxRights[i]) - height[i]
        if (area &gt; 0) &#123;
            ret += area
        &#125;
    &#125;
    return ret
&#125;

//Two Pointer
fun trap(height: IntArray): Int &#123;
  if (height.size &lt; 3) &#123;
    return 0
  &#125;
  var ret = 0
  var maxLeft = height[0]
  var maxRight = height[height.size - 1]
  var left = 1
  var right = height.size - 2
  while (left &lt;= right) &#123;
    if (maxLeft &lt; maxRight) &#123;
      val area = maxLeft - height[left]
      if (area &gt; 0) &#123;
        ret += area
      &#125;
      maxLeft = Math.max(maxLeft, height[left])
      left++
    &#125; else &#123;
      val area = maxRight - height[right]
      if (area &gt; 0) &#123;
        ret += area
      &#125;
      maxRight = Math.max(maxRight, height[right])
      right--

    &#125;
  &#125;
  return ret
&#125;
</code></pre>
<p>Note: 当前条的面积等于左边的最大高度与右边最小高度的最小值减去当前条的高度。双指针可以利用隐含条件，当另外一边的最大大于已经遍历过的这一边的最大，就可以确定左右最大中的最小。</p>
<h4 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="43. Multiply Strings"></a>43. Multiply Strings</h4><p>[String | Math]</p>
<p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</p>
<p>Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>
<pre><code class="kotlin">fun multiply(num1: String, num2: String): String &#123;
    if (num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) &#123;
        return &quot;0&quot;
    &#125;
    var ret = &quot;&quot;
    var tailZero = 0
    for (c2 in num2.length - 1 downTo  0) &#123;
        val i2 = num2[c2] - &#39;0&#39;
        var carry = 0
        val tmp = StringBuilder()
        for (c1 in num1.length - 1 downTo  0) &#123;
            val i1 = num1[c1] - &#39;0&#39;
            val product = i1 * i2 + carry
            val cur = product % 10
            carry = product / 10
            tmp.append(cur.toString())
        &#125;
        if (carry &gt; 0) &#123;
            tmp.append(carry)
        &#125;
        for (i in 1..tailZero) &#123;
            tmp.insert(0, &quot;0&quot;)
        &#125;
        ret = plus(ret, tmp.toString())
        tailZero++
    &#125;
    return ret.reversed()
&#125;

fun plus(num1: String, num2: String): String &#123;
    if (num1.isEmpty()) &#123;
        return num2
    &#125;else if (num2.isEmpty()) &#123;
        return num1
    &#125;
    val ret = StringBuilder()
    var i = 0
    var j = 0
    var carry = 0
    while (true) &#123;
        if (i &lt;= num1.length - 1 &amp;&amp; j &lt;= num2.length - 1) &#123;
            val i1 = num1[i] - &#39;0&#39;
            val i2 = num2[i] - &#39;0&#39;
            val addtion = i1 + i2 + carry
            ret.append(addtion % 10)
            carry = addtion / 10
        &#125; else if (i &lt;= num1.length - 1) &#123;
            val v = num1[i] - &#39;0&#39;
            val addtion = v + carry
            ret.append(addtion % 10)
            carry = addtion / 10
        &#125; else if (j &lt;= num2.length - 1) &#123;
            val v = num2[j] - &#39;0&#39;
            val addtion = v + carry
            ret.append(addtion % 10)
            carry = addtion / 10
        &#125; else &#123;
            break
        &#125;
        i++
        j++
    &#125;
    if (carry &gt; 0) &#123;
        ret.append(carry)
    &#125;
    return ret.toString()
&#125;
</code></pre>
<h4 id="44-Wildcard-Matching"><a href="#44-Wildcard-Matching" class="headerlink" title="44. Wildcard Matching"></a>44. Wildcard Matching</h4><p>[Dynamic Programing]</p>
<p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’ where:</p>
<ul>
<li>‘?’ Matches any single character.</li>
<li>‘*’ Matches any sequence of characters (including the empty sequence).</li>
</ul>
<p>The matching should cover the entire input string (not partial).</p>
<pre><code class="kotlin">    fun isMatch(s: String, p: String): Boolean &#123;
        val pLen = p.length
        val sLen = s.length
        val dp = Array(pLen + 1)&#123; BooleanArray(sLen + 1)&#125;
        dp[0][0] = true
        for (i in 0 .. pLen - 1) &#123;
            if (p[i] == &#39;*&#39;) &#123;
                dp[i + 1][0] = true
            &#125; else &#123;
                break
            &#125;
        &#125;

        for (i in 0 .. pLen-1) &#123;
            for (j in 0 .. sLen-1) &#123;
                if (p[i] == s[j] || p[i] == &#39;?&#39;) &#123;
                    dp[i + 1][j + 1] = dp[i][j]
                &#125; else if (p[i] == &#39;*&#39;) &#123;
                    dp[i + 1][j + 1] = dp[i][j + 1] || dp[i + 1][j]
                &#125;
            &#125;
        &#125;
        return dp[pLen][sLen]
    &#125;
</code></pre>
<p>Note: 注意<em>号的转移方程，</em>是左右匹配的，被<em>消耗或者没有被</em>消耗的情况</p>
<h4 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h4><p>[Greedy]</p>
<p>Given an array of non-negative integers nums, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>You can assume that you can always reach the last index.</p>
<pre><code class="kotlin">
//reverse:
fun jump(nums: IntArray): Int &#123;
    var step = 0
    val end = nums.size - 1
    var position = end
    var curEnd = end
    while (position &gt; 0) &#123;
        position--
        for (i in 0 until position) &#123;
            if (i + nums[i] &gt;= curEnd) &#123;
                position = i
                break
            &#125;
        &#125;
        curEnd = position
        step++
    &#125;
    return step
&#125;

//forward:
fun jump(nums: IntArray): Int &#123;
    var steps = 0
    var end = 0
    var curMaxDistance = 0
    for (i in 0 .. nums.size - 2) &#123;
        curMaxDistance = Math.max(nums[i] + i, curMaxDistance)
        if (end == i) &#123;
            steps++
            end = curMaxDistance
        &#125;
    &#125;
    return steps
&#125;
</code></pre>
<p>Note: 求局部最优解 —&gt; 全局最优解</p>
<h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h4><p>[Backtracking]</p>
<p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p>
<pre><code class="kotlin">val ret7 = mutableListOf&lt;List&lt;Int&gt;&gt;();

fun permute(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;
    permuteRecur(nums, mutableListOf())
    return ret7
&#125;

fun permuteRecur(nums: IntArray, tracer: MutableList&lt;Int&gt;) &#123;
    if (tracer.size == nums.size) &#123;
        ret7.add(tracer.toList())
        return
    &#125;
    for (i in nums) &#123;
        if (!tracer.contains(i)) &#123;
            tracer.add(i)
            permuteRecur(nums, tracer)
            tracer.remove(i)
        &#125;
    &#125;
&#125;

//Space O(1)

val ret8 = mutableListOf&lt;List&lt;Int&gt;&gt;();

fun permute(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;
    permuteRecur(nums, 0)
    return ret8
&#125;

fun permuteRecur(nums: IntArray, startIndex: Int) &#123;
    if (startIndex == nums.size) &#123;
        ret8.add(nums.toList())
        return
    &#125;
    for (index in startIndex .. nums.size - 1) &#123;
        swap(nums, index, startIndex)
        permuteRecur(nums, startIndex + 1)
        swap(nums, index, startIndex)
    &#125;
&#125;

fun swap(x: IntArray, a: Int, b: Int) &#123;
    val t = x[a]
    x[a] = x[b]
    x[b] = t
&#125;
</code></pre>
<h4 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h4><p>[Backtracking]</p>
<p>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.</p>
<pre><code class="kotlin">val ret9 = mutableListOf&lt;List&lt;Int&gt;&gt;()

fun permuteUnique(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;
  nums.sort()
  permuteUnique(nums, BooleanArray(nums.size), LinkedList())
  return ret9
&#125;

fun permuteUnique(nums: IntArray, visited: BooleanArray, path: LinkedList&lt;Int&gt;) &#123;
  if (path.size == nums.size ) &#123;
    ret9.add(path.toList())
    return
  &#125;
  for (i in 0 .. nums.size - 1) &#123;
    if (i != 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]) &#123;
      continue
    &#125;
    if (visited[i]) &#123;
      continue
    &#125;
    path.add(nums[i])
    visited[i] = true
    permuteUnique(nums, visited, path)
    visited[i] = false
    path.removeLast()
  &#125;
&#125;
</code></pre>
<p>Note: 开始遍历了之后就不用判断相同的上一个</p>
<h4 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. Rotate Image</h4><p>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).</p>
<p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>
<pre><code class="kotlin">fun rotate(matrix: Array&lt;IntArray&gt;): Unit &#123;
  var level = 0
  val end = matrix.size - 1
  while (matrix.size - 2 * level &gt;= 2) &#123;
    for (i in level .. matrix.size - level - 2) &#123;
      //(level, i)  -&gt; (i, end - level)
      val leftTop = matrix[level][i]
      val rightTop = matrix[i][end - level]
      val rightBottom = matrix[end - level][end - i]
      val leftBottom = matrix[end - i][level]

      matrix[level][i] = leftBottom
      matrix[i][end - level] = leftTop
      matrix[end - level][end - i] = rightTop
      matrix[end - i][level] = rightBottom
    &#125;
    level++
  &#125;
&#125;
</code></pre>
<p>Note: 注意边界条件</p>
<h4 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h4><p>[HashTable]</p>
<p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.</p>
<p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<pre><code class="kotlin">fun groupAnagrams(strs: Array&lt;String&gt;): List&lt;List&lt;String&gt;&gt; &#123;
    val map = mutableMapOf&lt;String, MutableList&lt;String&gt;&gt;()
    for (s in strs) &#123;
        val chars = s.toCharArray()
        chars.sort()
        val key = String(chars)
        if (map.containsKey(key)) &#123;
            map[key]?.add(s)
        &#125; else &#123;
            map[key] = mutableListOf(s)
        &#125;
    &#125;
    val values = map.values
    val ret = mutableListOf&lt;List&lt;String&gt;&gt;()
    values.forEach &#123;
        ret.add(it)
    &#125;
    return ret
&#125;
</code></pre>
<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h4><p>[Divide Conquer]</p>
<p>Implement pow(x, n), which calculates x raised to the power n (i.e. xn).</p>
<pre><code class="kotlin">//递归：
fun myPow(x: Double, n: Int): Double &#123;
    if (n &lt; 0) &#123;
        return 1.0f / myPowRecur(x, Math.abs(n))
    &#125; else &#123;
        return myPowRecur(x, Math.abs(n))
    &#125;
&#125;

fun myPowRecur(x: Double, n: Int): Double &#123;
    if (n == 1) &#123;
        return x
    &#125; else if (n == 0) &#123;
        return 1.0
    &#125;
    val part = myPowRecur(x, n / 2)
    if (n % 2 == 0) &#123;
        return part * part
    &#125; else &#123;
        return part * part * x
    &#125;
&#125;

//迭代：
fun myPow(x: Double, n: Int): Double &#123;
    var ret = 1.0
    var N = Math.abs(n.toLong())
    var tmp = x
    while (N &gt; 0) &#123;
        if (N and 1 == 1L) &#123;
            ret *= tmp
        &#125;

        N = N shr  1
        tmp *= tmp
    &#125;
    return if (n &gt; 0) ret else 1.0 / ret
&#125;

</code></pre>
<p>Note: 指数二进制移位</p>
<h4 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a>51. N-Queens</h4><p>[Backtracking]</p>
<p>The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.</p>
<p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space, respectively.</p>
<pre><code class="kotlin">val ret = mutableListOf&lt;List&lt;String&gt;&gt;()

fun solveNQueens(n: Int): List&lt;List&lt;String&gt;&gt; &#123;
    solveNQueensRecur(n, 0, IntArray(n)&#123;-1&#125;)
    return ret
&#125;

fun solveNQueensRecur(n: Int, row: Int, path: IntArray) &#123;
    //check （row - 1）already placed
    if (row == path.size) &#123;
        val listStr = mutableListOf&lt;String&gt;()
        val tmp = StringBuilder()
        for (i in path) &#123;
            tmp.clear()
            for (j in 0 .. row - 1) &#123;
                if (i == j) &#123;
                    tmp.append(&quot;Q&quot;)
                &#125; else &#123;
                    tmp.append(&quot;.&quot;)
                &#125;
            &#125;
            listStr.add(tmp.toString())
        &#125;
        ret.add(listStr)
        return
    &#125;

    for (i in 0 .. n - 1) &#123;
        path[row] = i
        if (!checkPathIsValid(path, row)) &#123;
            continue
        &#125;
        solveNQueensRecur(n, row + 1, path)
        path[row] = -1
    &#125;
&#125;

fun checkPathIsValid(path: IntArray, row: Int) : Boolean &#123;
    if (row &gt;= 1) &#123;
        val cur = path[row]
        for (k in row - 1 downTo 0) &#123;
            if (cur == path[k]) &#123;
                return false
            &#125;
            if ((path[k] + row - k) == cur || (path[k] - (row - k)) == cur) &#123;
                return false
            &#125;
        &#125;
    &#125;
    return true
&#125;
</code></pre>
<h4 id="52-N-Queens-II"><a href="#52-N-Queens-II" class="headerlink" title="52. N-Queens II"></a>52. N-Queens II</h4><p>The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.</p>
<p>Given an integer n, return the number of distinct solutions to the n-queens puzzle.</p>
<pre><code class="kotlin">var ret2 = 0

fun solveNQueensRecur(n: Int, row: Int, path: IntArray) &#123;
    //check （row - 1）already placed
    if (row == path.size) &#123;
        ret2++
        return
    &#125;

    for (i in 0 .. n - 1) &#123;
        path[row] = i
        if (!checkPathIsValid(path, row)) &#123;
            continue
        &#125;
        solveNQueensRecur(n, row + 1, path)
        path[row] = -1
    &#125;
&#125;

fun checkPathIsValid(path: IntArray, row: Int) : Boolean &#123;
    if (row &gt;= 1) &#123;
        val cur = path[row]
        for (k in row - 1 downTo 0) &#123;
            if (cur == path[k]) &#123;
                return false
            &#125;
            if ((path[k] + row - k) == cur || (path[k] - (row - k)) == cur) &#123;
                return false
            &#125;
        &#125;
    &#125;
    return true
&#125;


fun totalNQueens(n: Int): Int &#123;
    solveNQueensRecur(n, 0, IntArray(n)&#123;-1&#125;)
    return ret2
&#125;
</code></pre>
<h4 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h4><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<pre><code class="kotlin">fun maxSubArray(nums: IntArray): Int &#123;
    var subMax = nums[0] 
    var max = subMax
    for (i in 1 .. nums.size - 1) &#123; 
        if (subMax &lt; 0) &#123;
            subMax = nums[i]
        &#125; else &#123;
            subMax += nums[i]
        &#125;
        max = Math.max(max, subMax)
    &#125;
    return max
&#125;
</code></pre>
<p>Note: 动态规划， 状态压缩，只取最大的那个</p>
<h4 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a>54. Spiral Matrix</h4><p>Given an m x n matrix, return all elements of the matrix in spiral order.</p>
<pre><code class="kotlin">fun spiralOrder(matrix: Array&lt;IntArray&gt;): List&lt;Int&gt; &#123;
    val ret = mutableListOf&lt;Int&gt;()

    var left = 0
    var top = 0
    var right = matrix[0].size - 1
    var bottom = matrix.size - 1
    while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;
        for (i in left .. right) &#123;
            ret.add(matrix[top][i])
        &#125;
        for (i in top + 1 .. bottom) &#123;
            ret.add(matrix[i][right])
        &#125;
        if (bottom  &gt; top &amp;&amp; right &gt; left) &#123;
            for (i in right - 1 downTo left) &#123;
                ret.add(matrix[bottom][i])
            &#125;
            for (i in bottom - 1 downTo top + 1) &#123;
                ret.add(matrix[i][left])
            &#125;
        &#125;
        left++
        top++
        bottom--
        right--
    &#125;
    return ret
&#125;
</code></pre>
<p>Note: bottom  &gt; top &amp;&amp; right &gt; left  不能转向的判断</p>
<h4 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. Jump Game</h4><p>[Greedy]</p>
<p>Given an array of non-negative integers nums, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<pre><code class="kotlin">fun canJump(nums: IntArray): Boolean &#123;
    if (nums.size == 1) &#123;
        return true
    &#125;
    var barrier = 0
    var max = nums[0]
    for (i in 0 .. nums.size - 2) &#123;
        max = Math.max(max, i + nums[i])
        if (barrier == i) &#123;
            if (barrier &gt;= max) &#123;
                return false
            &#125;
            barrier = max
        &#125;

        if (max &gt;= nums.size - 1) &#123;
            return true
        &#125;
    &#125;
    return false
&#125;
</code></pre>
<h4 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h4><p>Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p>
<pre><code class="kotlin">fun merge(intervals: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; &#123;
//        for (i in 0 .. intervals.size - 2) &#123;
//            for (j in i + 1 .. intervals.size - 1) &#123;
//                if (intervals[i][0] &gt; intervals[j][0]) &#123;
//                    val tmp = intervals[i]
//                    intervals[i] = intervals[j]
//                    intervals[j] = tmp
//                &#125;
//            &#125;
//        &#125;
    val ret = mutableListOf&lt;IntArray&gt;()
    fun quickSort(arr: Array&lt;IntArray&gt;, start: Int, end: Int) &#123;
        fun swap(arr: Array&lt;IntArray&gt;, i: Int, j: Int) &#123;
            val tmp = arr[i]
            arr[i] = arr[j]
            arr[j] = tmp

        &#125;
        if (start &gt;= end) &#123;
            return
        &#125;
        val mid = (start + end) / 2
        swap(arr, mid, start)
        val pivot = arr[start]
        var last = start
        var i = start + 1
        while (i &lt;= end) &#123;
            if (arr[i][0] &lt; pivot[0]) &#123;
                swap(arr, i, ++last)
            &#125;
            i++
        &#125;
        swap(arr, last, start)
        quickSort(arr, start, last - 1)
        quickSort(arr, last + 1, end)
    &#125;
    quickSort(intervals, 0, intervals.size - 1)
    ret.add(intervals[0])
    for (i in 1 .. intervals.size - 1) &#123;
        if (ret[ret.size - 1][1] &gt;= intervals[i][0]) &#123;
            ret[ret.size - 1][0] = Math.min(intervals[i][0], ret[ret.size - 1][0])
            ret[ret.size - 1][1] = Math.max(intervals[i][1], ret[ret.size - 1][1])
        &#125; else &#123;
            ret.add(intervals[i])
        &#125;
    &#125;
    return ret.toTypedArray()
&#125;

</code></pre>
<p>Note： 快排快慢指针的运用</p>
<h4 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a>57. Insert Interval</h4><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<pre><code class="kotlin">fun insert(intervals: Array&lt;IntArray&gt;, newInterval: IntArray): Array&lt;IntArray&gt; &#123;
    val newIntervalList = intervals.toMutableList()
    var i = 0
    while (i &lt;= newIntervalList.size - 1) &#123;
        if (newIntervalList[i][0] &gt; newInterval[0]) &#123;
            newIntervalList.add(i, newInterval)
            break
        &#125;
        i++
    &#125;
    if (newIntervalList.size == intervals.size) &#123;
        newIntervalList.add(newInterval)
    &#125;
    val ret = mutableListOf&lt;IntArray&gt;()
    ret.add(newIntervalList[0])
    for (j in 1 .. newIntervalList.size - 1) &#123;
        if (ret[ret.size - 1][1] &gt;= newIntervalList[j][0]) &#123;
            ret[ret.size - 1][0] = Math.min(newIntervalList[j][0], ret[ret.size - 1][0])
            ret[ret.size - 1][1] = Math.max(newIntervalList[j][1], ret[ret.size - 1][1])
        &#125; else &#123;
            ret.add(newIntervalList[j])
        &#125;
    &#125;
    return ret.toTypedArray()
&#125;
</code></pre>
<h4 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. Length of Last Word</h4><p>Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0.</p>
<p>A word is a maximal substring consisting of non-space characters only.</p>
<pre><code class="kotlin">fun lengthOfLastWord(s: String): Int &#123;
    var ret = 0
    var end = s.length - 1
    //trim tail
    while (end &gt;= 0) &#123;
        if (s[end] != &#39; &#39;) &#123;
            break
        &#125; else &#123;
            end--
        &#125;
    &#125;

    while (end &gt;= 0) &#123;
        if (s[end] == &#39; &#39;) &#123;
            break
        &#125; else &#123;
            end--
            ret++
        &#125;
    &#125;
    return ret
&#125;
</code></pre>
<h4 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a>59. Spiral Matrix II</h4><p>Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.</p>
<pre><code class="kotlin">fun generateMatrix(n: Int): Array&lt;IntArray&gt; &#123;
    val ret = Array(n) &#123; IntArray(n) &#125;
    var x = 1
    var left = 0
    var top = 0
    var right = n - 1
    var bottom = n - 1
    while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;
        for (i in left .. right) &#123;
            ret[top][i] = x++
        &#125;

        for (i in top + 1 .. bottom) &#123;
            ret[i][right] = x++
        &#125;

        for (i in right - 1 downTo left) &#123;
            ret[bottom][i] = x++
        &#125;

        for (i in bottom - 1 downTo top + 1) &#123;
            ret[i][left] = x++
        &#125;
        top++
        left++
        right--
        bottom--
    &#125;
    return ret
&#125;
</code></pre>
<h4 id="60-Permutation-Sequence"><a href="#60-Permutation-Sequence" class="headerlink" title="60. Permutation Sequence"></a>60. Permutation Sequence</h4><p>The set [1, 2, 3, …, n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</p>
<pre><code>&quot;123&quot;
&quot;132&quot;
&quot;213&quot;
&quot;231&quot;
&quot;312&quot;
&quot;321&quot;
</code></pre><p>Given n and k, return the kth permutation sequence.</p>
<pre><code class="kotlin">fun getPermutation(n: Int, k: Int): String &#123;
  val exponents = IntArray(n)
  exponents[0] = 1
  for (i in 1 .. n - 1) &#123;
    exponents[i] = i * exponents[i - 1]
  &#125;
  val ret = StringBuilder()
  val readySelectArr = (1..n).toMutableList()
  var k = k - 1
  for (i in n downTo 1) &#123;
    val cur = k / exponents[i - 1]
    ret.append(readySelectArr.removeAt(cur))
    k -= cur * exponents[i - 1]
  &#125;
  return ret.toString()
&#125;
</code></pre>
<p>Note: 注意数组下标从0开始，即求k-1个</p>
<h4 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. Rotate List</h4><p>Given the head of a linked list, rotate the list to the right by k places.</p>
<pre><code class="kotlin">fun rotateRight(head: ListNode?, k: Int): ListNode? &#123;
    if (head?.next == null) &#123;
        return head
    &#125;
    var size = 0
    var tmp = head
    while (tmp != null) &#123;
        tmp = tmp.next
        size++
    &#125;
    val dummyHead = ListNode(0)
    dummyHead.next = head
    var n = k % size
    while (n &gt; 0) &#123;
        var cur = dummyHead.next
        var curNext = cur?.next
        while (curNext?.next != null) &#123;
            cur = cur?.next
            curNext = curNext.next
        &#125;
        cur?.next = null
        curNext?.next = dummyHead.next
        dummyHead.next = curNext
        n--
    &#125;
    return dummyHead.next
&#125;


//way 2:

fun rotateRight(head: ListNode?, k: Int): ListNode? &#123;
    if (head?.next == null) &#123;
        return head
    &#125;
    var size = 1
    var iter = head
    while (iter?.next != null) &#123;
        iter = iter.next
        size++
    &#125;
    iter?.next = head// tail
    var pre = size - k % size

    iter = head
    while (pre &gt; 1) &#123;
        iter = iter?.next
        pre --
    &#125;
    val ret = iter?.next
    iter?.next = null
    return ret
&#125;
</code></pre>
<p>Note: 利用求余数的方法得到有效的的旋转次数。 way 2 闭合环遍历断开</p>
<h4 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h4><p>[Dynamic Programing]</p>
<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<pre><code class="kotlin">fun uniquePaths(m: Int, n: Int): Int &#123;
    val dp = IntArray(n)
    for (i in 0..n - 1) &#123;
        dp[i] = 1
    &#125;
    for (i in 1..m - 1) &#123;
        for (j in 1..n - 1) &#123;
            dp[j] = dp[j - 1] + dp[j]
        &#125;
    &#125;
    return dp[n - 1]
&#125;
</code></pre>
<p>Note: 回溯，递归超时;  滚动数组优化空间</p>
<h4 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a>63. Unique Paths II</h4><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and space is marked as 1 and 0 respectively in the grid.</p>
<pre><code class="kotlin">fun uniquePathsWithObstacles(obstacleGrid: Array&lt;IntArray&gt;): Int &#123;
    val m = obstacleGrid.size
    val n = obstacleGrid[0].size
    if (obstacleGrid[m - 1][n - 1] == 1) &#123;
        return 0
    &#125;
    val dp = IntArray(n) &#123; 0 &#125;

    for (i in 0..n - 1) &#123;
        if (obstacleGrid[0][i] == 1) &#123;
            break
        &#125;
        dp[i] = 1
    &#125;

    for (i in 1 .. m - 1) &#123;
        for (j in 0 .. n - 1) &#123;
            if (j == 0) &#123;
                if (obstacleGrid[i][0] == 1) &#123;
                    dp[j] = 0
                &#125;
            &#125; else &#123;
                val part1 = if(obstacleGrid[i][j] == 1) 0 else dp[j]
                val part2 = if(obstacleGrid[i][j] == 1) 0 else dp[j - 1]
                dp[j] = part1 + part2
            &#125;
        &#125;
    &#125;
    return dp[n - 1]
&#125;
</code></pre>
<p>Note：状态压缩</p>
<h4 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h4><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<pre><code class="kotlin">fun minPathSum(grid: Array&lt;IntArray&gt;): Int &#123;
    val m = grid.size
    val n = grid[0].size
    val dp = IntArray(n)
    dp[0] = grid[0][0]
    for (i in 1..n - 1) &#123;
        dp[i] = grid[0][i] + dp[i - 1]
    &#125;
    for (i in 1..m - 1) &#123;
        for (j in 0..n - 1) &#123;
            if (j == 0) &#123;
                dp[j] = grid[i][j] + dp[j]
            &#125; else &#123;
                dp[j] = grid[i][j] + Math.min(dp[j - 1], dp[j])
            &#125;
        &#125;
    &#125;
    return dp[n - 1]
&#125;
</code></pre>
<h3 id="65-Valid-Number"><a href="#65-Valid-Number" class="headerlink" title="65. Valid Number"></a>65. Valid Number</h3><p>[String | FSM]</p>
<p>A valid number can be split up into these components (in order):</p>
<pre><code>A decimal number or an integer.
(Optional) An &#39;e&#39; or &#39;E&#39;, followed by an integer.
</code></pre><p>A decimal number can be split up into these components (in order):</p>
<pre><code>(Optional) A sign character (either &#39;+&#39; or &#39;-&#39;).
One of the following formats:
    At least one digit, followed by a dot &#39;.&#39;.
    At least one digit, followed by a dot &#39;.&#39;, followed by at least one digit.
    A dot &#39;.&#39;, followed by at least one digit.
</code></pre><p>An integer can be split up into these components (in order):</p>
<pre><code>(Optional) A sign character (either &#39;+&#39; or &#39;-&#39;).
At least one digit.
</code></pre><p>For example, all the following are valid numbers: [“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”], while the following are not valid numbers: [“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”].</p>
<p>Given a string s, return true if s is a valid number.</p>
<pre><code class="kotlin">data class ContextData(var decimal: Boolean, var exponential: Boolean)

enum class StateMachine &#123;

    INVALID &#123;
        override fun next(c: Char, context: ContextData): StateMachine &#123;
            TODO(&quot;Not yet implemented&quot;)
        &#125;
    &#125;,

    START &#123;
        override fun next(c: Char, context: ContextData): StateMachine &#123;
            if ((c == &#39;+&#39; || c == &#39;-&#39;)) &#123;
                return INTEGER
            &#125; else if (c.isDigit()) &#123;
                context.decimal = true
                return INTEGER
            &#125; else if (c == &#39;.&#39;) &#123;
                return FRACTION
            &#125; else &#123;
                return INVALID
            &#125;
        &#125;
    &#125;,

    INTEGER &#123;
        override fun next(c: Char, context: ContextData): StateMachine &#123;
            if (c.isDigit()) &#123;
                context.decimal = true
                return this
            &#125; else if (c == &#39;.&#39;) &#123;
                return FRACTION
            &#125; else if (c == &#39;e&#39; || c == &#39;E&#39;) &#123;
                context.exponential = false
                return E_SIGN
            &#125; else &#123;
                return INVALID
            &#125;
        &#125;
    &#125;,


    FRACTION &#123;
        override fun next(c: Char, context: ContextData): StateMachine &#123;
            if (c.isDigit()) &#123;
                context.decimal = true
                return this
            &#125; else if (c == &#39;e&#39; || c == &#39;E&#39;) &#123;
                context.exponential = false
                return E_SIGN
            &#125; else &#123;
                return INVALID
            &#125;
        &#125;
    &#125;,


    E_SIGN &#123;
        override fun next(c: Char, context: ContextData): StateMachine &#123;
            if (!context.decimal) &#123;
                return INVALID
            &#125;
            if (c == &#39;+&#39; || c == &#39;-&#39;) &#123;
                context.exponential = false
                return E_INTEGER
            &#125; else if (c.isDigit())&#123;
                context.exponential = true
                return E_INTEGER
            &#125; else &#123;
                return INVALID
            &#125;
        &#125;
    &#125;,

    E_INTEGER &#123;
        override fun next(c: Char, context: ContextData): StateMachine &#123;
            if (!context.decimal) &#123;
                return INVALID
            &#125; else if (c.isDigit()) &#123;
                context.exponential = true
                return this
            &#125; else &#123;
                return INVALID
            &#125;
        &#125;
    &#125;;

    abstract fun next(c: Char, context: ContextData): StateMachine
&#125;


fun isNumber(s: String): Boolean &#123;
    val context = ContextData(false, true)
    var stateMachine = StateMachine.START
    for (c in s) &#123;
        stateMachine = stateMachine.next(c, context)
        if (stateMachine == StateMachine.INVALID) &#123;
            return false
        &#125;
    &#125;
    return context.decimal &amp;&amp; context.exponential
&#125;
</code></pre>
<h4 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a>66. Plus One</h4><p>[Array]</p>
<p>Given a non-empty array of decimal digits representing a non-negative integer, increment one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<pre><code class="kotlin">fun plusOne(digits: IntArray): IntArray &#123;
    var carry = 1
    for (i in digits.size - 1 downTo 0) &#123;
        if (carry == 0) &#123;
            break
        &#125;
        val add = digits[i] + carry
        digits[i] = add % 10
        carry = add / 10
    &#125;
    if (carry == 1) &#123;
        return IntArray(digits.size + 1)&#123;
            if (it == 0) &#123;
                1
            &#125; else &#123;
                0
            &#125;
        &#125;
    &#125; else &#123;
        return digits
    &#125;
&#125;
</code></pre>
<h4 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67. Add Binary"></a>67. Add Binary</h4><p>Given two binary strings a and b, return their sum as a binary string.</p>
<pre><code class="kotlin">fun addBinary(a: String, b: String): String &#123;
    val ret = StringBuilder()
    var ia = a.length - 1
    var ib = b.length - 1
    var carry = &#39;0&#39;
    while (true) &#123;
        val ca = if (ia &gt;= 0) a[ia--] else &#39;0&#39;
        val cb = if (ib &gt;= 0) b[ib--] else &#39;0&#39;
        if (ca == cb) &#123;
            if (ca == &#39;0&#39;) &#123;
                ret.append(carry)
                carry = &#39;0&#39;
            &#125; else &#123;
                ret.append(carry)
                carry = &#39;1&#39;
            &#125;
        &#125; else &#123;
            if (carry == &#39;1&#39;) &#123;
                ret.append(&#39;0&#39;)
            &#125; else &#123;
                ret.append(&#39;1&#39;)
            &#125;
        &#125;

        if (ia &lt; 0 &amp;&amp; ib &lt; 0) &#123;
            if (carry == &#39;1&#39;) &#123;
                ret.append(&#39;1&#39;)
            &#125;
            break
        &#125;
    &#125;

    return ret.reverse().toString()
&#125;
</code></pre>
<h4 id="68-Text-Justification"><a href="#68-Text-Justification" class="headerlink" title="68. Text Justification"></a>68. Text Justification</h4><p>Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly maxWidth characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<p>Note:</p>
<ul>
<li>A word is defined as a character sequence consisting of non-space characters only.</li>
<li>Each word’s length is guaranteed to be greater than 0 and not exceed maxWidth.</li>
<li>The input array words contains at least one word.</li>
</ul>
<pre><code class="kotlin">fun fullJustify(words: Array&lt;String&gt;, maxWidth: Int): List&lt;String&gt; &#123;
    fun appendBlankChars(builder: StringBuilder, n: Int) &#123;
        for (i in 1..n) &#123;
            builder.append(&quot; &quot;)
        &#125;
    &#125;

    fun processLine(startIndex: Int, endIndex: Int): String &#123;
        var totalBlankLen = 0
        for (i in startIndex..endIndex) &#123;
            totalBlankLen += words[i].length
        &#125;
        totalBlankLen = maxWidth - totalBlankLen
        val intervals = endIndex - startIndex
        val lineStr = StringBuilder()
        if (intervals == 0) &#123;
            lineStr.append(words[startIndex])
            appendBlankChars(lineStr, maxWidth - lineStr.length)
        &#125; else &#123;
            val blanksOfInterval = IntArray(intervals)
            var i = 0
            while (totalBlankLen &gt; 0) &#123;
                blanksOfInterval[i]++
                i++
                if (i == blanksOfInterval.size) &#123;
                    i = 0
                &#125;
                totalBlankLen--
            &#125;
            var j = 0
            for (i in startIndex..endIndex) &#123;
                lineStr.append(words[i])
                if (i != endIndex) &#123;
                    appendBlankChars(lineStr, blanksOfInterval[j++])
                &#125;
            &#125;
        &#125;
        return lineStr.toString()
    &#125;

    val ret = mutableListOf&lt;String&gt;()
    var curLineWidth = 0
    var startWordIndex = 0
    var endWordIndex = 0
    for (wordIndex in 0..words.size - 1) &#123;
        curLineWidth = curLineWidth + words[wordIndex].length
        if (curLineWidth == maxWidth) &#123;
            endWordIndex = wordIndex

            ret.add(processLine(startWordIndex, endWordIndex))

            curLineWidth = 0
            startWordIndex = endWordIndex + 1
        &#125; else if (curLineWidth &lt; maxWidth) &#123;
            curLineWidth++
            continue
        &#125; else &#123; //curLineWidth &gt; maxWidth
            endWordIndex = wordIndex - 1

            ret.add(processLine(startWordIndex, endWordIndex))

            startWordIndex = wordIndex
            curLineWidth = words[startWordIndex].length + 1
        &#125;
    &#125;

    if (startWordIndex &lt;= words.size - 1) &#123;
        val lineStr = StringBuilder()
        for (i in startWordIndex..words.size - 1) &#123;
            lineStr.append(words[i])
            if (i != words.size - 1) &#123;
                lineStr.append(&quot; &quot;)
            &#125;
        &#125;
        appendBlankChars(lineStr, maxWidth - lineStr.length)
        ret.add(lineStr.toString())
    &#125;
    return ret
&#125;
</code></pre>
<h4 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a>69. Sqrt(x)</h4><p>Given a non-negative integer x, compute and return the square root of x.</p>
<p>Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.</p>
<pre><code class="kotlin">fun mySqrt(x: Int): Int &#123;
    var startVal = 1
    var endVal = x
    while (startVal &lt;= endVal) &#123;
        val mid = startVal + (endVal - startVal) / 2
        if (mid &gt; Int.MAX_VALUE / mid) &#123;
            endVal = mid - 1
            continue
        &#125;
        val v = mid * mid
        if (v == x) &#123;
            return mid
        &#125; else if (v &gt; x) &#123;
            endVal = mid - 1
        &#125; else &#123;
            startVal = mid + 1
        &#125;
    &#125;
    return endVal
&#125;
</code></pre>
<p>Note: 防止溢出操作</p>
<h4 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h4><p>[Dynamic Progroming]</p>
<p>You are climbing a staircase. It takes n steps to reach the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<pre><code class="kotlin">fun climbStairs(n: Int): Int &#123;
  var first = 1
  var second = 1
  for (i in 2 .. n) &#123;
    val tmp = first
    first += second
    second = tmp

  &#125;
  return first
&#125;
</code></pre>
<h4 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a>71. Simplify Path</h4><p>Given a string path, which is an absolute path (starting with a slash ‘/‘) to a file or directory in a Unix-style file system, convert it to the simplified canonical path.</p>
<p>In a Unix-style file system, a period ‘.’ refers to the current directory, a double period ‘..’ refers to the directory up a level, and any multiple consecutive slashes (i.e. ‘//‘) are treated as a single slash ‘/‘. For this problem, any other format of periods such as ‘…’ are treated as file/directory names.</p>
<p>The canonical path should have the following format:</p>
<ul>
<li>The path starts with a single slash ‘/‘.</li>
<li>Any two directories are separated by a single slash ‘/‘.</li>
<li>The path does not end with a trailing ‘/‘.</li>
<li>The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period ‘.’ or double period ‘..’)</li>
</ul>
<p>Return the simplified canonical path.</p>
<pre><code class="kotlin">enum class PathState &#123;
  INIT,
  SlashStart,
  DotStart,
  DotEnd,
  CHAR
&#125;

fun simplifyPath(path: String): String &#123;
  var curSlashStart = 0
  var state = PathState.INIT
  val stack = LinkedList&lt;String&gt;()
  for ((index, c) in path.withIndex()) &#123;
    if (c == &#39;/&#39;) &#123;
      if (state == PathState.INIT) &#123;
        curSlashStart = index
        state = PathState.SlashStart
      &#125; else if (state == PathState.DotStart) &#123;
        state = PathState.SlashStart
        curSlashStart = index
      &#125; else if (state == PathState.DotEnd) &#123;
        if (!stack.isEmpty()) &#123;
          stack.pop()
        &#125;
        state = PathState.SlashStart
        curSlashStart = index
      &#125; else if (state == PathState.CHAR) &#123;
        stack.push(path.substring(curSlashStart + 1..index - 1))
        curSlashStart = index
        state = PathState.SlashStart
      &#125; else if (state == PathState.SlashStart) &#123;
        curSlashStart = index
      &#125;
    &#125; else if (c == &#39;.&#39;) &#123;
      if (state == PathState.SlashStart) &#123;
        state = PathState.DotStart
      &#125; else if (state == PathState.DotStart) &#123;
        state = PathState.DotEnd
      &#125; else if (state == PathState.DotEnd) &#123;
        state = PathState.CHAR
      &#125;
    &#125; else &#123;
      state = PathState.CHAR
    &#125;
  &#125;

  if (state == PathState.DotEnd) &#123;
    if (stack.isNotEmpty()) &#123;
      stack.pop()
    &#125;
  &#125; else if (state == PathState.CHAR) &#123;
    stack.push(path.substring(curSlashStart + 1..path.length - 1))
  &#125;

  val ret = StringBuilder()
  ret.append(&quot;/&quot;)
  while (stack.isNotEmpty()) &#123;
    ret.append(stack.removeLast())
    ret.append(&quot;/&quot;)
  &#125;
  if (ret.length &gt; 1) &#123;
    ret.deleteCharAt(ret.length - 1)
  &#125;
  return ret.toString()
&#125;
</code></pre>
<h4 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h4><p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following three operations permitted on a word:</p>
<ul>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ul>
<pre><code class="kotlin">fun minDistance(word1: String, word2: String): Int &#123;
    val A = word1.length
    val B = word2.length
    if (A * B == 0) &#123;
        return A + B
    &#125;

    val dp = Array(A + 1) &#123; IntArray(B + 1) &#125;
    for (i in 0 .. A) &#123;
        dp[i][0] = i
    &#125;
    for (i in 0 .. B) &#123;
        dp[0][i] = i
    &#125;

    for (i in 1 .. A) &#123;
        for (j in 1 ..B) &#123;
            dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)
            if (word1[i - 1] == word2[j - 1]) &#123;
                dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i][j])
            &#125; else &#123;
                dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, dp[i][j])
            &#125;

        &#125;
    &#125;
    return dp[A][B]
&#125;
</code></pre>
<h4 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73. Set Matrix Zeroes"></a>73. Set Matrix Zeroes</h4><p>Given an m x n matrix. If an element is 0, set its entire row and column to 0. Do it in-place.</p>
<p>Follow up:</p>
<ul>
<li>A straight forward solution using O(mn) space is probably a bad idea.</li>
<li>A simple improvement uses O(m + n) space, but still not the best solution.</li>
<li>Could you devise a constant space solution? </li>
</ul>
<pre><code class="kotlin">fun setZeroes(matrix: Array&lt;IntArray&gt;): Unit &#123;
    val m = matrix.size
    val n = matrix[0].size
    var row0Zero = false
    var col0Zero = false
    for (i in 0..m - 1) &#123;
        if (matrix[i][0] == 0) &#123;
            col0Zero = true
            break
        &#125;
    &#125;

    for (i in 0..n - 1) &#123;
        if (matrix[0][i] == 0) &#123;
            row0Zero = true
            break
        &#125;
    &#125;

    for (i in 1..m - 1) &#123;
        for (j in 1..n - 1) &#123;
            if (matrix[i][j] == 0) &#123;
                matrix[0][j] = 0
                matrix[i][0] = 0
            &#125;
        &#125;
    &#125;

    for (i in 1..m - 1) &#123;
        for (j in 1..n - 1) &#123;
            if (matrix[0][j] == 0 || matrix[i][0] == 0) &#123;
                matrix[i][j] = 0
            &#125;
        &#125;
    &#125;

    if (col0Zero) &#123;
        for (i in 0..m - 1) &#123;
            matrix[i][0] = 0
        &#125;
    &#125;

    if (row0Zero) &#123;
        for (i in 0..n - 1) &#123;
            matrix[0][i] = 0
        &#125;
    &#125;
&#125;
</code></pre>
<p>Note: O(1)空间</p>
<h4 id="74-Search-a-2D-Matrix"><a href="#74-Search-a-2D-Matrix" class="headerlink" title="74. Search a 2D Matrix"></a>74. Search a 2D Matrix</h4><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<pre><code class="kotlin">fun searchMatrix(matrix: Array&lt;IntArray&gt;, target: Int): Boolean &#123;
    val m = matrix.size
    val n = matrix[0].size
    var start = 0
    var end = m * n - 1
    while (start &lt;= end) &#123;
        val mid = (start + end) / 2
        val midVal = matrix[mid / n][mid % n]
        if (target == midVal) &#123;
            return true
        &#125; else if (target &gt; midVal) &#123;
            start = mid + 1
        &#125; else &#123;
            end = mid - 1
        &#125;
    &#125;
    return false
&#125;
</code></pre>
<h5 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a>75. Sort Colors</h5><p>Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p>
<p>We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.</p>
<pre><code class="kotlin">//counter sort
fun sortColors(nums: IntArray): Unit &#123;
    val counter = IntArray(3)
    for (v in nums) &#123;
        counter[v]++
    &#125;
    var i = 0
    for ((index, c) in counter.withIndex()) &#123;
        for (ci in 1..c) &#123;
            nums[i++] = index
        &#125;
    &#125;
&#125;


//two pointer
fun sortColors(nums: IntArray): Unit &#123;
    fun swap(i: Int, j: Int) &#123;
        val tmp = nums[i]
        nums[i] = nums[j]
        nums[j] = tmp
    &#125;

    var left = 0
    var right = nums.size - 1
    var i = 0
    while (i &lt;= right) &#123;
        if (nums[i] == 0) &#123;
            swap(i, left)
            left++
        &#125; else if (nums[i] == 2) &#123;
            swap(i, right)
            right--
            if (nums[i] != 1) &#123;
                i--
            &#125;
        &#125;
        i++
    &#125;
&#125;
</code></pre>
<h4 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h4><p>[Sliding Window | Hash Table | Two Pointers]</p>
<p>Given two strings s and t, return the minimum window in s which will contain all the characters in t. If there is no such window in s that covers all characters in t, return the empty string “”.</p>
<p>Note that If there is such a window, it is guaranteed that there will always be only one unique minimum window in s.</p>
<pre><code class="kotlin">fun minWindow(s: String, t: String): String &#123;
    val tMap = mutableMapOf&lt;Char, Int&gt;()
    for (c in t) &#123;
        tMap[c] = tMap.getOrDefault(c, 0) + 1
    &#125;
    var found =  false
    var minStartIndex = 0
    var minEndIndex = s.length - 1
    var startIndex = 0
    var endIndex = 0
    var count = t.length
    while (endIndex &lt; s.length) &#123;
        val endEntryCnt = tMap.get(s[endIndex])
        if (endEntryCnt != null) &#123;
            tMap.put(s[endIndex], endEntryCnt - 1)
            if (endEntryCnt &gt; 0) &#123;
                count--
            &#125;
        &#125;
        while (count == 0) &#123;
            found = true
            if (endIndex - startIndex &lt; minEndIndex - minStartIndex) &#123;
                minStartIndex = startIndex
                minEndIndex = endIndex
            &#125;
            val startEntryCnt = tMap.get(s[startIndex])
            if (startEntryCnt != null) &#123;
                tMap.put(s[startIndex], startEntryCnt + 1)
                if (startEntryCnt + 1 &gt; 0) &#123;
                    count++
                &#125;
            &#125;
            startIndex++
        &#125;
        endIndex++
    &#125;
    return if (found) s.substring(minStartIndex..minEndIndex) else &quot;&quot;
&#125;
</code></pre>
<p>Note: 注意t会有重复的子串</p>
<h4 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h4><p>Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].</p>
<p>You may return the answer in any order.</p>
<pre><code class="kotlin">val ret8 = mutableListOf&lt;List&lt;Int&gt;&gt;()

fun combine(n: Int, k: Int): List&lt;List&lt;Int&gt;&gt; &#123;
    combineRecur(n, 1, k, mutableListOf())
    return ret8
&#125;

fun combineRecur(n: Int, start:Int, k: Int, path: MutableList&lt;Int&gt;)&#123;
    if (k == 0) &#123;
        ret8.add(ArrayList(path))
        return
    &#125;
    for (i in start..n) &#123;
        path.add(i)
        combineRecur(n, i + 1, k - 1, path)
        path.removeAt(path.size - 1)
    &#125;
&#125;
</code></pre>
<h4 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h4><p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p>
<p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>
<pre><code class="kotlin">val ret10 = mutableListOf&lt;List&lt;Int&gt;&gt;()

fun subsets(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;
    subsetsRecur(nums, 0, mutableListOf())
    return ret10
&#125;

fun subsetsRecur(nums: IntArray, start: Int, path: MutableList&lt;Int&gt;) &#123;
    ret10.add(ArrayList(path))
    if (start == nums.size || path.size == nums.size) &#123;
        return
    &#125;

    for (i in start..nums.size - 1) &#123;
        path.add(nums[i])
        subsetsRecur(nums, i + 1, path)
        path.removeAt(path.size - 1)
    &#125;
&#125;
</code></pre>
<h4 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h4><p>Given an m x n grid of characters board and a string word, return true if word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<pre><code class="kotlin">fun exist(board: Array&lt;CharArray&gt;, word: String): Boolean &#123;
    val visited = Array(board.size)&#123;BooleanArray(board[0].size)&#125;
    for (i in 0..board.size - 1) &#123;
        for (j in 0..board[0].size - 1) &#123;
            if (existRecur(i, j, board, word, 0, visited)) &#123;
                return true
            &#125;
        &#125;
    &#125;
    return false
&#125;

fun existRecur(i: Int, j:Int, board: Array&lt;CharArray&gt;, word: String, wordCur: Int, visited: Array&lt;BooleanArray&gt;): Boolean &#123;
    if (i &lt; 0 || i &gt; board.size - 1 || j &lt; 0 || j &gt; board[0].size - 1 || visited[i][j] ||board[i][j] != word[wordCur]) &#123;
        return false
    &#125;
    visited[i][j] = true

    if (wordCur == word.length - 1) &#123;
        return true
    &#125;
    if (existRecur(i, j - 1, board, word, wordCur + 1, visited)) &#123;
        return true
    &#125;

    if (existRecur(i, j + 1, board, word, wordCur + 1, visited)) &#123;
        return true
    &#125;

    if (existRecur(i - 1, j, board, word, wordCur + 1, visited)) &#123;
        return true
    &#125;

    if (existRecur(i + 1, j, board, word, wordCur + 1, visited)) &#123;
        return true
    &#125;
    visited[i][j] = false
    return false
&#125;
</code></pre>
<h4 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80. Remove Duplicates from Sorted Array II"></a>80. Remove Duplicates from Sorted Array II</h4><p>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.</p>
<p>Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>Clarification:</p>
<p>Confused why the returned value is an integer, but your answer is an array?</p>
<p>Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller.</p>
<p>Internally you can think of this:</p>
<p>// nums is passed in by reference. (i.e., without making a copy)<br>int len = removeDuplicates(nums);</p>
<p>// any modification to nums in your function would be known by the caller.<br>// using the length returned by your function, it prints the first len elements.<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p>
<pre><code class="kotlin">fun removeDuplicates(nums: IntArray): Int &#123;
    if (nums.size &lt;= 2) &#123;
        return 2
    &#125;
    nums.sort()
    var slow = 2
    for (fast in 2..nums.size - 1) &#123;
        if (nums[slow - 2] != nums[fast]) &#123;
            nums[slow] = nums[fast]
            slow++
        &#125;
    &#125;
    return slow
&#125;
</code></pre>
<p>Note: 移动慢指针条件； 和慢指针前两个元素对比</p>
<h4 id="81-Search-in-Rotated-Sorted-Array-II"><a href="#81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="81. Search in Rotated Sorted Array II"></a>81. Search in Rotated Sorted Array II</h4><p> There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).</p>
<p>Before being passed to your function, nums is rotated at an unknown pivot index k (0 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].</p>
<p>Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.</p>
<pre><code class="kotlin">fun search(nums: IntArray, target: Int): Boolean &#123;
    var start = 0
    var end = nums.size - 1
    while (start &lt;= end) &#123;
        val mid = (start + end) / 2
        if (nums[mid] == target) &#123;
            return true
        &#125; else &#123;
            if (nums[mid] == nums[start] &amp;&amp; nums[mid] == nums[end]) &#123;
                start++
                end--
            &#125; else  if (nums[mid] &lt;= nums[end]) &#123;//right sorted
                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) &#123;
                    start = mid + 1
                &#125; else &#123;
                    end = mid - 1
                &#125;
            &#125; else if (nums[mid] &gt;= nums[start]) &#123;//left sorted
                if (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;
                    end = mid - 1
                &#125; else &#123;
                    start = mid + 1
                &#125;
            &#125;
        &#125;
    &#125;
    return false
&#125;
</code></pre>
<h4 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82. Remove Duplicates from Sorted List II"></a>82. Remove Duplicates from Sorted List II</h4><p>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.</p>
<pre><code class="kotlin">fun deleteDuplicates(head: ListNode?): ListNode? &#123;
    val dummyNode = ListNode(0, head)
    var pre = dummyNode
    var cur = head
    while (cur != null) &#123;
        if (cur.`val` == cur.next?.`val`) &#123;
            var tmp = cur
            while (tmp != null &amp;&amp; tmp.`val` == tmp.next?.`val`) &#123;
                tmp = tmp.next
            &#125;
            cur = tmp?.next
            pre.next = cur
        &#125; else &#123;
            pre = cur
            cur = cur.next
        &#125;
    &#125;
    return dummyNode.next
&#125;
</code></pre>
<h4 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a>83. Remove Duplicates from Sorted List</h4><p>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.</p>
<pre><code class="kotlin">fun deleteDuplicates(head: ListNode?): ListNode? &#123;
    var cur = head
    while (cur?.next != null) &#123;
        if (cur.`val` == cur.next?.`val`) &#123;
            cur.next = cur.next?.next
        &#125; else &#123;
            cur = cur.next
        &#125;
    &#125;
    return head
&#125;
</code></pre>
<p>!!!先跳过Hard….</p>
<h4 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a>86. Partition List</h4><p>Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<pre><code class="kotlin">fun partition(head: ListNode?, x: Int): ListNode? &#123;
    val dummyHeadLeft = ListNode(0)
    var curLeft = dummyHeadLeft
    val dummyHeadRight = ListNode(0)
    var curRight = dummyHeadRight
    var cur = head
    while (cur != null) &#123;
        if (cur.`val` &lt; x) &#123;
            curLeft.next = cur
            curLeft = cur
        &#125; else&#123;
            curRight.next = cur
            curRight = cur
        &#125;
        cur = cur.next
    &#125;
    //merge two list
    curRight.next = null
    curLeft.next = dummyHeadRight.next
    return dummyHeadLeft.next
&#125;
</code></pre>
<p>Note: 注意出现循环链表</p>
<h4 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a>88. Merge Sorted Array</h4><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has a size equal to m + n such that it has enough space to hold additional elements from nums2.</p>
<pre><code class="kotlin">fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit &#123;
    if (n &lt;=0) &#123;
        return
    &#125;
    var cur = nums1.size - 1
    var p1 = m - 1
    var p2 = n - 1
    while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) &#123;
        if (nums1[p1] &gt; nums2[p2]) &#123;
            nums1[cur--] = nums1[p1--]
        &#125; else &#123;
            nums1[cur--] = nums2[p2--]
        &#125;
    &#125;

    while (p2 &gt;= 0) &#123;
        nums1[cur--] = nums2[p2--]
    &#125;
&#125;
</code></pre>
<h4 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89. Gray Code"></a>89. Gray Code</h4><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given an integer n representing the total number of bits in the code, return any sequence of gray code.</p>
<p>A gray code sequence must begin with 0.</p>
<pre><code class="kotlin">val grayCodeRet = mutableListOf&lt;Int&gt;()

fun grayCode(n: Int): List&lt;Int&gt; &#123;
    val path = StringBuilder()
    grayCodeRecur(0, n, true, path)
    path.deleteCharAt(path.length - 1)
    grayCodeRecur(1, n, false, path)
    //println(grayCodeRet)
    return grayCodeRet
&#125;

fun grayCodeRecur(cur: Int, n: Int, left: Boolean, path: StringBuilder) &#123;
    path.append(cur)
    if (path.length &gt;= n) &#123;
        grayCodeRet.add(Integer.parseInt(path.toString(), 2))
        return
    &#125;
    if (left) &#123;
        grayCodeRecur(0, n, true, path)
        path.deleteCharAt(path.length - 1)
        grayCodeRecur(1, n, false, path)
        path.deleteCharAt(path.length - 1)
    &#125; else &#123;
        grayCodeRecur(1, n, true, path)
        path.deleteCharAt(path.length - 1)
        grayCodeRecur(0, n, false, path)
        path.deleteCharAt(path.length - 1)
    &#125;
&#125;
</code></pre>
<h4 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h4><p>Given an integer array nums that may contain duplicates, return all possible subsets (the power set).</p>
<p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>
<pre><code class="kotlin">val ret11 = mutableListOf&lt;List&lt;Int&gt;&gt;()

fun subsetsWithDup(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;
    nums.sort()
    subsetsWithDupRecur(nums, 0, mutableListOf())
    return ret11
&#125;

fun subsetsWithDupRecur(nums: IntArray, start: Int, path: MutableList&lt;Int&gt;) &#123;
    ret11.add(ArrayList(path))
    if (start &gt;= nums.size) &#123;
        return
    &#125;
    for (i in start..nums.size - 1) &#123;
        if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123;
            continue
        &#125;
        path.add(nums[i])
        subsetsWithDupRecur(nums, i + 1, path)
        path.removeAt(path.size - 1)
    &#125;
&#125;
</code></pre>
<h4 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h4><p>A message containing letters from A-Z can be encoded into numbers using the following mapping:</p>
<p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”</p>
<p>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into:</p>
<pre><code>&quot;AAJF&quot; with the grouping (1 1 10 6)
&quot;KJF&quot; with the grouping (11 10 6)
</code></pre><p>Note that the grouping (1 11 06) is invalid because “06” cannot be mapped into ‘F’ since “6” is different from “06”.</p>
<p>Given a string s containing only digits, return the number of ways to decode it.</p>
<p>The answer is guaranteed to fit in a 32-bit integer.</p>
<pre><code class="kotlin">fun numDecodings(s: String): Int &#123;
    val dp = IntArray(s.length + 1)
    dp[0] = 1
    for (i in 0..s.length - 1) &#123;
        if (s[i] != &#39;0&#39;) &#123;
            dp[i + 1] = dp[i]
        &#125;

        if (i &gt; 0 &amp;&amp; s[i - 1] != &#39;0&#39; &amp;&amp; ((s[i - 1] - &#39;0&#39;) * 10 + (s[i] - &#39;0&#39;)) &lt;= 26) &#123;
            dp[i + 1] += dp[i - 1]
        &#125;
    &#125;
    return dp[s.length]
&#125;
</code></pre>
<h4 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a>92. Reverse Linked List II</h4><p>Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.</p>
<pre><code class="kotlin">fun reverseBetween(head: ListNode?, left: Int, right: Int): ListNode? &#123;
    val dummyHead = ListNode(0)
    dummyHead.next = head
    var cur = head
    var i = 1
    var before: ListNode? = null
    while (i &lt; left) &#123;
        before = cur
        cur = cur?.next
        i++
    &#125;
    val rangeTail = cur
    var after = cur
    var pre: ListNode? = null
    while (cur != null &amp;&amp; i &lt;= right) &#123;
        val next = cur.next
        cur.next = pre
        pre = cur
        cur = next
        i++
        after = next
    &#125;
    val rangeHead = pre
    before?.next = rangeHead
    rangeTail?.next = after
    if (before == null) &#123;
        return rangeHead
    &#125; else &#123;
        return dummyHead.next
    &#125;
&#125;
</code></pre>
<h4 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a>93. Restore IP Addresses</h4><p>Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order.</p>
<p>A valid IP address consists of exactly four integers, each integer is between 0 and 255, separated by single dots and cannot have leading zeros. For example, “0.1.2.201” and “192.168.1.1” are valid IP addresses and “0.011.255.245”, “192.168.1.312” and “<a href="mailto:192.168@1.1">192.168@1.1</a>“ are invalid IP addresses. </p>
<pre><code class="kotlin">val ret = mutableListOf&lt;String&gt;()

fun restoreIpAddresses(s: String): List&lt;String&gt; &#123;
    restoreIpAddressesRecur(s, 0, mutableListOf())
    return ret
&#125;

fun restoreIpAddressesRecur(s: String, start: Int, path: MutableList&lt;String&gt;) &#123;
    if (path.size == 4 &amp;&amp; start == s.length) &#123;
        val builder = StringBuilder()
        for (it in path) &#123;
            builder.append(it).append(&#39;.&#39;)
        &#125;
        builder.deleteCharAt(builder.length - 1)
        ret.add(builder.toString())
        return
    &#125;

    for (i in start .. s.length - 1) &#123;
        if (path.size == 3 &amp;&amp; (s.length - 1 - start) &gt; 3) &#123;
            break
        &#125;
        if (i - start &gt; 0 &amp;&amp; s[start] == &#39;0&#39;) &#123;
            break
        &#125;
        val item = s.subSequence(start .. i).toString()
        if (Integer.parseInt(item) &gt; 255) &#123;
            break
        &#125;
        path.add(item)
        restoreIpAddressesRecur(s, i + 1, path)
        path.removeAt(path.size - 1)
    &#125;
&#125;
</code></pre>
<h4 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h4><p>Given the root of a binary tree, return the inorder traversal of its nodes’ values.</p>
<pre><code class="kotlin">//递归
fun inorderTraversal(root: TreeNode?): List&lt;Int&gt; &#123;
    val ret = mutableListOf&lt;Int&gt;()
    inorderTraversalRecur(root, ret)
    return ret
&#125;

fun inorderTraversalRecur(node: TreeNode?, path: MutableList&lt;Int&gt;) &#123;
    if (node == null) &#123;
        return
    &#125;
    inorderTraversalRecur(node.left, path)
    path.add(node.`val`)
    inorderTraversalRecur(node.right, path)
&#125;

//迭代
fun inorderTraversal(root: TreeNode?): List&lt;Int&gt; &#123;
    val ret = mutableListOf&lt;Int&gt;()
    val stack: Deque&lt;TreeNode&gt; = LinkedList&lt;TreeNode&gt;()
    var cur = root
    while (cur != null || stack.isNotEmpty()) &#123;
        while (cur != null) &#123;
            stack.push(cur)
            cur = cur.left
        &#125;
        cur = stack.pop()
        ret.add(cur.`val`)
        cur = cur.right
    &#125;
    return ret
&#125;
</code></pre>
<h4 id="95-Unique-Binary-Search-Trees-II"><a href="#95-Unique-Binary-Search-Trees-II" class="headerlink" title="95. Unique Binary Search Trees II"></a>95. Unique Binary Search Trees II</h4><p>Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.</p>
<pre><code class="kotlin">fun generateTrees(n: Int): List&lt;TreeNode?&gt; &#123;
    return generateTreesInternal(IntArray(n) &#123;
        it + 1
    &#125;, 0, n - 1)
&#125;

fun generateTreesInternal(arr: IntArray, start: Int, end: Int): List&lt;TreeNode?&gt; &#123;
    val ret = mutableListOf&lt;TreeNode?&gt;()
    if (start &gt; end) &#123;
        ret.add(null)
        return ret
    &#125;
    for (i in start..end) &#123;

        val leftTrees = generateTreesInternal(arr, start, i - 1)
        val rightTrees = generateTreesInternal(arr, i + 1, end)

        for (left in leftTrees) &#123;
            for (right in rightTrees) &#123;
                val root = TreeNode(arr[i])
                root.left = left
                root.right = right
                ret.add(root)
            &#125;
        &#125;
    &#125;
    return ret
&#125;
</code></pre>
<h4 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h4><p>Given an integer n, return the number of structurally unique BST’s (binary search trees) which has exactly n nodes of unique values from 1 to n.</p>
<pre><code class="kotin">//Divide Conquer
fun numTrees(n: Int): Int &#123;
    return numTreesRecur(1, n)
&#125;

fun numTreesRecur(start: Int, end: Int) : Int&#123;
    var ret = 0
    if (start &gt; end) &#123;
        return 1
    &#125;
    for (i in start..end) &#123;
        val leftNum = numTreesRecur(start, i - 1)
        val rightNum = numTreesRecur(i + 1, end)
        ret += leftNum * rightNum
    &#125;
    return ret
&#125;

//Dynamic Programing
fun numTrees(n: Int): Int &#123;
    val G = IntArray(n + 1)
    G[0] = 1
    G[1] = 1
    for (i in 2 .. n) &#123;
        for (k in 1..i) &#123;
            G[i] += G[k - 1] * G [i - k]
        &#125;
    &#125;
    return G[n]
&#125;
</code></pre>
<p>Note: DP的状态转移方程可以从分治推导出来</p>
<h4 id="97-Interleaving-String"><a href="#97-Interleaving-String" class="headerlink" title="97. Interleaving String"></a>97. Interleaving String</h4><p>Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.</p>
<p>An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that:</p>
<ul>
<li>s = s1 + s2 + … + sn</li>
<li>t = t1 + t2 + … + tm</li>
<li>|n - m| &lt;= 1</li>
<li>The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + … or t1 + s1 + t2 + s2 + t3 + s3 + …</li>
</ul>
<p>Note: a + b is the concatenation of strings a and b.</p>
<pre><code class="kotlin">//递归超时.....:
fun isInterleave(s1: String, s2: String, s3: String): Boolean &#123;
    return isInterleave(s1, s1.length - 1, s2, s2.length - 1, s3, s3.length - 1)
&#125;

fun isInterleave(s1: String, i1: Int, s2: String, i2: Int, s3: String, i3: Int): Boolean &#123;
    if (i1 &lt; 0 &amp;&amp; i2 &lt; 0 &amp;&amp; i3 &lt; 0) &#123;
        return true
    &#125;
        if (i1 &gt;=0 &amp;&amp; i3 &gt;= 0 &amp;&amp; s1[i1] == s3[i3] &amp;&amp; isInterleave(s1, i1 - 1, s2, i2, s3, i3 - 1)) &#123;
        return true
    &#125; else if (i2 &gt;= 0 &amp;&amp; i3 &gt;= 0 &amp;&amp; s2[i2] == s3[i3] &amp;&amp; isInterleave(s1, i1, s2, i2 - 1, s3, i3 - 1)) &#123;
        return true
    &#125; else &#123;
        return false
    &#125;
&#125;

//DP:
fun isInterleave(s1: String, s2: String, s3: String): Boolean &#123;
    if (s1.length + s2.length != s3.length) &#123;
        return false
    &#125;
    val dp = Array(s1.length + 1) &#123;BooleanArray(s2.length + 1)&#125;
    dp[0][0] = true
    for (i in 0 .. s1.length) &#123;
        for (j in 0 .. s2.length) &#123;
            if (i &gt; 0 &amp;&amp; s3[i + j - 1] == s1[i - 1] &amp;&amp; dp[i - 1][j]) &#123;
                dp[i][j] = true
            &#125;

            if (j &gt; 0 &amp;&amp; s3[i + j - 1] == s2[j - 1] &amp;&amp; dp[i][j - 1]) &#123;
                dp[i][j] = true
            &#125;
        &#125;
    &#125;
    return dp[s1.length][s2.length]
&#125;
</code></pre>
<h4 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h4><p>Given the root of a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>A valid BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<pre><code class="kotlin">//递归：
var pre: Int? = null

fun isValidBST(root: TreeNode?): Boolean &#123;
    if (root == null) &#123;
        return true
    &#125;
    if (!isValidBST(root.left)) &#123;
        return false
    &#125;
    println(root.`val`)
    if (pre != null &amp;&amp; root.`val` &lt;= pre!!) &#123;
        return false
    &#125; else &#123;
        pre = root.`val`
        return isValidBST(root.right)
    &#125;
&#125;

//迭代
fun isValidBST(root: TreeNode?): Boolean &#123;
    var pre: Int? = null
    val stack = LinkedList&lt;TreeNode&gt;()
    var cur = root
    while (cur != null || stack.isNotEmpty()) &#123;
        while (cur != null) &#123;
            stack.push(cur)
            cur = cur.left
        &#125;
        val top = stack.pop()
        if (pre != null &amp;&amp; top.`val` &lt;= pre) &#123;
            return false
        &#125; else &#123;
            pre = top.`val`
        &#125;
        cur = top.right
    &#125;
    return true
&#125;
</code></pre>
<h4 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a>100. Same Tree</h4><p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
<pre><code class="kotlin">fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean &#123;
    if (p?.`val` != q?.`val`) &#123;
        return false
    &#125;
    if (p == null &amp;&amp; q == null) &#123;
        return true
    &#125;
    return isSameTree(p?.left, q?.left) &amp;&amp; isSameTree(p?.right, q?.right)
&#125;
</code></pre>
<h4 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h4><p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>
<pre><code class="kotlin">fun isSymmetric(root: TreeNode?): Boolean &#123;
    return isSymmetricRecur(root?.left, root?.right)
&#125;

fun isSymmetricRecur(L: TreeNode?, R: TreeNode?): Boolean &#123;
    if (L == null &amp;&amp; R == null) &#123;
        return true
    &#125; else if (L == null || R == null) &#123;
        return false
    &#125;
    if (L.`val` != R.`val`) &#123;
        return false
    &#125;
    if (!isSymmetricRecur(L.left, R.right)) &#123;
        return false
    &#125;

    if (!isSymmetricRecur(L.right, R.left)) &#123;
        return false
    &#125;
    return true
&#125;
</code></pre>
<h4 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h4><p>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>
<pre><code class="kotlin">fun levelOrder(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; &#123;
    val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()
    if (root == null) &#123;
        return ret
    &#125;
    val queue: Queue&lt;TreeNode&gt; = LinkedList()
    queue.offer(root)
    var curLevelCnt = 1
    var nextLevelCnt = 0
    var tmpList = mutableListOf&lt;Int&gt;()
    while (queue.isNotEmpty()) &#123;
        val node: TreeNode = queue.remove()
        tmpList.add(node.`val`)
        curLevelCnt--

        if (node.left != null) &#123;
            queue.offer(node.left)
            nextLevelCnt++
        &#125;

        if (node.right != null) &#123;
            queue.offer(node.right)
            nextLevelCnt++
        &#125;

        if (curLevelCnt == 0) &#123;
            ret.add(tmpList)
            tmpList = mutableListOf()
            curLevelCnt = nextLevelCnt
            nextLevelCnt = 0
        &#125;
    &#125;
    return ret
&#125;
</code></pre>
<h4 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h4><p>Given the root of a binary tree, return the zigzag level order traversal of its nodes’ values. (i.e., from left to right, then right to left for the next level and alternate between).</p>
<pre><code class="kotlin">    fun zigzagLevelOrder(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; &#123;
        val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()
        if (root == null) &#123;
            return ret
        &#125;
        val queue: Queue&lt;TreeNode&gt; = LinkedList()
        queue.offer(root)
        var curLevelCnt = 1
        var nextLevelCnt = 0
        var level = 0
        var tmpList = mutableListOf&lt;Int&gt;()
        while (queue.isNotEmpty()) &#123;
            val node: TreeNode = queue.remove()
            tmpList.add(node.`val`)
            curLevelCnt--

            if (node.left != null) &#123;
                queue.offer(node.left)
                nextLevelCnt++
            &#125;

            if (node.right != null) &#123;
                queue.offer(node.right)
                nextLevelCnt++
            &#125;

            if (curLevelCnt == 0) &#123;
                if (level % 2 == 1) &#123;
                    ret.add(tmpList.reversed())
                &#125; else &#123;
                    ret.add(tmpList)
                &#125;
                level++
                tmpList = mutableListOf()
                curLevelCnt = nextLevelCnt
                nextLevelCnt = 0
            &#125;
        &#125;
        return ret
    &#125;
</code></pre>
<h4 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h4><p>Given the root of a binary tree, return its maximum depth.</p>
<p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<pre><code class="kotlin">fun maxDepth(root: TreeNode?): Int &#123;
    return maxDepthRecur(root, 0)
&#125;

fun maxDepthRecur(root: TreeNode?, level: Int): Int &#123;
    if (root == null) &#123;
        return level
    &#125;
    return Math.max(maxDepthRecur(root.left, level + 1),
            maxDepthRecur(root.right, level + 1))
&#125;
</code></pre>
<h4 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h4><p>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p>
<pre><code class="kotlin">fun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? &#123;
    val inorderIndexMap = mutableMapOf&lt;Int, Int&gt;()
    for ((index, value) in inorder.withIndex()) &#123;
        inorderIndexMap[value] = index
    &#125;
    return buildTreeHelper(0, preorder.size - 1, 0, inorder.size - 1, preorder, inorderIndexMap)
&#125;

fun buildTreeHelper(pL: Int, pR: Int, iL: Int, iR: Int, preorder: IntArray, inorderIndexMap: Map&lt;Int, Int&gt;): TreeNode? &#123;
    if (pL &gt; pR || iL &gt; iR) &#123;
        return null
    &#125;
    val iIndex: Int? = inorderIndexMap.get(preorder[pL])
    val root = TreeNode(preorder[pL])
    iIndex!!
    root.left = buildTreeHelper(pL + 1, pL + iIndex - iL, iL, iIndex - 1, preorder, inorderIndexMap)
    root.right = buildTreeHelper(pR - (iR - iIndex) + 1, pR, iIndex + 1, iR, preorder, inorderIndexMap)
    return root
&#125;
</code></pre>
<p>Note: 利用中序遍历确定左右子树的范围</p>
<h4 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h4><p>Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.</p>
<pre><code class="kotlin">fun buildTree(inorder: IntArray, postorder: IntArray): TreeNode? &#123;
    val inorderMap = mutableMapOf&lt;Int, Int&gt;()
    for ((index, value) in inorder.withIndex()) &#123;
        inorderMap[value] = index
    &#125;
    return buildTreeHelper(0, postorder.size - 1, 0, inorder.size - 1, postorder, inorderMap)
&#125;

fun buildTreeHelper(pL: Int, pR: Int, iL: Int, iR: Int, postorder: IntArray, inorderMap: Map&lt;Int, Int&gt;): TreeNode? &#123;
    if (pL &gt; pR || iL &gt; iR) &#123;
        return null
    &#125;
    val root = TreeNode(postorder[pR])
    val index = inorderMap[root.`val`]
    index!!
    root.left = buildTreeHelper(pL, pL + (index - iL) - 1, iL, index - 1, postorder, inorderMap)
    root.right = buildTreeHelper(pL + (index - iL), pR - 1, index + 1, iR, postorder, inorderMap)
    return root
&#125;
</code></pre>
<h4 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107.Binary Tree Level Order Traversal II"></a>107.Binary Tree Level Order Traversal II</h4><p>Given the root of a binary tree, return the bottom-up level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root).</p>
<pre><code class="kotlin">fun levelOrderBottom(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; &#123;
  val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()
  if (root == null) &#123;
    return ret
  &#125;
  val queue = LinkedList&lt;TreeNode&gt;()
  queue.offer(root)
  var currentLevelCnt = 1
  var nextLevelCnt = 0
  var tmpList = mutableListOf&lt;Int&gt;()
  while (queue.isNotEmpty()) &#123;
    val node = queue.remove()
    tmpList.add(node.`val`)
    currentLevelCnt--
    if (node.left != null) &#123;
      queue.offer(node.left)
      nextLevelCnt++
    &#125;

    if (node.right != null) &#123;
      queue.offer(node.right)
      nextLevelCnt++
    &#125;

    if (currentLevelCnt == 0) &#123;
      currentLevelCnt = nextLevelCnt
      nextLevelCnt = 0
      ret.add(tmpList)
      tmpList = mutableListOf()
    &#125;

  &#125;
  ret.reverse()
  return ret
&#125;
</code></pre>
<h4 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. Convert Sorted Array to Binary Search Tree</h4><p>Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.</p>
<p>A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>
<pre><code class="kotlin">fun sortedArrayToBST(nums: IntArray): TreeNode? &#123;
    return sortedArrayToBSTHelper(nums, 0, nums.size - 1)
&#125;

fun sortedArrayToBSTHelper(nums: IntArray, start: Int, end: Int): TreeNode? &#123;
    if (start &gt; end) &#123;
        return null
    &#125;
    val mid = (start + end) / 2
    val root = TreeNode(nums[mid])
    root.left = sortedArrayToBSTHelper(nums, start, mid - 1)
    root.right = sortedArrayToBSTHelper(nums, mid + 1, end)
    return root
&#125;
</code></pre>
<h4 id="109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="109. Convert Sorted List to Binary Search Tree"></a>109. Convert Sorted List to Binary Search Tree</h4><p>Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<pre><code class="kotlin">fun sortedListToBST(head: ListNode?): TreeNode? &#123;
    val list = mutableListOf&lt;Int&gt;()
    var tmp = head
    while (tmp != null) &#123;
        list.add(tmp.`val`)
        tmp = tmp.next
    &#125;
    return sortedListToBSTHelper(list, 0, list.size - 1)
&#125;

fun sortedListToBSTHelper(list: List&lt;Int&gt;, start: Int, end: Int): TreeNode? &#123;
    if (start &gt; end) &#123;
        return null
    &#125;
    val mid = (start + end) / 2
    val root = TreeNode(list[mid])
    root.left = sortedListToBSTHelper(list, start, mid - 1)
    root.right = sortedListToBSTHelper(list, mid + 1, end)
    return root
&#125;
</code></pre>
<h4 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. Balanced Binary Tree</h4><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<ul>
<li>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</li>
</ul>
<pre><code class="kotlin">fun isBalanced(root: TreeNode?): Boolean &#123;
    return isBalancedHelper(root, 0) &gt;= 0
&#125;

fun isBalancedHelper(root: TreeNode?, level: Int): Int &#123;
    if (root == null) &#123;
        return level
    &#125;
    val leftLevel = isBalancedHelper(root.left, level + 1)
    val rightLevel = isBalancedHelper(root.right, level + 1)
    if (leftLevel == -1 || rightLevel == -1 || Math.abs(leftLevel - rightLevel) &gt; 1) &#123;
        return -1
    &#125; else &#123;
        return Math.max(leftLevel, rightLevel)
    &#125;
&#125;
</code></pre>
<h4 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h4><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<pre><code class="kotlin">fun minDepth(root: TreeNode?): Int &#123;
    if (root == null) &#123;
        return 0
    &#125;
    return minDepthHelper(root, 1)
&#125;

fun minDepthHelper(root: TreeNode?, level: Int): Int &#123;
    if (root?.left == null &amp;&amp; root?.right == null) &#123;
        return level
    &#125;
    if (root.left == null) &#123;
        return minDepthHelper(root.right, level + 1)
    &#125; else if (root.right == null)&#123;
        return minDepthHelper(root.left, level + 1)
    &#125; else  &#123;
        return Math.min(minDepthHelper(root.right, level + 1), minDepthHelper(root.left, level + 1))
    &#125;
&#125;
</code></pre>
<h4 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a>112. Path Sum</h4><p>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</p>
<p>A leaf is a node with no children.</p>
<pre><code class="kotlin">fun hasPathSum(root: TreeNode?, targetSum: Int): Boolean &#123;
    if (root == null) &#123;
        return false
    &#125;
    return hasPathSumHelper(root, root.`val`, targetSum)
&#125;

fun hasPathSumHelper(root: TreeNode, curSum: Int, targetSum: Int): Boolean &#123;
    if (root.left == null &amp;&amp; root.right == null) &#123;
        if (curSum == targetSum) &#123;
            return true
        &#125;
    &#125;
    var ret = false
    root.left?.also &#123;
        ret = ret or hasPathSumHelper(it, curSum + it.`val`, targetSum)
    &#125;

    root.right?.also &#123;
        ret = ret or hasPathSumHelper(it, curSum + it.`val`, targetSum)
    &#125;
    return ret
&#125;
</code></pre>
<h4 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a>113. Path Sum II</h4><p>Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path’s sum equals targetSum.</p>
<p>A leaf is a node with no children.</p>
<pre><code class="kotlin">fun pathSum(root: TreeNode?, targetSum: Int): List&lt;List&lt;Int&gt;&gt; &#123;
    val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()
    if (root == null) &#123;
        return ret
    &#125;
    val backtrace = mutableListOf&lt;Int&gt;()
    backtrace.add(root.`val`)
    pathSumHelper(root, targetSum, root.`val`, backtrace, ret)
    return ret
&#125;

fun pathSumHelper(root: TreeNode, targetSum: Int, curSum: Int,
                    backtrace: MutableList&lt;Int&gt;, ret: MutableList&lt;List&lt;Int&gt;&gt;) &#123;
    if (root.left == null &amp;&amp; root.right == null) &#123;
        if (targetSum == curSum) &#123;
            ret.add(backtrace.toList())
            return
        &#125;
    &#125;
    root.left?.also &#123;
        backtrace.add(it.`val`)
        pathSumHelper(it, targetSum, curSum + it.`val`, backtrace, ret)
        backtrace.removeAt(backtrace.lastIndex)
    &#125;

    root.right?.also &#123;
        backtrace.add(it.`val`)
        pathSumHelper(it, targetSum, curSum + it.`val`, backtrace, ret)
        backtrace.removeAt(backtrace.lastIndex)
    &#125;
&#125;
</code></pre>
<h4 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h4><p>Given the root of a binary tree, flatten the tree into a “linked list”:</p>
<ul>
<li><p>The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.</p>
</li>
<li><p>The “linked list” should be in the same order as a pre-order traversal of the binary tree.</p>
</li>
</ul>
<pre><code class="kotlin">fun flatten(root: TreeNode?): Unit &#123;
    flattenHelper(root)
&#125;

fun flattenHelper(root: TreeNode?): TreeNode? &#123;
    if (root == null) &#123;
        return null
    &#125;
    val R = root.right
    root.right = flattenHelper(root.left)
    root.left = null
    var tmp: TreeNode = root
    while (tmp.right != null) &#123;
        tmp = tmp.right!!
    &#125;
    tmp.right = flattenHelper(R)
    return root
&#125;
</code></pre>
<h4 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. Populating Next Right Pointers in Each Node</h4><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<p>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}</p>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Follow up:</p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
<pre><code class="kotlin">fun connect(root: Node?): Node? &#123;
    if (root == null) &#123;
        return null
    &#125;
    val queue = LinkedList&lt;Node&gt;()
    queue.offer(root)
    var curentLevelCnt = 1
    var nextLevelCnt = 0
    var lastNode: Node? = null
    while (queue.isNotEmpty()) &#123;
        val node = queue.remove()
        if (lastNode != null) &#123;
            lastNode.next = node
        &#125;
        lastNode = node
        curentLevelCnt--
        if (node.left != null) &#123;
            queue.offer(node.left)
            nextLevelCnt++
        &#125;

        if (node.right != null) &#123;
            queue.offer(node.right)
            nextLevelCnt++
        &#125;

        if (curentLevelCnt == 0) &#123;
            lastNode = null
            curentLevelCnt = nextLevelCnt
            nextLevelCnt = 0
        &#125;
    &#125;
    return root
&#125;
</code></pre>
<h4 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a>117. Populating Next Right Pointers in Each Node II</h4><p>Same as 116</p>
<h4 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a>118. Pascal’s Triangle</h4><p>Given an integer numRows, return the first numRows of Pascal’s triangle.</p>
<pre><code class="kotlin">fun generate(numRows: Int): List&lt;List&lt;Int&gt;&gt; &#123;
    val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()
    if (numRows == 0) &#123;
        return ret
    &#125;
    ret.add(listOf(1))
    if (numRows == 1) &#123;
        return ret
    &#125;
    ret.add(listOf(1,1))
    for (i in 2 .. numRows - 1) &#123;
        val tmp = mutableListOf&lt;Int&gt;()
        tmp.add(1)
        for (k in 1 .. i - 1) &#123;
            tmp.add(ret[i - 1][k - 1] + ret[i - 1][k])
        &#125;
        tmp.add(1)
        ret.add(tmp)
    &#125;
    return ret
&#125;
</code></pre>
<h4 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119. Pascal’s Triangle II"></a>119. Pascal’s Triangle II</h4><p>Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle.</p>
<pre><code class="kotlin">fun getRow(rowIndex: Int): List&lt;Int&gt; &#123;
    val dpArray = IntArray(rowIndex + 1)
    if (rowIndex &gt;= 0) &#123;
        dpArray[0] = 1
    &#125;

    if (rowIndex &gt;= 1) &#123;
        dpArray[0] = 1
        dpArray[1] = 1
    &#125;

    if (rowIndex &gt;= 2) &#123;
        for (i in 2 .. rowIndex) &#123;
            for (k in i - 1 downTo 1) &#123;
                dpArray[k] = dpArray[k] + dpArray[k - 1]
            &#125;
            dpArray[i] = 1
        &#125;
    &#125;

    return dpArray.toList()
&#125;
</code></pre>
<h4 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h4><p>Given a triangle array, return the minimum path sum from top to bottom.</p>
<p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.</p>
<pre><code class="kotlin">fun minimumTotal(triangle: List&lt;List&lt;Int&gt;&gt;): Int &#123;
    val dArray = IntArray(triangle[triangle.lastIndex].size)
    dArray[0] = triangle[0][0]

    for (i in 1 .. triangle.lastIndex) &#123;
        val rowArray = triangle[i]
        dArray[rowArray.lastIndex] = dArray[rowArray.lastIndex - 1] + rowArray[rowArray.lastIndex]
        for (k in rowArray.lastIndex - 1 downTo 1) &#123;
            dArray[k] = Math.min(rowArray[k] + dArray[k - 1], rowArray[k] + dArray[k])
        &#125;
        dArray[0] = dArray[0] + rowArray[0]
    &#125;

    var ret = Int.MAX_VALUE
    for (v in dArray) &#123;
        ret = Math.min(v, ret)
    &#125;
    return ret
&#125;
</code></pre>
<p>Note: Dynamic Programing</p>
<h4 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h4><p>You are given an array prices where prices[i] is the price of a given stock on the ith day.</p>
<p>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</p>
<p>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</p>
<pre><code class="kotlin">fun maxProfit(prices: IntArray): Int &#123;
    val dp = IntArray(prices.size)
    dp[0] = 0
    var minPrice = prices[0]
    for (i in 1 .. prices.lastIndex) &#123;
        if (prices[i] &lt; minPrice) &#123;
            minPrice = prices[i]
            dp[i] = dp[i - 1]
        &#125; else &#123;
            dp[i] = Math.max(dp[i - 1], prices[i] - minPrice)
        &#125;
    &#125;
    return dp[dp.lastIndex]
&#125;
</code></pre>
<p>Note: 动态规划方程: dp[i] = max(dp[i - 1], arr[i] - minPrice)</p>
<h4 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h4><p>[Greedy]</p>
<p>You are given an array prices where prices[i] is the price of a given stock on the ith day.</p>
<p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p>Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>
<pre><code class="kotlin">fun maxProfit(prices: IntArray): Int &#123;
    var ans = 0
    for (i in 1 .. prices.size - 1) &#123;
        ans += Math.max(0, prices[i] - prices[i - 1])
    &#125;
    return ans
&#125;
</code></pre>




</body>
</html>