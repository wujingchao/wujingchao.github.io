<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: References</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: References" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: References" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="index.xhtml#Top" rel="prev" title="Top" />
<link href="Exercises.xhtml#Exercises" rel="next" title="Exercises" />
<link href="5_002e5.xhtml#g_t5_002e5_002e7" rel="prev" title="5.5.7" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><span class="top jump" title="Jump to top"><a href="#pagetop" accesskey="t">⇡</a></span><a id="pagetop"></a><a id="References"></a>
<nav class="header">
<p>
Next: <a href="Exercises.xhtml#Exercises" accesskey="n" rel="next">Exercises</a>, Prev: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="p" rel="prev">5.5</a>, Up: <a href="index.xhtml#Top" accesskey="u" rel="prev">Top</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>]</p>
</nav>
<a id="References-1"></a>
<h2 class="unnumbered">References</h2>

<a id="Abelson-et-al_002e-1992"></a><p>Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister,
Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992.  The Supercomputer
Toolkit: A general framework for special-purpose computing.
<cite>International Journal of High-Speed Electronics</cite> 3(3): 337-361.
<a href="http://www.hpl.hp.com/techreports/94/HPL-94-30.html">–›</a>
</p>
<a id="Allen-1978"></a><p>Allen, John.  1978.  <cite>Anatomy of Lisp</cite>. New York: McGraw-Hill.
</p>
<a id="ANSI-1994"></a><p><abbr>ANSI</abbr> <abbr>X</abbr>3.226-1994. <cite>American National Standard for Information
Systems—Programming Language—Common Lisp</cite>.
</p>
<a id="Appel-1987"></a><p>Appel, Andrew W.  1987.  Garbage collection can be faster than stack
allocation.  <cite>Information Processing Letters</cite> 25(4): 275-279.
<a href="https://www.cs.princeton.edu/~appel/papers/45.ps">–›</a>
</p>
<a id="Backus-1978"></a><p>Backus, John.  1978.  Can programming be liberated from the von Neumann style?
<cite>Communications of the <abbr>ACM</abbr></cite> 21(8): 613-641.
<a href="http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf">–›</a>
</p>
<a id="Baker-_00281978_0029"></a><p>Baker, Henry G., Jr.  1978.  List processing in real time on a serial computer.
<cite>Communications of the <abbr>ACM</abbr></cite> 21(4): 280-293.
<a href="http://dspace.mit.edu/handle/1721.1/41976">–›</a>
</p>
<a id="Batali-et-al_002e-1982"></a><p>Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise.
1982.  The Scheme-81 architecture—System and chip.  In <cite>Proceedings of
the <abbr>MIT</abbr> Conference on Advanced Research in <abbr>VLSI</abbr></cite>, edited by
Paul Penfield, Jr. Dedham, <abbr>MA</abbr>: Artech House.
</p>
<a id="Borning-_00281977_0029"></a><p>Borning, Alan.  1977.  ThingLab—An object-oriented system for building
simulations using constraints. In <cite>Proceedings of the 5th International
Joint Conference on Artificial Intelligence</cite>.
<a href="http://ijcai.org/Past%20Proceedings/IJCAI-77-VOL1/PDF/085.pdf">–›</a>
</p>
<a id="Borodin-and-Munro-_00281975_0029"></a><p>Borodin, Alan, and Ian Munro.  1975.  <cite>The Computational Complexity of
Algebraic and Numeric Problems</cite>. New York: American Elsevier.
</p>
<a id="Chaitin-1975"></a><p>Chaitin, Gregory J.  1975.  Randomness and mathematical proof.
<cite>Scientific American</cite> 232(5): 47-52.
<a href="https://www.cs.auckland.ac.nz/~chaitin/sciamer.html">–›</a>
</p>
<a id="Church-_00281941_0029"></a><p>Church, Alonzo.  1941.  <cite>The Calculi of Lambda-Conversion</cite>.  Princeton,
N.J.: Princeton University Press.
</p>
<a id="Clark-_00281978_0029"></a><p>Clark, Keith L.  1978.  Negation as failure.  In <cite>Logic and Data Bases</cite>.
New York: Plenum Press, pp. 293-322.
<a href="http://www.doc.ic.ac.uk/~klc/neg.html">–›</a>
</p>
<a id="Clinger-_00281982_0029"></a><p>Clinger, William.  1982.  Nondeterministic call by need is neither lazy nor by
name. In <cite>Proceedings of the <abbr>ACM</abbr> Symposium on Lisp and
Functional Programming</cite>, pp. 226-234.
</p>
<a id="Clinger-and-Rees-1991"></a><p>Clinger, William, and Jonathan Rees.  1991.  Macros that work.  In
<cite>Proceedings of the 1991 <abbr>ACM</abbr> Conference on Principles of
Programming Languages</cite>, pp. 155-162.
<a href="http://mumble.net/~jar/pubs/macros_that_work.ps">–›</a>
</p>
<a id="Colmerauer-et-al_002e-1973"></a><p>Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel.  1973.  Un système de
communication homme-machine en français.  Technical report, Groupe
Intelligence Artificielle, Université d’Aix Marseille, Luminy.
<a href="http://alain.colmerauer.free.fr/alcol/ArchivesPublications/HommeMachineFr/HoMa.pdf">–›</a>
</p>
<a id="Cormen-et-al_002e-1990"></a><p>Cormen, Thomas, Charles Leiserson, and Ronald Rivest.  1990. <cite>Introduction
to Algorithms</cite>. Cambridge, <abbr>MA</abbr>: <abbr>MIT</abbr> Press.
</p>
<a id="Darlington-et-al_002e-1982"></a><p>Darlington, John, Peter Henderson, and David Turner.  1982.  <cite>Functional
Programming and Its Applications</cite>. New York: Cambridge University Press.
</p>
<a id="Dijkstra-1968a"></a><p>Dijkstra, Edsger W. 1968a.  The structure of the “<abbr>THE</abbr>”
multiprogramming system.  <cite>Communications of the <abbr>ACM</abbr></cite>
11(5): 341-346.
<a href="http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD196.PDF">–›</a>
</p>
<a id="g_t1968b"></a><p>Dijkstra, Edsger W. 1968b.  Cooperating sequential processes.  In
<cite>Programming Languages</cite>, edited by F. Genuys. New York: Academic Press,
pp.  43-112.
<a href="http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD123.PDF">–›</a>
</p>
<a id="Dinesman-1968"></a><p>Dinesman, Howard P.  1968.  <cite>Superior Mathematical Puzzles</cite>.  New York:
Simon and Schuster.
</p>
<a id="deKleer-et-al_002e-1977"></a><p>deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman.  1977.
<abbr>AMORD</abbr>: Explicit control of reasoning.  In <cite>Proceedings of the
<abbr>ACM</abbr> Symposium on Artificial Intelligence and Programming Languages</cite>,
pp.  116-125.
<a href="http://dspace.mit.edu/handle/1721.1/5750">–›</a>
</p>
<a id="Doyle-_00281979_0029"></a><p>Doyle, Jon. 1979. A truth maintenance system. <cite>Artificial Intelligence</cite>
12: 231-272.
<a href="http://dspace.mit.edu/handle/1721.1/5733">–›</a>
</p>
<a id="Feigenbaum-and-Shrobe-1993"></a><p>Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National Fifth
Generation Project: Introduction, survey, and evaluation.  In <cite>Future
Generation Computer Systems</cite>, vol. 9, pp. 105-117.
<a href="https://saltworks.stanford.edu/assets/kv359wz9060.pdf">–›</a>
</p>
<a id="Feeley-_00281986_0029"></a><p>Feeley, Marc.  1986.  Deux approches à l’implantation du language
Scheme.  Masters thesis, Université de Montréal.
<a href="http://www.iro.umontreal.ca/~feeley/papers/FeeleyMSc.pdf">–›</a>
</p>
<a id="Feeley-and-Lapalme-1987"></a><p>Feeley, Marc and Guy Lapalme.  1987.  Using closures for code generation.
<cite>Journal of Computer Languages</cite> 12(1): 47-66.
<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.6978">–›</a>
</p>
<p>Feller, William.  1957.  <cite>An Introduction to Probability Theory and Its
Applications</cite>, volume 1. New York: John Wiley &amp; Sons.
</p>
<a id="Fenichel-and-Yochelson-_00281969_0029"></a><p>Fenichel, R., and J. Yochelson.  1969.  A Lisp garbage collector for virtual
memory computer systems.  <cite>Communications of the <abbr>ACM</abbr></cite>
12(11): 611-612.
<a href="https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf">–›</a>
</p>
<a id="Floyd-_00281967_0029"></a><p>Floyd, Robert. 1967. Nondeterministic algorithms. <cite><abbr>JACM</abbr></cite>,
14(4): 636-644.
<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.332.36">–›</a>
</p>
<a id="Forbus-and-deKleer-1993"></a><p>Forbus, Kenneth D., and Johan deKleer.  1993. <cite>Building Problem
Solvers</cite>. Cambridge, <abbr>MA</abbr>: <abbr>MIT</abbr> Press.
</p>
<a id="Friedman-and-Wise-_00281976_0029"></a><p>Friedman, Daniel P., and David S. Wise.  1976.  <abbr>CONS</abbr> should not
evaluate its arguments. In <cite>Automata, Languages, and Programming: Third
International Colloquium</cite>, edited by S. Michaelson and R.  Milner, pp. 257-284.
<a href="https://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR44">–›</a>
</p>
<a id="Friedman-et-al_002e-1992"></a><p>Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.
<cite>Essentials of Programming Languages</cite>.  Cambridge, <abbr>MA</abbr>: <abbr>MIT</abbr>
Press/McGraw-Hill.
</p>
<a id="Gabriel-1988"></a><p>Gabriel, Richard P. 1988.  The Why of <em>Y</em>.  <cite>Lisp Pointers</cite>
2(2): 15-25.
<a href="http://www.dreamsongs.com/Files/WhyOfY.pdf">–›</a>
</p>
<p>Goldberg, Adele, and David Robson.  1983.  <cite>Smalltalk-80: The Language and
Its Implementation</cite>. Reading, <abbr>MA</abbr>: Addison-Wesley.
<a href="http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf">–›</a>
</p>
<a id="Gordon-et-al_002e-1979"></a><p>Gordon, Michael, Robin Milner, and Christopher Wadsworth.  1979.
<cite>Edinburgh <abbr>LCF</abbr></cite>. Lecture Notes in Computer Science, volume 78. New York:
Springer-Verlag.
</p>
<a id="Gray-and-Reuter-1993"></a><p>Gray, Jim, and Andreas Reuter. 1993. <cite>Transaction Processing: Concepts and
Models</cite>. San Mateo, <abbr>CA</abbr>: Morgan-Kaufman.
</p>
<a id="Green-1969"></a><p>Green, Cordell.  1969.  Application of theorem proving to problem solving.  In
<cite>Proceedings of the International Joint Conference on Artificial
Intelligence</cite>, pp. 219-240.
<a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.81.9820">–›</a>
</p>
<a id="Green-and-Raphael-_00281968_0029"></a><p>Green, Cordell, and Bertram Raphael.  1968.  The use of theorem-proving
techniques in question-answering systems.  In <cite>Proceedings of the
<abbr>ACM</abbr> National Conference</cite>, pp. 169-181.
<a href="http://www.kestrel.edu/home/people/green/publications/green-raphael.pdf">–›</a>
</p>
<a id="Griss-1981"></a><p>Griss, Martin L.  1981.  Portable Standard Lisp, a brief overview.  Utah
Symbolic Computation Group Operating Note 58, University of Utah.
</p>
<a id="Guttag-1977"></a><p>Guttag, John V.  1977.  Abstract data types and the development of data
structures.  <cite>Communications of the <abbr>ACM</abbr></cite> 20(6): 396-404.
<a href="http://www.unc.edu/~stotts/comp723/guttagADT77.pdf">–›</a>
</p>
<a id="Hamming-1980"></a><p>Hamming, Richard W.  1980.  <cite>Coding and Information Theory</cite>.  Englewood
Cliffs, N.J.: Prentice-Hall.
</p>
<a id="Hanson-1990"></a><p>Hanson, Christopher P.  1990.  Efficient stack allocation for tail-recursive
languages.  In <cite>Proceedings of <abbr>ACM</abbr> Conference on Lisp and
Functional Programming</cite>, pp. 106-118.
<a href="https://groups.csail.mit.edu/mac/ftpdir/users/cph/links.ps.gz">–›</a>
</p>
<a id="Hanson-1991"></a><p>Hanson, Christopher P.  1991.  A syntactic closures macro facility.  <cite>Lisp
Pointers</cite>, 4(3).
<a href="http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/synclo.ps">–›</a>
</p>
<a id="Hardy-1921"></a><p>Hardy, Godfrey H.  1921.  Srinivasa Ramanujan.  <cite>Proceedings of the London
Mathematical Society</cite> <abbr>XIX</abbr>(2).
</p>
<a id="Hardy-and-Wright-1960"></a><p>Hardy, Godfrey H., and E. M. Wright.  1960.  <cite>An Introduction to the
Theory of Numbers</cite>.  4th edition.  New York: Oxford University Press.
<a href="https://archive.org/details/AnIntroductionToTheTheoryOfNumbers-4thEd-G.h.HardyE.m.Wright">–›</a>
</p>
<a id="Havender-_00281968_0029"></a><p>Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. <cite>IBM
Systems Journal</cite> 7(2): 74-84.
</p>
<a id="Hearn-1969"></a><p>Hearn, Anthony C.  1969.  Standard Lisp.  Technical report <abbr>AIM</abbr>-90,
Artificial Intelligence Project, Stanford University.
<a href="http://www.softwarepreservation.org/projects/LISP/stanford/Hearn-StandardLisp-AIM-90.pdf">–›</a>
</p>
<a id="Henderson-1980"></a><p>Henderson, Peter. 1980.  <cite>Functional Programming: Application and
Implementation</cite>. Englewood Cliffs, N.J.: Prentice-Hall.
</p>
<a id="Henderson-1982"></a><p>Henderson. Peter. 1982. Functional Geometry. In <cite>Conference Record of the
1982 <abbr>ACM</abbr> Symposium on Lisp and Functional Programming</cite>, pp. 179-187.
<a href="http://pmh-systems.co.uk/phAcademic/papers/funcgeo.pdf">–›</a>,
<a href="http://eprints.soton.ac.uk/257577/1/funcgeo2.pdf">2002 version –›</a>
</p>
<a id="Hewitt-_00281969_0029"></a><p>Hewitt, Carl E.  1969.  <abbr>PLANNER</abbr>: A language for proving
theorems in robots.  In <cite>Proceedings of the International Joint
Conference on Artificial Intelligence</cite>, pp. 295-301.
<a href="http://dspace.mit.edu/handle/1721.1/6171">–›</a>
</p>
<a id="Hewitt-_00281977_0029"></a><p>Hewitt, Carl E.  1977.  Viewing control structures as patterns of passing
messages.  <cite>Journal of Artificial Intelligence</cite> 8(3): 323-364.
<a href="http://dspace.mit.edu/handle/1721.1/6272">–›</a>
</p>
<a id="Hoare-_00281972_0029"></a><p>Hoare, C. A. R. 1972.  Proof of correctness of data representations.
<cite>Acta Informatica</cite> 1(1).
</p>
<a id="Hodges-1983"></a><p>Hodges, Andrew. 1983.  <cite>Alan Turing: The Enigma</cite>. New York: Simon and
Schuster.
</p>
<a id="Hofstadter-1979"></a><p>Hofstadter, Douglas R.  1979.  <cite>Gödel, Escher, Bach: An Eternal Golden
Braid</cite>. New York: Basic Books.
</p>
<a id="Hughes-1990"></a><p>Hughes, R. J. M.  1990.  Why functional programming matters.  In <cite>Research
Topics in Functional Programming</cite>, edited by David Turner.  Reading, <abbr>MA</abbr>:
Addison-Wesley, pp. 17-42.
<a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf">–›</a>
</p>
<a id="IEEE-1990"></a><p><abbr>IEEE</abbr> Std 1178-1990.  1990.  <cite><abbr>IEEE</abbr> Standard for the
Scheme Programming Language</cite>.
</p>
<a id="Ingerman-et-al_002e-1960"></a><p>Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted by
M. Lind, Herbert Kanner, and Robert Floyd.  1960.  <abbr>THUNKS</abbr>: A way of
compiling procedure statements, with some comments on procedure declarations.
Unpublished manuscript.  (Also, private communication from Wallace Feurzeig.)
</p>
<a id="Kaldewaij-1990"></a><p>Kaldewaij, Anne. 1990.  <cite>Programming: The Derivation of Algorithms</cite>. New
York: Prentice-Hall.
</p>
<a id="Knuth-_00281973_0029"></a><p>Knuth, Donald E.  1973.  <cite>Fundamental Algorithms</cite>. Volume 1 of <cite>The
Art of Computer Programming</cite>.  2nd edition. Reading, <abbr>MA</abbr>: Addison-Wesley.
</p>
<a id="Knuth-1981"></a><p>Knuth, Donald E.  1981.  <cite>Seminumerical Algorithms</cite>. Volume 2 of <cite>The
Art of Computer Programming</cite>.  2nd edition. Reading, <abbr>MA</abbr>: Addison-Wesley.
</p>
<a id="Kohlbecker-1986"></a><p>Kohlbecker, Eugene Edmund, Jr. 1986.  Syntactic extensions in the programming
language Lisp.  Ph.D. thesis, Indiana University.
<a href="http://www.ccs.neu.edu/scheme/pubs/dissertation-kohlbecker.pdf">–›</a>
</p>
<a id="Konopasek-and-Jayaraman-1984"></a><p>Konopasek, Milos, and Sundaresan Jayaraman.  1984.  <cite>The TK!Solver Book: A
Guide to Problem-Solving in Science, Engineering, Business, and
Education</cite>. Berkeley, <abbr>CA</abbr>: Osborne/McGraw-Hill.
</p>
<a id="Kowalski-_00281973_003b-1979_0029"></a><p>Kowalski, Robert.  1973.  Predicate logic as a programming language.  Technical
report 70, Department of Computational Logic, School of Artificial
Intelligence, University of Edinburgh.
<a href="http://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf">–›</a>
</p>
<p>Kowalski, Robert.  1979.  <cite>Logic for Problem Solving</cite>. New York:
North-Holland.
<a href="http://www.doc.ic.ac.uk/%7Erak/papers/LogicForProblemSolving.pdf">–›</a>
</p>
<a id="Lamport-_00281978_0029"></a><p>Lamport, Leslie. 1978.  Time, clocks, and the ordering of events in a
distributed system.  <cite>Communications of the <abbr>ACM</abbr></cite> 21(7): 558-565.
<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf">–›</a>
</p>
<a id="Lampson-et-al_002e-1981"></a><p>Lampson, Butler, J. J. Horning, R.  London, J. G. Mitchell, and G. K.  Popek.
1981.  Report on the programming language Euclid.  Technical report, Computer
Systems Research Group, University of Toronto.
<a href="http://www.bitsavers.org/pdf/xerox/parc/techReports/CSL-81-12_Report_On_The_Programming_Language_Euclid.pdf">–›</a>
</p>
<a id="Landin-_00281965_0029"></a><p>Landin, Peter.  1965.  A correspondence between Algol 60 and Church’s lambda
notation: Part I.  <cite>Communications of the <abbr>ACM</abbr></cite> 8(2): 89-101.
</p>
<a id="Lieberman-and-Hewitt-1983"></a><p>Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage collector based
on the lifetimes of objects. <cite>Communications of the <abbr>ACM</abbr></cite>
26(6): 419-429.
<a href="http://dspace.mit.edu/handle/1721.1/6335">–›</a>
</p>
<a id="Liskov-and-Zilles-_00281975_0029"></a><p>Liskov, Barbara H., and Stephen N. Zilles.  1975.  Specification techniques for
data abstractions.  <cite><abbr>IEEE</abbr> Transactions on Software Engineering</cite>
1(1): 7-19.
<a href="http://csg.csail.mit.edu/CSGArchives/memos/Memo-117.pdf">–›</a>
</p>
<a id="McAllester-_00281978_003b-1980_0029"></a><p>McAllester, David Allen.  1978.  A three-valued truth-maintenance system.  Memo
473, <abbr>MIT</abbr> Artificial Intelligence Laboratory.
<a href="http://dspace.mit.edu/handle/1721.1/6296">–›</a>
</p>
<p>McAllester, David Allen.  1980.  An outlook on truth maintenance.  Memo 551,
<abbr>MIT</abbr> Artificial Intelligence Laboratory.
<a href="http://dspace.mit.edu/handle/1721.1/6327">–›</a>
</p>
<a id="McCarthy-1960"></a><p>McCarthy, John.  1960.  Recursive functions of symbolic expressions and their
computation by machine.  <cite>Communications of the <abbr>ACM</abbr></cite> 3(4): 184-195.
<a href="http://www-formal.stanford.edu/jmc/recursive.pdf">–›</a>
</p>
<a id="McCarthy-1963"></a><p>McCarthy, John.  1963.  A basis for a mathematical theory of computation.  In
<cite>Computer Programming and Formal Systems</cite>, edited by P. Braffort and
D. Hirschberg.  North-Holland.
<a href="http://www-formal.stanford.edu/jmc/basis.html">–›</a>
</p>
<a id="McCarthy-1978"></a><p>McCarthy, John.  1978.  The history of Lisp.  In <cite>Proceedings of the
<abbr>ACM</abbr> <abbr>SIGPLAN</abbr> Conference on the History of Programming
Languages</cite>.
<a href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html">–›</a>
</p>
<a id="McCarthy-et-al_002e-1965"></a><p>McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I.  Levin.
1965.  <cite>Lisp 1.5 Programmer’s Manual</cite>.  2nd edition.  Cambridge, <abbr>MA</abbr>:
<abbr>MIT</abbr> Press.
<a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf/view">–›</a>
</p>
<a id="McDermott-and-Sussman-_00281972_0029"></a><p>McDermott, Drew, and Gerald Jay Sussman.  1972. Conniver reference manual.
Memo 259, <abbr>MIT</abbr> Artificial Intelligence Laboratory.
<a href="http://dspace.mit.edu/handle/1721.1/6203">–›</a>
</p>
<a id="Miller-1976"></a><p>Miller, Gary L.  1976.  Riemann’s Hypothesis and tests for primality.
<cite>Journal of Computer and System Sciences</cite> 13(3): 300-317.
<a href="http://www.cs.cmu.edu/~glmiller/Publications/b2hd-Mi76.html">–›</a>
</p>
<a id="Miller-and-Rozas-1994"></a><p>Miller, James S., and Guillermo J. Rozas. 1994.  Garbage collection is fast,
but a stack is faster.  Memo 1462, <abbr>MIT</abbr> Artificial Intelligence
Laboratory.
<a href="http://dspace.mit.edu/handle/1721.1/6622">–›</a>
</p>
<a id="Moon-1978"></a><p>Moon, David.  1978.  MacLisp reference manual, Version 0.  Technical report,
<abbr>MIT</abbr> Laboratory for Computer Science.
<a href="http://www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf/view">–›</a>
</p>
<a id="Moon-and-Weinreb-1981"></a><p>Moon, David, and Daniel Weinreb.  1981.  Lisp machine manual.  Technical
report, <abbr>MIT</abbr> Artificial Intelligence Laboratory.
<a href="http://www.unlambda.com/lmman/index.html">–›</a>
</p>
<a id="Morris-et-al_002e-1980"></a><p>Morris, J. H., Eric Schmidt, and Philip Wadler.  1980.  Experience with an
applicative string processing language.  In <cite>Proceedings of the 7th Annual
<abbr>ACM</abbr> <abbr>SIGACT</abbr>/<abbr>SIGPLAN</abbr> Symposium on the Principles of
Programming Languages</cite>.
</p>
<a id="Phillips-1934"></a><p>Phillips, Hubert.  1934. <cite>The Sphinx Problem Book</cite>.  London: Faber and
Faber.
</p>
<a id="Pitman-1983"></a><p>Pitman, Kent. 1983. The revised MacLisp Manual (Saturday evening edition).
Technical report 295, <abbr>MIT</abbr> Laboratory for Computer Science.
<a href="http://maclisp.info/pitmanual">–›</a>
</p>
<a id="Rabin-1980"></a><p>Rabin, Michael O. 1980. Probabilistic algorithm for testing primality.
<cite>Journal of Number Theory</cite> 12: 128-138.
</p>
<a id="Raymond-1993"></a><p>Raymond, Eric.  1993. <cite>The New Hacker’s Dictionary</cite>. 2nd edition.
Cambridge, <abbr>MA</abbr>: <abbr>MIT</abbr> Press.
<a href="http://www.catb.org/jargon/">–›</a>
</p>
<p>Raynal, Michel. 1986. <cite>Algorithms for Mutual Exclusion</cite>.  Cambridge, <abbr>MA</abbr>:
<abbr>MIT</abbr> Press.
</p>
<a id="Rees-and-Adams-1982"></a><p>Rees, Jonathan A., and Norman I. Adams IV. 1982.  T: A dialect of Lisp or,
lambda: The ultimate software tool.  In <cite>Conference Record of the 1982
<abbr>ACM</abbr> Symposium on Lisp and Functional Programming</cite>, pp.  114-122.
<a href="http://people.csail.mit.edu/riastradh/t/adams82t.pdf">–›</a>
</p>
<p>Rees, Jonathan, and William Clinger (eds). 1991.  The revised⁴ report on the
algorithmic language Scheme.  <cite>Lisp Pointers</cite>, 4(3).
<a href="http://people.csail.mit.edu/jaffer/r4rs.pdf">–›</a>
</p>
<a id="Rivest-et-al_002e-_00281977_0029"></a><p>Rivest, Ronald, Adi Shamir, and Leonard Adleman.  1977.  A method for obtaining
digital signatures and public-key cryptosystems. Technical memo <abbr>LCS</abbr>/<abbr>TM82</abbr>,
<abbr>MIT</abbr> Laboratory for Computer Science.
<a href="http://people.csail.mit.edu/rivest/Rsapaper.pdf">–›</a>
</p>
<a id="Robinson-1965"></a><p>Robinson, J. A. 1965.  A machine-oriented logic based on the resolution
principle.  <cite>Journal of the <abbr>ACM</abbr></cite> 12(1): 23.
</p>
<a id="Robinson-1983"></a><p>Robinson, J. A. 1983.  Logic programming—Past, present, and future.
<cite>New Generation Computing</cite> 1: 107-124.
</p>
<a id="Spafford-1989"></a><p>Spafford, Eugene H.  1989.  The Internet Worm: Crisis and aftermath.
<cite>Communications of the <abbr>ACM</abbr></cite> 32(6): 678-688.
<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8503&amp;rep=rep1&amp;type=pdf">–›</a>
</p>
<a id="Steele-1977"></a><p>Steele, Guy Lewis, Jr.  1977.  Debunking the “expensive procedure call” myth.
In <cite>Proceedings of the National Conference of the <abbr>ACM</abbr></cite>,
pp. 153-62.
<a href="http://dspace.mit.edu/handle/1721.1/5753">–›</a>
</p>
<a id="Steele-1982"></a><p>Steele, Guy Lewis, Jr.  1982.  An overview of Common Lisp.  In
<cite>Proceedings of the <abbr>ACM</abbr> Symposium on Lisp and Functional
Programming</cite>, pp. 98-107.
</p>
<a id="Steele-1990"></a><p>Steele, Guy Lewis, Jr.  1990.  <cite>Common Lisp: The Language</cite>. 2nd edition.
Digital Press.
<a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html">–›</a>
</p>
<a id="Steele-and-Sussman-1975"></a><p>Steele, Guy Lewis, Jr., and Gerald Jay Sussman.  1975.  Scheme: An interpreter
for the extended lambda calculus.  Memo 349, <abbr>MIT</abbr> Artificial
Intelligence Laboratory.
<a href="http://dspace.mit.edu/handle/1721.1/5794">–›</a>
</p>
<a id="Steele-et-al_002e-1983"></a><p>Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R.  Crispin,
Richard M. Stallman, and Geoffrey S. Goodfellow.  1983.  <cite>The Hacker’s
Dictionary</cite>. New York: Harper &amp; Row.
<a href="http://www.dourish.com/goodies/jargon.html">–›</a>
</p>
<a id="Stoy-1977"></a><p>Stoy, Joseph E.  1977.  <cite>Denotational Semantics</cite>. Cambridge, <abbr>MA</abbr>:
<abbr>MIT</abbr> Press.
</p>
<a id="Sussman-and-Stallman-1975"></a><p>Sussman, Gerald Jay, and Richard M. Stallman.  1975.  Heuristic techniques in
computer-aided circuit analysis.  <cite><abbr>IEEE</abbr> Transactions on Circuits
and Systems</cite> <abbr>CAS</abbr>-22(11): 857-865.
<a href="http://dspace.mit.edu/handle/1721.1/5803">–›</a>
</p>
<a id="Sussman-and-Steele-1980"></a><p>Sussman, Gerald Jay, and Guy Lewis Steele Jr.  1980.  Constraints—A language
for expressing almost-hierachical descriptions.  <cite>AI Journal</cite> 14: 1-39.
<a href="http://dspace.mit.edu/handle/1721.1/6312">–›</a>
</p>
<a id="Sussman-and-Wisdom-1992"></a><p>Sussman, Gerald Jay, and Jack Wisdom.  1992. Chaotic evolution of the solar
system.  <cite>Science</cite> 257: 256-262.
<a href="http://groups.csail.mit.edu/mac/users/wisdom/ss-chaos.pdf">–›</a>
</p>
<a id="Sussman-et-al_002e-_00281971_0029"></a><p>Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak.  1971.  Microplanner
reference manual.  Memo 203<abbr>A</abbr>, <abbr>MIT</abbr> Artificial Intelligence Laboratory.
<a href="http://dspace.mit.edu/handle/1721.1/6184">–›</a>
</p>
<a id="Sutherland-_00281963_0029"></a><p>Sutherland, Ivan E.  1963.  <abbr>SKETCHPAD</abbr>: A man-machine graphical
communication system.  Technical report 296, <abbr>MIT</abbr> Lincoln Laboratory.
<a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-574.pdf">–›</a>
</p>
<a id="Teitelman-1974"></a><p>Teitelman, Warren.  1974.  Interlisp reference manual.  Technical report, Xerox
Palo Alto Research Center.
<a href="http://www.softwarepreservation.org/projects/LISP/interlisp/Interlisp-Oct_1974.pdf/view">–›</a>
</p>
<a id="Thatcher-et-al_002e-1978"></a><p>Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978.  Data type
specification: Parameterization and the power of specification techniques. In
<cite>Conference Record of the Tenth Annual <abbr>ACM</abbr> Symposium on Theory
of Computing</cite>, pp. 119-132.
</p>
<a id="Turner-1981"></a><p>Turner, David.  1981.  The future of applicative languages.  In
<cite>Proceedings of the 3rd European Conference on Informatics</cite>, Lecture Notes
in Computer Science, volume 123. New York: Springer-Verlag, pp.  334-348.
</p>
<a id="Wand-1980"></a><p>Wand, Mitchell.  1980.  Continuation-based program transformation strategies.
<cite>Journal of the <abbr>ACM</abbr></cite> 27(1): 164-180.
<a href="http://www.diku.dk/OLD/undervisning/2005e/224/papers/Wand80.pdf">–›</a>
</p>
<a id="Waters-_00281979_0029"></a><p>Waters, Richard C.  1979.  A method for analyzing loop programs.
<cite><abbr>IEEE</abbr> Transactions on Software Engineering</cite> 5(3): 237-247.
</p>
<p>Winograd, Terry.  1971.  Procedures as a representation for data in a computer
program for understanding natural language.  Technical report <abbr>AI TR</abbr>-17,
<abbr>MIT</abbr> Artificial Intelligence Laboratory.
<a href="http://dspace.mit.edu/handle/1721.1/7095">–›</a>
</p>
<a id="Winston-1992"></a><p>Winston, Patrick. 1992. <cite>Artificial Intelligence</cite>.  3rd edition.  Reading,
<abbr>MA</abbr>: Addison-Wesley.
</p>
<a id="Zabih-et-al_002e-1987"></a><p>Zabih, Ramin, David McAllester, and David Chapman.  1987.  Non-deterministic
Lisp with dependency-directed backtracking.  <cite><abbr>AAAI</abbr>-87</cite>,
pp. 59-64.
<a href="http://www.aaai.org/Papers/AAAI/1987/AAAI87-011.pdf">–›</a>
</p>
<a id="Zippel-_00281979_0029"></a><p>Zippel, Richard.  1979.  Probabilistic algorithms for sparse polynomials.
Ph.D. dissertation, Department of Electrical Engineering and Computer Science,
<abbr>MIT</abbr>.
</p>
<a id="Zippel-1993"></a><p>Zippel, Richard.  1993.  <cite>Effective Polynomial Computation</cite>.  Boston, <abbr>MA</abbr>:
Kluwer Academic Publishers.
</p>
<nav class="header">
<p>
Next: <a href="Exercises.xhtml#Exercises" accesskey="n" rel="next">Exercises</a>, Prev: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="p" rel="prev">5.5</a>, Up: <a href="index.xhtml#Top" accesskey="u" rel="prev">Top</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>]</p>
</nav>


</section><span class="bottom jump" title="Jump to bottom"><a href="#pagebottom" accesskey="b">⇣</a></span><a id="pagebottom"></a>
</body>
</html>
