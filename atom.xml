<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lost &amp; Found</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wujingchao.github.io/"/>
  <updated>2024-12-07T09:26:30.811Z</updated>
  <id>http://wujingchao.github.io/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Modified UTF-8</title>
    <link href="http://wujingchao.github.io/2021/04/04/modified-utf8/"/>
    <id>http://wujingchao.github.io/2021/04/04/modified-utf8/</id>
    <published>2021-04-03T16:00:00.000Z</published>
    <updated>2024-12-07T09:26:30.811Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-Modified-UTF-8"><a href="#Java-Modified-UTF-8" class="headerlink" title="Java Modified UTF-8"></a>Java Modified UTF-8</h3><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode，官方中文名称为统一码，是计算机科学领域字符集的业界标准。它整理、编码了世界上大部分的文字系统，使得电脑可以用更为简单的方式来呈现和处理文字。 </p><p>简单来说就是某一个文字或者符号，对应(映射)着一个整数值，范围为0x0000 ~ 0x1FFFF</p><p>Unicode划分将字符集划分为17组，其中第一组为基本字符集（也叫基本多文种平面Basic Multilingual Plane）范围为0x0000 ~ 0xFFFF，包含了大部分国家常用的字符串和符号，其中0xD800 ~ 0xDFFF不映射字符，所以基本平面能够表示的字符个数为 (65536 - 2048)</p><p>其余的字符集为增补字符集（也叫多文种补充平面Supplementary Multilingual Plane），范围为0x10000 ~ 0x1FFFFF</p><p>所以Unicode的字符集个数为 2^17 - 2048 = 1112064</p><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>UTF-16是对Unicode的字符集的编码，Java的Char类型占用两个字节，用的就是UTF-16进行编码。对于基本字符集使用一个char就能够表示，比如：</p><p>‘A’ 对于的二进制为： 0x00 0x41</p><p>对于增补字符集，一个char表示不了，需要用两个char，但是对于每一个char的解析，我们需要知道它是落在了基本字符集里还是增补字符集里面，所以就需要一个类似转义的操作，由于基本字符集里的0xD800 ~ 0xDFFF是不映射字符的，可以用来转义。计算过程如下：</p><p>扩展平面减去基本平面数量  0x10000 ~ 0x10FFFF - 0x10000 = 0x00000 ~ 0xFFFFF, 共20位，分别对前10位和后10位进行编码.</p><p>0xD800 + 前10位   前两个字节，又叫高代理对(High Surrogate), 范围为0xD800 ~ 0xD8FF（0xD800 + 0x3FF）</p><p>0xDC00 + 后10位   后两个子集，又叫低代理对(Low Surrogate)，范围为0xDC00 ~ 0xDFFF（0xDC00 + 0x3FF）</p><p>例如’𠎠’字符，对应的Unicode码为 0x203A0，为增补字符集里面的字符，所以需要使用代理对进行编码：</p><p>首先减去基本字符集的范围：<br>    0x203A0 - 0x10000 = 0x103A0， 对应的二进制位0001 0000 0011 1010 0000</p><p>对前十位进行编码：<br>    0xD800 +  0100 0000 = 0xD800 + 0x40 = 0xD840</p><p>对后十位进行编码<br>    0xDC00 +  11 1010 0000 = 0xDC00 + 0x3A0 = 0xDFA0</p><p>所以编码后两个字符内容为：\uD840\uDFA0</p><h4 id="Regular-UTF-8"><a href="#Regular-UTF-8" class="headerlink" title="Regular UTF-8"></a>Regular UTF-8</h4><p>UTF-8 同样是对Unicode字符集的编码，不过他使用变长的规则进行编码，对于大部分基本字符集里面的汉字字符，需要3个字节进行编码，但是对于英文字符ASCII，只需要一个字节。</p><p>编码规则如下：</p><p>对于与范围为0x00 ~ 0x7F的Uicode码: 0XXXXXXX</p><p>对于超过0x7F的字符，使用变长的规则,低位均为10开头，从第二位位后面到0之间1的个数就是后面字节的个数</p><p>0x7F  ~ 0x7FF     110XXXXX 10XXXXXX</p><p>0x800 ~ 0xFFFF    1110XXXX 10XXXXXX 10XXXXXX</p><p>0x10000 ~ 0x10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</p><p>例如字符’A’ 对于的编码为 0x41</p><p>字符’𠎠’对于的编码：</p><p>0x203A0落在区间0x10000 ~ 0x10FFFF，对于的二进制为0010 0000 0011 1010 0000,将位填入上面的占位符(X)得到：</p><p>1111 0000 1010 0000 1000 1110 1010 0000 即 0xF0 0xA0 0x8E 0xA0</p><h4 id="Modified-UTF-8"><a href="#Modified-UTF-8" class="headerlink" title="Modified UTF-8"></a>Modified UTF-8</h4><p>Modified UTF-8对UTF-8做了一些修改，起源于Java，java.io.DataInput里有对其描述(<a href="https://developer.android.com/reference/java/io/DataInput),区别主要有：">https://developer.android.com/reference/java/io/DataInput),区别主要有：</a></p><ul><li><p>对0号Unicode的处理，0号字符又叫null character，在C语言里面用于结束字符串标识，正常的UTF-8只需要一个字节表示，而Modified UTF-8需要用两个字节对\u0000进行编码，对应的二进制位11000000 10000000，即0xC080，所以Modified UTF-8里不会出现单个字节的null character，所以可以使用null character作为字符串的结尾，这对于C标准库里面的很多函数很有用。另外Java里面的字符串并没有结束符，需要能够正常的处理u/0000的字符</p></li><li><p>只使用1，2，3字节的格式，即 0XXXXXXX |  110XXXXX 10XXXXXX | 1110XXXX 10XXXXXX 10XXXXXX</p></li><li><p>只使用1，2，3字节格式来编码，那么对于增补字符集，分别对UTF-16的高代理对于低代理对进行UTF-8编码，就可以得到6字节长度。（区别于标准UTF8，直接使用Unicode码进行）</p></li></ul><p>继续使用增补字符集的字符’𠎠’示例：</p><p>从上面可以知道UTF-16的高代理对于低代理对字节为： \uD840 \uDFA0</p><p>分别对0xD840与0xDFA0进行UTF-8编码</p><p>0xD840 对于二进制 1101 1000 0100 0000</p><p>0xDFA0 对于二进制 1101 1111 1010 0000</p><p>对高代理对进行编码 得到 11101101  10100001 10000000 即 0xED 0xA1 0x80</p><p>对低代理对进行编码得到  11101101  10111110 10100000 即 0xED 0xBE 0xA0</p><p>所以最终得到的编码内容为 0xED 0xA1 0xBD 0xED 0xB8 0x88</p><p>Modified UTF-8主要用在了两个地方：</p><ul><li><p>class文件的Utf8常量项字符格式，这样当虚拟机解析字面量不用对增补字符集做另外的代理对转换处理</p></li><li><p>另一个地方就是JNI的GetStringChars函数</p></li></ul><pre><code>GetStringUTFCharsconst char * GetStringUTFChars(JNIEnv *env, jstring string,jboolean *isCopy);Returns a pointer to an array of bytes representing the string in modified UTF-8 encoding</code></pre><p>但是对于增补字符集，在Android R上测试了这个函数，’𠎠’字符得到的是用Unicode进行UTF8编码的，并不是使用代理对处理的Modified UTF-8：</p><p>11100000 10100000 10001110 10100000 即 0xF0 0xA0 0x8E 0xA0</p><p>查了下，很早的版本就有人反馈这个现象 <a href="https://github.com/android/ndk/issues/283">https://github.com/android/ndk/issues/283</a></p><p>但是文档或者实现都没有改，所以涉及到JNI使用UTF-8处理增补字符集的时候，需要留意下有没有问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java-Modified-UTF-8&quot;&gt;&lt;a href=&quot;#Java-Modified-UTF-8&quot; class=&quot;headerlink&quot; title=&quot;Java Modified UTF-8&quot;&gt;&lt;/a&gt;Java Modified UTF-8&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Leetcode Kotlin 解题记录</title>
    <link href="http://wujingchao.github.io/2021/02/26/leetcode/"/>
    <id>http://wujingchao.github.io/2021/02/26/leetcode/</id>
    <published>2021-02-25T16:00:00.000Z</published>
    <updated>2024-12-07T09:26:15.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Leetcode-Kotlin-解题记录"><a href="#Leetcode-Kotlin-解题记录" class="headerlink" title="Leetcode Kotlin 解题记录"></a>Leetcode Kotlin 解题记录</h3><h5 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.Two Sum"></a>1.Two Sum</h5><p>[HashTable | Array ]</p><p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p><p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><pre><code class="kotlin">fun twoSum(nums: IntArray, target: Int): IntArray &#123;    val map = mutableMapOf&lt;Int, Int&gt;()    for ((index, i) in nums.withIndex()) &#123;        val complement = target - i        if (map[complement] != null) &#123;            return intArrayOf(index, map[complement]!!)        &#125;        map[i] = index    &#125;    return intArrayOf()&#125;</code></pre><p>NOTE：反向思维，通过和来找另一个加数 ，为了不用遍历且更快地找到，将元素的值和位置保存在map里面，空间换时间</p><h5 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h5><p><u>[Linked List | Math]</u></p><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><pre><code class="kotlin">fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? &#123;    val head = ListNode()    var headCur = head    var l1Cur = l1    var l2Cur = l2    while (true) &#123;        if (l1Cur != null) &#123;            headCur.`val` += l1Cur.`val`            l1Cur = l1Cur.next        &#125;        if (l2Cur != null) &#123;            headCur.`val` += l2Cur.`val`            l2Cur = l2Cur.next        &#125;        if (headCur.`val` &gt; 9) &#123;            headCur.`val` %= 10            headCur.next = ListNode(1)        &#125;        if (l1Cur == null &amp;&amp; l2Cur == null) &#123;            break        &#125;        if (headCur.next == null) &#123;            headCur.next = ListNode()        &#125;        headCur = headCur.next!!    &#125;    return head&#125;</code></pre><p>NOTE:  同时遍历两个列表，注意进位操作</p><h5 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h5><p>[Hash Table | Two Pointers | String | Sliding Window]</p><p>Given a string s, find the length of the longest substring without repeating characters.</p><pre><code class="kotlin">fun lengthOfLongestSubstring(s: String): Int &#123;    var result = 0    val cPosition = mutableMapOf&lt;Char, Int&gt;()    var i = 0    var j = 0    while (j &lt; s.length) &#123;        val pos = cPosition[s[j]]        if (pos != null &amp;&amp; pos &gt;= i) &#123;            i++        &#125; else &#123;            result = Math.max(result, j - i + 1)            cPosition[s[j]] = j            j++        &#125;    &#125;    return result&#125;</code></pre><p>NOTE: 双指针，一个不断往前移动，判断是否有重复的字符，用Hash Table加速查询，不满足条件移动后面指针</p><h5 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h5><p>[Array | Binary Search | Divide Conquuer ]</p><p>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.</p><p>Follow up: The overall run time complexity should be O(log (m+n)).</p><pre><code class="kotlin">fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double &#123;    val totalLen = nums1.size + nums2.size    val center:Int    val even = totalLen % 2 == 0    if (even) &#123;        center = (totalLen + 1) / 2    &#125; else &#123;        center = totalLen / 2    &#125;    var index1 = 0    var index2 = 0    var result = 0.0    var last = 0    for (i in 0 .. (totalLen - 1)) &#123;        var cur = 0        if (index1 &lt; nums1.size &amp;&amp; index2 &lt; nums2.size) &#123;            if (nums1[index1] &lt; nums2[index2]) &#123;                cur = nums1[index1]                index1++            &#125; else&#123;                cur = nums2[index2]                index2++            &#125;        &#125; else if (index1 &lt; nums1.size) &#123;            cur = nums1[index1]            index1++        &#125; else if (index2 &lt; nums2.size)&#123;            cur = nums2[index2]            index2++        &#125;        if (i == center) &#123;            if (even) &#123;                result = (last + cur) / 2.0            &#125; else &#123;                result = cur.toDouble()            &#125;            break        &#125;        last = cur;    &#125;    return result&#125;</code></pre><p>NOTE:  归并排序的方式对两个数组进行遍历，记录上一个值与当前值，到达中间的位置直接求出结果</p><h4 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h4><p>[String | Dynamic Programing ]</p><p>Given a string s, return the longest palindromic substring in s.</p><pre><code class="kotlin">fun longestPalindrome(s: String): String &#123;    if (s.length &lt; 2) &#123;        return s    &#125;    var max = 1    var start = 0;    val dp = Array(s.length) &#123; BooleanArray(s.length) &#125;    for (j in 1 until s.length) &#123;        for (i in 0 until j) &#123;            if (s[i] == s[j]) &#123;                dp[i][j] = j - i + 1 &lt;= 3 ||  dp[i + 1][j - 1]            &#125; else &#123;                dp[i][j] = false            &#125;            if (dp[i][j] &amp;&amp; j - i + 1 &gt; max) &#123;                max = j - i + 1                start = i            &#125;        &#125;    &#125;    return s.substring(start, start + max)&#125;</code></pre><p>NOTE: 从前往后遍历，用dp[][]记录计算过的回文串区间，避免重复计算</p><h4 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a>6. ZigZag Conversion</h4><p>[String]</p><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><p>P   A   H   N<br>A P L S I I G<br>Y   I   R</p><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><pre><code class="kotlin">fun convert(s: String, numRows: Int): String &#123;    if (numRows == 1) return s    val sbuilderArr = Array(numRows) &#123; StringBuilder() &#125;    var switchIndex = 0    var verticalIndex = 0    s.forEachIndexed &#123; index, c -&gt;                      if (switchIndex != 0) &#123;                          sbuilderArr[switchIndex--].append(c)                      &#125; else &#123;                          sbuilderArr[verticalIndex++].append(c)                          if (verticalIndex == numRows) &#123;                              switchIndex = numRows - 2                              verticalIndex = 0                          &#125;                      &#125;                     &#125;    val result = StringBuilder()    sbuilderArr.forEach &#123;        result.append(it)    &#125;    return result.toString()&#125;</code></pre><p>NOTE: 每一行用一个StringBuilder保存，然后顺序遍历，根据行数切换保存的位置，然后合并结果</p><h4 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h4><p>[Math]</p><p>Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.</p><p>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</p><pre><code class="kotlin">fun reverse(x: Int): Int &#123;    var ret = 0    var y = x    var pop = 0    while (y != 0) &#123;        pop = y % 10        if (ret &gt; 0 &amp;&amp; Integer.MAX_VALUE - ret * 10 &lt; pop) &#123;            return 0        &#125; else if (ret &lt; 0 &amp;&amp; (Integer.MIN_VALUE - ret * 10) &gt; pop ) &#123;            return 0        &#125;        ret = ret * 10 + pop        y /= 10    &#125;    return ret&#125;</code></pre><p>NOTE:  求余数得到各位，除以10消除个位，计算前先判断是否溢出，溢出的判断方法为先列不等式，然后变换不等式消除不等式计算两端移除的可能</p><h4 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h4><p>[Math | String]</p><p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++’s <code>atoi</code> function).</p><p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p><ol><li>Read in and ignore any leading whitespace.</li><li>Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final  result is negative or positive respectively. Assume the result is  positive if neither is present.</li><li>Read in next the characters until the next non-digit charcter or  the end of the input is reached. The rest of the string is ignored.</li><li>Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</li><li>If the integer is out of the 32-bit signed integer range <code>[-2^31, 2^31 - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-231</code> should be clamped to <code>-231</code>, and integers greater than <code>2^31 - 1</code> should be clamped to <code>2^31 - 1</code>.</li><li>Return the integer as the final result.</li></ol><pre><code class="kotlin">fun myAtoi(s: String): Int &#123;    var ret = 0    var neg = false    var invalid = false    for (c in s) &#123;        if (c == &#39;-&#39; || c == &#39;+&#39;) &#123;            if (invalid) &#123;                break            &#125;            if (c == &#39;-&#39;) &#123;                neg = true            &#125; else if (c == &#39;+&#39;) &#123;                neg = false            &#125;            invalid = true        &#125; else if ((c == &#39; &#39;)) &#123;            if (invalid) &#123;                break            &#125;            continue        &#125; else if (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &#123;            break        &#125; else &#123;            val bit = c.toInt() - &#39;0&#39;.toInt()            if (!neg &amp;&amp; ret &gt; (Integer.MAX_VALUE - bit) / 10) &#123;                ret = Integer.MAX_VALUE                break            &#125; else if (neg &amp;&amp; -ret &lt; (Integer.MIN_VALUE + bit) / 10) &#123;                ret = Integer.MIN_VALUE                break            &#125;            ret = ret * 10 + bit            invalid = true        &#125;    &#125;    return if (neg) -ret else ret&#125;</code></pre><p>NOTE: 用 invalid来判断是否还可以出入其他的字符，当开始输入数字或者已经输入符号就再能在输入其他符号</p><h4 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h4><p>An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.</p><p>[Math]</p><pre><code class="kotlin">fun isPalindrome(x: Int): Boolean &#123;    if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;        return false    &#125;    var x = x    var ret = 0    while (x &gt; ret) &#123;        val pop = x % 10        ret = ret * 10 + pop        x /= 10    &#125;    return x == ret || x == ret / 10&#125;</code></pre><p>NOTE: 隐含条件  : 计算反转数字的时候只用计算一半即可</p><h4 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h4><p>[String]</p><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’ where: </p><ul><li>‘.’ Matches any single character.​​​​</li><li>‘*’ Matches zero or more of the preceding element.</li></ul><p>The matching should cover the entire input string (not partial).</p><pre><code class="kotlin">fun isMatch(s: String, p: String): Boolean &#123;  if (p.isEmpty()) &#123;    return s.isEmpty()  &#125;  val firstCharMatch = s.isNotEmpty() &amp;&amp; (s[0] == p[0] || p[0] == &#39;.&#39;)  val firstStarMatch = p.length &gt; 1 &amp;&amp; p[1] == &#39;*&#39;  if (firstCharMatch &amp;&amp; firstStarMatch) &#123;    return isMatch(s.substring(1), p) || isMatch(s, p.substring(2))  &#125; else if (firstStarMatch) &#123;    return isMatch(s, p.substring(2))  &#125; else if (firstCharMatch) &#123;    return isMatch(s.substring(1), p.substring(1))  &#125;else &#123;    return false  &#125;&#125;//DP:fun isMatch(s: String, p: String): Boolean &#123;  val pLen = p.length  val sLen = s.length  val dp = Array(pLen + 1)&#123;BooleanArray(sLen + 1)&#125;  dp[0][0] = true  for (i in 1 .. pLen - 1 step 2) &#123;    if (p[i] == &#39;*&#39;) &#123;      dp[i][0] = true      dp[i + 1][0] = true    &#125; else &#123;      break    &#125;  &#125;  for (i in 0 .. pLen - 1) &#123;    for (j in 0 .. sLen - 1) &#123;      if (p[i] == &#39;*&#39;) &#123;        dp[i + 1][j + 1] = dp[i][j + 1]      &#125; else if (p[i] == &#39;.&#39; || p[i] == s[j]) &#123;        if (i + 1 &lt; pLen &amp;&amp; p[i + 1] == &#39;*&#39;) &#123;          dp[i + 1][j + 1] = dp[i][j + 1] || dp[i + 1][j]        &#125; else &#123;          dp[i + 1][j + 1] = dp[i][j]        &#125;      &#125; else &#123;        if (i + 1 &lt; pLen &amp;&amp; p[i + 1] == &#39;*&#39;) &#123;          dp[i + 1][j + 1] = dp[i][j + 1]        &#125;      &#125;    &#125;  &#125;  return dp[pLen][sLen]&#125;</code></pre><p>NOTE: 递归逐字符对比，根据模式字符串与被匹配字符的前两个字符的匹配结果不断地向前移动字符串，如果模式字符串为空了，那么被匹配的字符串也要为空才能正确地匹配。DP解法注意初始的条件。</p><h4 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h4><p>[Two Pointers | Array]</p><p>Given <code>n</code> non-negative integers <code>a1, a2, ..., an</code> , where each represents a point at coordinate <code>(i, ai)</code>. <code>n</code> vertical lines are drawn such that the two endpoints of the line <code>i</code> is at <code>(i, ai)</code> and <code>(i, 0)</code>. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.</p><p><strong>Notice</strong> that you may not slant the container.</p><pre><code class="kotlin">fun maxArea(height: IntArray): Int &#123;  var start = 0  var end = height.size - 1  var max = 0  while (start &lt; end) &#123;    val area = Math.min(height[start], height[end]) * (end - start)    if (area &gt; max) &#123;      max = area    &#125;    if (height[start] &gt; height[end]) &#123;      end--    &#125; else &#123;      start++    &#125;  &#125;  return max&#125;</code></pre><p>NOTE:  面积大小取决于最矮高度， min(x, y) * width,  宽度一定只能尽可能地增加高度才能让面积最大</p><h4 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a>12. Integer to Roman</h4><p>[Math]</p><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p><p>For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9. </li><li>X can be placed before L (50) and C (100) to make 40 and 90. </li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral.</p><pre><code class="kotlin">fun intToRoman(num: Int): String &#123;  val ret = StringBuilder()  val romanInt = intArrayOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)  val romanStr = arrayOf(&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;)  var num = num  var i = 0  while (num &gt; 0) &#123;    if (num - romanInt[i] &gt;= 0) &#123;      num -= romanInt[i]      ret.append(romanStr[i])    &#125; else &#123;      i++    &#125;  &#125;  return ret.toString()&#125;</code></pre><p>NOTE:  罗马数字的特征，尽可能优先使用较大数值对应的字符，最后转换的结果字符最少，理由贪心算法思想，从最高位开始匹配，就能保证字符串最少。最开始想到的是另外一种方法查表法，将罗马数字的所有个位，十位..组合罗列出来，取低位的值不断地加，列表的时候较烦琐。  </p><h4 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h4><p>[Math]</p><pre><code class="kotlin">fun romanToInt(s: String): Int &#123;    var ret = 0    val romanMap = mapOf(&quot;M&quot; to 1000, &quot;CM&quot; to 900, &quot;D&quot; to 500, &quot;CD&quot; to 400,                         &quot;C&quot; to 100, &quot;XC&quot; to 90, &quot;L&quot; to 50, &quot;XL&quot; to 40, &quot;X&quot; to 10, &quot;IX&quot; to 9,                         &quot;V&quot; to 5, &quot;IV&quot; to 4, &quot;I&quot; to 1)    var romanStr = s    while (romanStr.isNotEmpty()) &#123;        if (romanStr.length &gt; 1 &amp;&amp; romanMap[romanStr.substring(0, 2)] != null) &#123;            ret += romanMap[romanStr.substring(0, 2)]!!            romanStr = romanStr.substring(2)        &#125; else &#123;            ret += romanMap[romanStr.substring(0, 1)]!!            romanStr = romanStr.substring(1)        &#125;    &#125;    return ret&#125;</code></pre><p>NOTE: 思路同12，利用贪心算法。罗马数字高位就包含了位置信息只需从高位得到阿拉伯数字的值加上低位即可。</p><h4 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h4><p>[String]</p><pre><code class="kotlin">fun longestCommonPrefix(strs: Array&lt;String&gt;): String &#123;    if (strs.isEmpty()) return &quot;&quot;    var ret = strs[0]    for (i in 1 until strs.size) &#123;        ret = computeCommonPrefix(ret, strs[i])        if (ret.isEmpty()) &#123;            return &quot;&quot;        &#125;    &#125;    return ret&#125;private fun computeCommonPrefix(s1: String, s2: String): String &#123;    var i = 0    var j = 0    while (i &lt; s1.length &amp;&amp; j &lt; s2.length) &#123;        if (s1[i] == s2[j]) &#123;            i++            j++        &#125; else &#123;            break        &#125;    &#125;    return s1.substring(0, i)&#125;</code></pre><h4 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h4><p>[Array | Two Pointer]</p><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Notice that the solution set must not contain duplicate triplets.</p><pre><code class="kotlin">fun threeSum(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;    if (nums.size &lt; 3) &#123;        return listOf()    &#125;    nums.sort()    val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()    for ((index, value) in nums.withIndex()) &#123;        if (index != 0 &amp;&amp; nums[index] == nums[index - 1]) &#123;            continue        &#125;        var start = index + 1        var end = nums.size - 1        while (start &lt; end) &#123;            if (start != (index + 1) &amp;&amp; nums[start] == nums[start - 1]) &#123;                start++;                continue;            &#125;            val threeSum = value + nums[start] + nums[end]            if (threeSum == 0) &#123;                ret.add(listOf(value, nums[start], nums[end]))                end--                start++            &#125; else if (threeSum &gt; 0) &#123;                end--            &#125; else &#123;                start++            &#125;        &#125;    &#125;    return ret&#125;</code></pre><p>NOTE: 排序，去重，利用双指针特性</p><h4 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h4><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><pre><code class="kotlin">fun threeSumClosest(nums: IntArray, target: Int): Int &#123;    nums.sort()    var closest = 0    var distance = Integer.MAX_VALUE    for ((index, value) in nums.withIndex()) &#123;        if (index != 0 &amp;&amp; nums[index] == nums[index - 1]) &#123;            continue        &#125;        var start = index + 1        var end = nums.size - 1        while (start &lt; end) &#123;            if (start != index + 1 &amp;&amp; nums[start - 1] == nums[start]) &#123;                start++                continue            &#125;            val treeSum = value + nums[start] + nums[end]            val curDistance = treeSum - target            if (curDistance == 0) &#123;                return target            &#125; else if (curDistance &gt; 0) &#123;                end--            &#125; else if (curDistance &lt; 0) &#123;                start++            &#125;            val absDis = Math.abs(curDistance)            if (absDis &lt; distance) &#123;                closest = treeSum                distance = absDis            &#125;        &#125;    &#125;    return closest&#125;</code></pre><h4 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h4><p>[String | Backtracking | Depth-first Search | Recursion] </p><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><pre><code>//使用数组记录进位信息fun letterCombinations(digits: String): List&lt;String&gt; &#123;    val ret = mutableListOf&lt;String&gt;()    val numberStrList = mutableListOf&lt;String&gt;()    for (c in digits) &#123;        numberStrList.add(letterTable(c))    &#125;    val arrIndex = Array(numberStrList.size) &#123;0&#125;    while (true) &#123;        val strBuilder = StringBuilder()        for ((index, numStr) in numberStrList.withIndex()) &#123;            strBuilder.append(numStr[arrIndex[index]])        &#125;        if (strBuilder.isNotEmpty()) &#123;            ret.add(strBuilder.toString())        &#125;        var carry = 1        for (i in arrIndex.size - 1 downTo 0) &#123;            if (carry == 0) &#123;                break            &#125;            if (arrIndex[i] + carry == numberStrList[i].length) &#123;                carry = 1                arrIndex[i] = 0            &#125; else &#123;                arrIndex[i] += carry                carry = 0            &#125;        &#125;        if (carry == 1) &#123;            break        &#125;    &#125;    return ret&#125;fun letterTable(char: Char) = when (char) &#123;    &#39;2&#39; -&gt; &quot;abc&quot;    &#39;3&#39; -&gt; &quot;def&quot;    &#39;4&#39; -&gt; &quot;ghi&quot;    &#39;5&#39; -&gt; &quot;jkl&quot;    &#39;6&#39; -&gt; &quot;mno&quot;    &#39;7&#39; -&gt; &quot;pqrs&quot;    &#39;8&#39; -&gt; &quot;tuv&quot;    &#39;9&#39; -&gt; &quot;wxyz&quot;    else -&gt; &quot;&quot;&#125;val ret = mutableListOf&lt;String&gt;()fun letterCombinations(digits: String): List&lt;String&gt; &#123;    if (digits.length == 0) &#123;        return ret    &#125;    val numberStrList = mutableListOf&lt;String&gt;()    for (c in digits) &#123;        numberStrList.add(letterTable(c))    &#125;    internalLetterCombination(0, numberStrList, StringBuilder())    return ret&#125;fun internalLetterCombination(index: Int, numberStrList:List&lt;String&gt;, sb:StringBuilder) &#123;    if (index == numberStrList.size) &#123;        ret.add(sb.toString())        return    &#125;    for (c in numberStrList[index]) &#123;        sb.append(c)        internalLetterCombination(index + 1, numberStrList, sb)        sb.deleteCharAt(sb.length - 1)    &#125;&#125;</code></pre><p>NOTE：两种方法，递归与迭代</p><h4 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h4><p>[Two Pointer | HashTable]</p><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p><p>Notice that the solution set must not contain duplicate quadruplets.</p><pre><code class="kotlin">fun fourSum(nums: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123;    val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()    nums.sort()    for (i in 0..nums.size - 1) &#123;        if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;            continue        &#125;        for (j in i + 1..nums.size - 1) &#123;            if (j != i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;                continue            &#125;            var start = j + 1            var end = nums.size - 1            while (start &lt; end) &#123;                val tmp = nums[i] + nums[j] + nums[start] + nums[end]                if (target == tmp) &#123;                    ret.add(listOf(nums[i], nums[j], nums[start], nums[end]))                    start++                    end--                &#125; else if (tmp &gt; target) &#123;                    end--                &#125; else &#123;                    start++                &#125;            &#125;        &#125;    &#125;    return ret&#125;</code></pre><p>NOTE：时间复杂度(o^3)</p><h4 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h4><p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p><p>Follow up: Could you do this in one pass?</p><pre><code class="kotlin">fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? &#123;    val dummyHead = ListNode(0)    dummyHead.next = head    val recordList = mutableListOf&lt;ListNode&gt;()    var tmp: ListNode? = dummyHead    while (tmp != null) &#123;        recordList.add(tmp)        tmp = tmp.next    &#125;    val toRemove = recordList[recordList.size - n]    val preToRemove = recordList[recordList.size - n - 1]    preToRemove.next = toRemove.next    return dummyHead.next&#125;</code></pre><p>NOTE: 构造Dummy节点就不用对头部单独处理； toRemove.next不用判断空；如果不用列表记录位置信息那么需要先遍历一遍算长度</p><h4 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h4><p>Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:</p><ul><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ul><pre><code class="kotlin">fun isValid(s: String): Boolean &#123;    val stack = LinkedList&lt;Char&gt;()    for (c in s) &#123;        val opposite = convertRight(c)        if (opposite != &#39; &#39;) &#123;            if (stack.isEmpty() || stack.pop() != opposite) &#123;                return false            &#125;        &#125; else &#123;            stack.push(c)        &#125;    &#125;    return stack.isEmpty()&#125;fun convertRight(c: Char) = when(c) &#123;    &#39;)&#39; -&gt; &#39;(&#39;    &#39;]&#39; -&gt; &#39;[&#39;    &#39;&#125;&#39; -&gt; &#39;&#123;&#39;    else -&gt; &#39; &#39;&#125;</code></pre><p>NOTE: 注意stack.isEmpty()判断顺序</p><h4 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h4><p>[LinkedList | Recursion]</p><p>Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.</p><pre><code class="kotlin">fun mergeTwoLists(l1: ListNode?, l2: ListNode?): ListNode? &#123;    if (l1 == null) &#123;        return l2    &#125; else if (l2 == null) &#123;        return l1    &#125; else if (l1.`val` &lt; l2.`val`) &#123;        l1.next = mergeTwoLists(l1.next, l2)        return l1    &#125; else &#123;        l2.next = mergeTwoLists(l1, l2.next)        return l2    &#125;&#125;</code></pre><p>Note: 递归简洁</p><h4 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h4><p>[String | Backtracking]</p><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><pre><code class="kotlin">val ret1 = mutableListOf&lt;String&gt;()fun generateParenthesis(n: Int): List&lt;String&gt; &#123;    generateParenthesisInternal(n, n , StringBuilder())    return ret1&#125;fun generateParenthesisInternal(leftBracket: Int, rightBracket: Int, sb: StringBuilder) &#123;    if (leftBracket == 0 &amp;&amp; rightBracket == 0) &#123;        ret1.add(sb.toString())        return    &#125; else if (leftBracket &gt; rightBracket) &#123;        return    &#125; else if (leftBracket &lt; 0) &#123;        return    &#125;    sb.append(&#39;(&#39;)    generateParenthesisInternal(leftBracket - 1, rightBracket, sb)    sb.deleteCharAt(sb.length - 1)    sb.append(&#39;)&#39;)    generateParenthesisInternal(leftBracket, rightBracket - 1, sb)    sb.deleteCharAt(sb.length - 1)&#125;</code></pre><p>Note: 回溯结束条件</p><h4 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h4><p>[LinkedList | Divide and Conquer | Heap]</p><p>You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.</p><p>Merge all the linked-lists into one sorted linked-list and return it.</p><pre><code class="kotlin">fun mergeKLists(lists: Array&lt;ListNode?&gt;): ListNode? &#123;    return mergeKListsIntern(lists)&#125;fun mergeKListsIntern(lists: Array&lt;ListNode?&gt;): ListNode? &#123;    if (lists.size == 1) &#123;        return lists[0]    &#125; else if (lists.isEmpty()) &#123;        return null    &#125;    val leftListNode = mergeKListsIntern(lists.sliceArray(0 .. lists.size / 2 - 1))    val rightListNode = mergeKListsIntern(lists.sliceArray(lists.size / 2 .. lists.size - 1))    return mergeTwoListNode(leftListNode, rightListNode)&#125;fun mergeTwoListNode(l1: ListNode?, l2: ListNode?): ListNode? &#123;    if (l1 == null) &#123;        return l2    &#125; else if (l2 == null) &#123;        return l1    &#125; else if (l1.`val` &lt; l2.`val`) &#123;        l1.next = mergeTwoListNode(l1.next, l2)        return l1    &#125; else &#123;        l2.next = mergeTwoListNode(l1, l2.next)        return l2    &#125;&#125;</code></pre><h4 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a>24. Swap Nodes in Pairs</h4><p>[LinkedList | ]</p><p>Given a linked list, swap every two adjacent nodes and return its head.</p><pre><code class="kotlin">fun swapPairs(head: ListNode?): ListNode? &#123;    val dummyListNode = ListNode()    dummyListNode.next = head    var ihead = head    var pre = dummyListNode    while (ihead != null &amp;&amp; ihead.next != null) &#123;        val node1: ListNode = ihead        val node2: ListNode = ihead.next!!        pre.next = node2        node1.next = node2.next        node2.next = node1        ihead = node1.next        pre = node1    &#125;    return dummyListNode.next&#125;fun  swapPairs(head: ListNode?): ListNode? &#123;    if (head == null || head.next == null) &#123;        return head    &#125;    val newHead: ListNode = head.next!!    head.next = swapPairs(newHead.next)    newHead.next = head    return newHead&#125;</code></pre><p>NOTE：同时遍历两个节点；递归版本!!!</p><h3 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h3><p>[LinkedList]</p><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</p><p>Follow up:</p><ul><li>Could you solve the problem in O(1) extra memory space?</li><li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li></ul><pre><code class="kotlin">fun reverseKGroup(head: ListNode?, k: Int): ListNode? &#123;    val dummyHead = ListNode()    dummyHead.next = head    var ihead = head    var cur = head    var cnt = 1    var preCur: ListNode? = dummyHead    while (ihead != null) &#123;        if (k == cnt) &#123;            //reverse from cur ...            val newTail = cur            var curN = cur?.next            var curNN:ListNode? = null            while (cnt &gt; 1) &#123;                curNN = curN?.next                curN?.next = cur                cur = curN                curN = curNN                cnt--            &#125;            newTail?.next = curN            preCur?.next = cur            cur = curN            preCur = newTail            ihead = newTail?.next            //cnt = 1        &#125; else &#123;            cnt++            ihead = ihead.next        &#125;    &#125;    return dummyHead.next&#125;</code></pre><p>NOTE: 利用三个指针反转链表到达空间复杂度O(1)</p><h4 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h4><p>[Array | Two Pointer]</p><p>Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><pre><code class="kotlin">fun removeDuplicates(nums: IntArray): Int &#123;    if (nums.isEmpty()) &#123;        return 0    &#125;    var i = 0    for (j in 1 .. nums.size - 1) &#123;        if (nums[i] != nums[j]) &#123;            i++            nums[i] = nums[j]        &#125;    &#125;    return i + 1&#125;</code></pre><p>NOTE: 快慢指针移动赋值补位，不用移动后面的所有元素..</p><h4 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h4><p>[Array | Two Pointer]</p><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><pre><code class="kotlin">fun removeElement(nums: IntArray, `val`: Int): Int &#123;    var i = -1    for (j in 0 .. nums.size - 1) &#123;        if (nums[j] != `val`) &#123;            i++            nums[i] = nums[j]        &#125;    &#125;    return i + 1&#125;</code></pre><h4 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a>28. Implement strStr()</h4><p>Implement strStr().</p><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><pre><code class="kotlin">fun strStr(haystack: String, needle: String): Int &#123;  val m = haystack.length  val n = needle.length  if (n == 0) return 0  if (n &gt; m) &#123;    return -1  &#125;  for (i in 0 .. m - n) &#123;    for (j in 0 .. n - 1) &#123;      if (haystack[i + j] != needle[j]) break      if (j == n - 1) &#123;        return i      &#125;    &#125;  &#125;  return -1&#125;</code></pre><h4 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29. Divide Two Integers"></a>29. Divide Two Integers</h4><p>[Math]</p><p>Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.</p><p>Return the quotient after dividing dividend by divisor.</p><p>The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.</p><p>Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For this problem, assume that your function returns 2^31 − 1 when the division result overflows.</p><pre><code class="kotlin">fun divide(dividend: Int, divisor: Int): Int &#123;    if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123;        return Integer.MAX_VALUE;    &#125;    val positive = (dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0)    val absDividend = Math.abs(dividend)    val absDivisor = Math.abs(divisor)    var toDec = absDivisor    var total = absDividend    var ret = 0    var cnt = 1    while (total - toDec &gt;= 0) &#123;        total -= toDec        ret += cnt        if (total &lt;=0 ) &#123;            break        &#125;        if (total - (toDec shl 1) &lt; 0) &#123;            toDec = absDivisor            cnt = 1        &#125; else &#123;            if (toDec  &lt; Int.MAX_VALUE - toDec) &#123;                toDec = (toDec shl 1)                cnt += cnt            &#125;        &#125;    &#125;    if (positive) &#123;        return ret    &#125; else &#123;        return -ret    &#125;&#125;</code></pre><p>NOTE: 加法和就绝对值都可能溢出</p><h4 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30. Substring with Concatenation of All Words"></a>30. Substring with Concatenation of All Words</h4><p>[HashTable]</p><p>You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.</p><p>You can return the answer in any order.</p><pre><code class="kotlin">fun findSubstring(s: String, words: Array&lt;String&gt;): List&lt;Int&gt; &#123;    val ret = mutableListOf&lt;Int&gt;()    val wordCountMap = mutableMapOf&lt;String, Int&gt;()    for (word in words) &#123;        wordCountMap.put(word, wordCountMap.getOrDefault(word, 0) + 1)    &#125;    val wordLen = words[0].length    val totalWorldLen = words.sumBy &#123; it.length &#125;    for (i in 0 .. s.length - totalWorldLen) &#123;        val subStrMap = mutableMapOf&lt;String, Int&gt;()        var matchedCnt = 0        for (j in i .. i + totalWorldLen - 1 step wordLen) &#123;            val subStr = s.substring(j, j + wordLen)            val cnt = subStrMap.getOrDefault(subStr, 0) + 1            if (cnt &gt; wordCountMap.getOrDefault(subStr, 0)) &#123;                break            &#125;            matchedCnt++            subStrMap.put(subStr, cnt)        &#125;        if (matchedCnt == words.size) &#123;            ret.add(i)        &#125;    &#125;    return ret&#125;</code></pre><p>NOTE：使用HashMap加速匹配</p><h4 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. Next Permutation</h4><p>[Array]</p><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).</p><p>The replacement must be in place and use only constant extra memory.</p><pre><code class="kotlin">fun nextPermutation(nums: IntArray): Unit &#123;  var end = nums.size - 1  var i = -1  var j = -1  //find i  for (k in end downTo 1) &#123;    if (nums[k] &gt; nums[k - 1]) &#123;      i = k - 1      break    &#125;  &#125;  //find j  if (i != -1) &#123;    for (k in end downTo i) &#123;      if (nums[k] &gt; nums[i]) &#123;        j = k        break      &#125;    &#125;  &#125;  //swap i and j  if (i != -1 &amp;&amp; j != -1) &#123;    swap(nums, i, j)  &#125;  //reverse i .. tail  var start = i + 1  while (start &lt; end) &#123;    swap(nums, start++, end--)  &#125;&#125;fun swap(arr: IntArray, i: Int, j: Int) &#123;  val tmp = arr[i]  arr[i] = arr[j]  arr[j] = tmp&#125;</code></pre><p>NOTE: 要让数变大-&gt;将右边较大的数与左边较小的数交换，要想使变化的幅度最小，要在较大的数里面找到最小的</p><h4 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a>32. Longest Valid Parentheses</h4><p>[String | Dynamic Program]</p><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p><pre><code class="kotlin">fun longestValidParentheses(s: String): Int &#123;    val dp = IntArray(s.length)    var ret = 0    for ((index, value) in s.withIndex()) &#123;        if (value == &#39;)&#39;) &#123;            if (index &gt; 0) &#123;                if (s[index - 1] == &#39;(&#39;) &#123;                    dp[index] = (if (index - 2 &gt;= 0) dp[index - 2] else 0) + 2                &#125; else if (s[index - 1] == &#39;)&#39; &amp;&amp; index - dp[index - 1] - 1 &gt;= 0 &amp;&amp; s[index - dp[index - 1] - 1] == &#39;(&#39;) &#123;                    dp[index] = dp[index - 1] + 2 + if (index - dp[index - 1] - 2 &gt;= 0) dp[index - dp[index - 1] - 2] else 0                &#125;                ret = Math.max(dp[index], ret)            &#125;        &#125;    &#125;    return ret&#125;</code></pre><p>NOTE: 使用例子列状态转移方程，尾部存在两张情况 “()”， “(…XX))”</p><h4 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h4><p>[Binary Search]</p><p>There is an integer array nums sorted in ascending order (with distinct values).</p><p>Prior to being passed to your function, nums is rotated at an unknown pivot index k (0 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].</p><p>Given the array nums after the rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</p><pre><code class="kotlin">fun search(nums: IntArray, target: Int): Int &#123;    var left = 0    var right = nums.size - 1    while (left &lt;= right) &#123;        val mid = (left + right) / 2        if (target == nums[mid]) &#123;            return mid        &#125;        if (nums[left] &lt;= nums[mid]) &#123;//left sorted， 注意这里的等号，left与mid在两个数的时候相等            if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;                right = mid - 1            &#125; else &#123;                left = mid + 1            &#125;        &#125; else &#123;//right sorted            if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                left = mid + 1            &#125; else &#123;                right = mid - 1            &#125;        &#125;    &#125;    return -1&#125;</code></pre><p>Note: 二分法，有一边肯定是有序的，判断是否在有序的返回以内，如果在，那么就可以在这个范围查找，不在的话肯定在另外一边</p><h4 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a>34. Find First and Last Position of Element in Sorted Array</h4><p>[Binary Search]</p><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p><p>If target is not found in the array, return [-1, -1].</p><p>Follow up: Could you write an algorithm with O(log n) runtime complexity?</p><pre><code class="kotlin">fun searchRange(nums: IntArray, target: Int): IntArray &#123;    var l = 0    var r = nums.size - 1    var retL = -1    var retR = -1    //search left bound    while (l &lt;= r) &#123;        val mid = (l + r) / 2        if (nums[mid] == target) &#123;            retL = mid            r = mid - 1        &#125; else if (nums[mid] &gt; target) &#123;            r = mid - 1        &#125; else &#123;            l = mid + 1        &#125;    &#125;    //search right bound    l = 0    r = nums.size - 1    while (l &lt;= r) &#123;        val mid = (l + r) / 2        if (nums[mid] == target) &#123;            retR = mid            l = mid + 1        &#125; else if (nums[mid] &gt; target) &#123;            r = mid - 1        &#125; else &#123;            l = mid + 1        &#125;    &#125;    return intArrayOf(retL, retR)&#125;</code></pre><p>Note: 二分法核心是确定搜索区间</p><h4 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h4><p>[Binary Search]</p><p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><pre><code class="kotlin">fun searchInsert(nums: IntArray, target: Int): Int &#123;    var l = 0    var r = nums.size - 1    while (l &lt;= r) &#123;        val mid = (l + r) / 2        if (nums[mid] == target) &#123;            return mid        &#125; else if (nums[mid] &gt; target) &#123;            r = mid - 1        &#125; else if (nums[mid] &lt; target) &#123;            l = mid + 1        &#125;    &#125;    return l&#125;</code></pre><h4 id="36-Valid-Sudoku"><a href="#36-Valid-Sudoku" class="headerlink" title="36. Valid Sudoku"></a>36. Valid Sudoku</h4><p>[Array | HashTable]</p><p>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p><ul><li>Each row must contain the digits 1-9 without repetition.</li><li>Each column must contain the digits 1-9 without repetition.</li><li>Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li></ul><p>Note:</p><ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned rules.</li></ul><pre><code class="kotlin">fun isValidSudoku(board: Array&lt;CharArray&gt;): Boolean &#123;    val rowMap = Array(10) &#123;IntArray(10)&#125;    val colMap = Array(10) &#123;IntArray(10)&#125;    val subBoxMap = Array(10) &#123;IntArray(10)&#125;    var row = 0    while (row &lt; board.size) &#123;        var col = 0        while (col &lt; board[row].size) &#123;            if (board[row][col] == &#39;.&#39;) &#123;                col++                continue            &#125;            val digits = board[row][col] - &#39;0&#39;            //row exists            if (rowMap[row][digits] != 0) &#123;                return false            &#125; else &#123;                rowMap[row][digits] = 1            &#125;            //col exists            if (colMap[col][digits] != 0) &#123;                return false            &#125; else &#123;                colMap[col][digits] = 1            &#125;            //subbox exists            if (subBoxMap[(row / 3) * 3 + col / 3][digits] != 0) &#123;                return false            &#125; else &#123;                subBoxMap[(row / 3) * 3 + col / 3][digits] = 1            &#125;            col++        &#125;        row++    &#125;    return true&#125;</code></pre><p>NOTE: 逐个遍历，然后使用表加速查找</p><h4 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a>37. Sudoku Solver</h4><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy all of the following rules:</p><ul><li>Each of the digits 1-9 must occur exactly once in each row.</li><li>Each of the digits 1-9 must occur exactly once in each column.</li><li>Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.</li></ul><p>The ‘.’ character indicates empty cells.</p><pre><code class="kotlin">fun solveSudoku(board: Array&lt;CharArray&gt;): Unit &#123;    val rowTable = Array(10) &#123; IntArray(10) &#123; 0 &#125; &#125;    val colTable = Array(10) &#123; IntArray(10) &#123; 0 &#125; &#125;    val subTable = Array(10) &#123; IntArray(10) &#123; 0 &#125; &#125;    for (row in 0..board.size - 1) &#123;        for (col in 0..board[0].size - 1) &#123;            if (board[row][col] != &#39;.&#39;) &#123;                val digit = board[row][col] - &#39;0&#39;                rowTable[row][digit] = 1                colTable[col][digit] = 1                subTable[3 * (row / 3) + col / 3][digit] = 1            &#125;        &#125;    &#125;    solveSudoku(board, rowTable, colTable, subTable, 0, 0)&#125;fun solveSudoku(board: Array&lt;CharArray&gt;, rowTable: Array&lt;IntArray&gt;, colTable: Array&lt;IntArray&gt;, subTable: Array&lt;IntArray&gt;, row: Int, col: Int): Boolean &#123;    if (row == board.size) &#123;        return true    &#125;    var ret: Boolean = false    if (board[row][col] == &#39;.&#39;) &#123;        for (i in 1..9) &#123;            if (rowTable[row][i] != 1 &amp;&amp; colTable[col][i] != 1 &amp;&amp; subTable[3 * (row / 3) + col / 3][i] != 1) &#123;                rowTable[row][i] = 1                colTable[col][i] = 1                subTable[3 * (row / 3) + col / 3][i] = 1                board[row][col] = &#39;0&#39; + i                if (col == board[0].size - 1) &#123;                    ret = solveSudoku(board, rowTable, colTable, subTable, row + 1, 0)                &#125; else &#123;                    ret = solveSudoku(board, rowTable, colTable, subTable, row, col + 1)                &#125;                if (ret) &#123;                    return true                &#125;                board[row][col] = &#39;.&#39;                rowTable[row][i] = 0                colTable[col][i] = 0                subTable[3 * (row / 3) + col / 3][i] = 0            &#125;        &#125;    &#125; else &#123;        if (col == board[0].size - 1) &#123;            ret = solveSudoku(board, rowTable, colTable, subTable, row + 1, 0)        &#125; else &#123;            ret = solveSudoku(board, rowTable, colTable, subTable, row, col + 1)        &#125;    &#125;    return ret&#125;</code></pre><p>Note: 万能的回溯..</p><h4 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38. Count and Say"></a>38. Count and Say</h4><p>[String]</p><p>The count-and-say sequence is a sequence of digit strings defined by the recursive formula:</p><ul><li>countAndSay(1) = “1”</li><li>countAndSay(n) is the way you would “say” the digit string from countAndSay(n-1), which is then converted into a different digit string.</li></ul><p>To determine how you “say” a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.</p><pre><code class="kotlin">fun countAndSay(n: Int): String &#123;    var ret = StringBuilder()    for (i in 1..n) &#123;        if (ret.isEmpty()) &#123;            ret.append(i)        &#125; else &#123;            val tmp = StringBuilder()            var lastChar = &#39;x&#39;            var cnt = 1            for ((index, c) in ret.withIndex()) &#123;                if (index == 0) &#123;                    tmp.append(c)                &#125; else &#123;                    if (lastChar == c) &#123;                        cnt++                    &#125; else &#123;                        tmp.append(cnt)                        tmp.append(c)                        cnt = 1                    &#125;                &#125;                lastChar = c            &#125;            tmp.append(cnt)            ret = tmp        &#125;    &#125;    return ret.reverse().toString()&#125;</code></pre><h4 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h4><p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</p><p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p><p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p><pre><code class="kotlin">val ret5 = mutableListOf&lt;List&lt;Int&gt;&gt;()fun combinationSum(candidates: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123;    //candidates.sort()    internalCombinationSum(candidates,  target, mutableListOf(), 0)    return ret5&#125;fun internalCombinationSum(candidates: IntArray, target: Int, tracer: MutableList&lt;Int&gt;, startIndex: Int) &#123;    val sum = tracer.sum()    if (sum == target) &#123;        ret5.add(ArrayList(tracer))        return    &#125; else if (sum &gt; target) &#123;        return    &#125;    for (i in startIndex..candidates.size - 1) &#123;        tracer.add(candidates[i])        internalCombinationSum(candidates, target, tracer, i)        tracer.removeAt(tracer.size - 1)    &#125;&#125;</code></pre><p>Note: 可不排序，排序后减少回溯分支</p><h4 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h4><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.</p><p>Each number in candidates may only be used once in the combination.</p><p>Note: The solution set must not contain duplicate combinations.</p><pre><code class="kotlin">val ret6 = mutableListOf&lt;List&lt;Int&gt;&gt;()fun combinationSum2(candidates: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123;    candidates.sort()    combinationSum2Recur(candidates, target, 0, mutableListOf())    return ret6&#125;fun combinationSum2Recur(candidates: IntArray, target: Int, startIndex: Int, tracer: MutableList&lt;Int&gt;) &#123;    val sum = tracer.sum()    if (sum == target) &#123;        ret6.add(ArrayList(tracer))        return    &#125; else if (sum &gt; target) &#123;        return    &#125;    for (i in startIndex..candidates.size - 1) &#123;        if (i != startIndex &amp;&amp; candidates[i] == candidates[i - 1]) &#123;            continue        &#125;        tracer.add(candidates[i])        combinationSum2Recur(candidates, target, i + 1, tracer)        tracer.removeAt(tracer.size - 1)    &#125;&#125;</code></pre><p>Note: 排序去重</p><h4 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a>41. First Missing Positive</h4><p>Given an unsorted integer array nums, find the smallest missing positive integer.</p><pre><code class="kotlin">fun firstMissingPositive(nums: IntArray): Int &#123;    val len = nums.size + 1    val hash = Array(len)&#123;-1&#125;    for ((index, value) in nums.withIndex()) &#123;        if (value &gt; 0  &amp;&amp; value &lt; len) &#123;            hash[value] = index        &#125;    &#125;    for (i in  1 .. nums.size) &#123;        if (hash[i] == -1) &#123;            return i        &#125;    &#125;    return nums.size + 1&#125;</code></pre><p>Note: 利用哈希表加速查找</p><h4 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h4><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p><pre><code class="kotlin">//DP:fun trap(height: IntArray): Int &#123;    if (height.size &lt;= 2) &#123;        return 0    &#125;    var ret = 0    val maxLefts = Array(height.size)&#123;0&#125;    val maxRights = Array(height.size)&#123;0&#125;    var tmpMax = 0    for (i in 0 .. height.size - 1) &#123;        maxLefts[i] = Math.max(height[i], tmpMax)        tmpMax = maxLefts[i]    &#125;    tmpMax = 0    for (i in height.size - 1 downTo 0) &#123;        maxRights[i] = Math.max(height[i], tmpMax)        tmpMax = maxRights[i]    &#125;    for (i in 1 .. (height.size - 2)) &#123;        val area = Math.min(maxLefts[i], maxRights[i]) - height[i]        if (area &gt; 0) &#123;            ret += area        &#125;    &#125;    return ret&#125;//Two Pointerfun trap(height: IntArray): Int &#123;  if (height.size &lt; 3) &#123;    return 0  &#125;  var ret = 0  var maxLeft = height[0]  var maxRight = height[height.size - 1]  var left = 1  var right = height.size - 2  while (left &lt;= right) &#123;    if (maxLeft &lt; maxRight) &#123;      val area = maxLeft - height[left]      if (area &gt; 0) &#123;        ret += area      &#125;      maxLeft = Math.max(maxLeft, height[left])      left++    &#125; else &#123;      val area = maxRight - height[right]      if (area &gt; 0) &#123;        ret += area      &#125;      maxRight = Math.max(maxRight, height[right])      right--    &#125;  &#125;  return ret&#125;</code></pre><p>Note: 当前条的面积等于左边的最大高度与右边最小高度的最小值减去当前条的高度。双指针可以利用隐含条件，当另外一边的最大大于已经遍历过的这一边的最大，就可以确定左右最大中的最小。</p><h4 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="43. Multiply Strings"></a>43. Multiply Strings</h4><p>[String | Math]</p><p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</p><p>Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.</p><pre><code class="kotlin">fun multiply(num1: String, num2: String): String &#123;    if (num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) &#123;        return &quot;0&quot;    &#125;    var ret = &quot;&quot;    var tailZero = 0    for (c2 in num2.length - 1 downTo  0) &#123;        val i2 = num2[c2] - &#39;0&#39;        var carry = 0        val tmp = StringBuilder()        for (c1 in num1.length - 1 downTo  0) &#123;            val i1 = num1[c1] - &#39;0&#39;            val product = i1 * i2 + carry            val cur = product % 10            carry = product / 10            tmp.append(cur.toString())        &#125;        if (carry &gt; 0) &#123;            tmp.append(carry)        &#125;        for (i in 1..tailZero) &#123;            tmp.insert(0, &quot;0&quot;)        &#125;        ret = plus(ret, tmp.toString())        tailZero++    &#125;    return ret.reversed()&#125;fun plus(num1: String, num2: String): String &#123;    if (num1.isEmpty()) &#123;        return num2    &#125;else if (num2.isEmpty()) &#123;        return num1    &#125;    val ret = StringBuilder()    var i = 0    var j = 0    var carry = 0    while (true) &#123;        if (i &lt;= num1.length - 1 &amp;&amp; j &lt;= num2.length - 1) &#123;            val i1 = num1[i] - &#39;0&#39;            val i2 = num2[i] - &#39;0&#39;            val addtion = i1 + i2 + carry            ret.append(addtion % 10)            carry = addtion / 10        &#125; else if (i &lt;= num1.length - 1) &#123;            val v = num1[i] - &#39;0&#39;            val addtion = v + carry            ret.append(addtion % 10)            carry = addtion / 10        &#125; else if (j &lt;= num2.length - 1) &#123;            val v = num2[j] - &#39;0&#39;            val addtion = v + carry            ret.append(addtion % 10)            carry = addtion / 10        &#125; else &#123;            break        &#125;        i++        j++    &#125;    if (carry &gt; 0) &#123;        ret.append(carry)    &#125;    return ret.toString()&#125;</code></pre><h4 id="44-Wildcard-Matching"><a href="#44-Wildcard-Matching" class="headerlink" title="44. Wildcard Matching"></a>44. Wildcard Matching</h4><p>[Dynamic Programing]</p><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’ where:</p><ul><li>‘?’ Matches any single character.</li><li>‘*’ Matches any sequence of characters (including the empty sequence).</li></ul><p>The matching should cover the entire input string (not partial).</p><pre><code class="kotlin">    fun isMatch(s: String, p: String): Boolean &#123;        val pLen = p.length        val sLen = s.length        val dp = Array(pLen + 1)&#123; BooleanArray(sLen + 1)&#125;        dp[0][0] = true        for (i in 0 .. pLen - 1) &#123;            if (p[i] == &#39;*&#39;) &#123;                dp[i + 1][0] = true            &#125; else &#123;                break            &#125;        &#125;        for (i in 0 .. pLen-1) &#123;            for (j in 0 .. sLen-1) &#123;                if (p[i] == s[j] || p[i] == &#39;?&#39;) &#123;                    dp[i + 1][j + 1] = dp[i][j]                &#125; else if (p[i] == &#39;*&#39;) &#123;                    dp[i + 1][j + 1] = dp[i][j + 1] || dp[i + 1][j]                &#125;            &#125;        &#125;        return dp[pLen][sLen]    &#125;</code></pre><p>Note: 注意<em>号的转移方程，</em>是左右匹配的，被<em>消耗或者没有被</em>消耗的情况</p><h4 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h4><p>[Greedy]</p><p>Given an array of non-negative integers nums, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Your goal is to reach the last index in the minimum number of jumps.</p><p>You can assume that you can always reach the last index.</p><pre><code class="kotlin">//reverse:fun jump(nums: IntArray): Int &#123;    var step = 0    val end = nums.size - 1    var position = end    var curEnd = end    while (position &gt; 0) &#123;        position--        for (i in 0 until position) &#123;            if (i + nums[i] &gt;= curEnd) &#123;                position = i                break            &#125;        &#125;        curEnd = position        step++    &#125;    return step&#125;//forward:fun jump(nums: IntArray): Int &#123;    var steps = 0    var end = 0    var curMaxDistance = 0    for (i in 0 .. nums.size - 2) &#123;        curMaxDistance = Math.max(nums[i] + i, curMaxDistance)        if (end == i) &#123;            steps++            end = curMaxDistance        &#125;    &#125;    return steps&#125;</code></pre><p>Note: 求局部最优解 —&gt; 全局最优解</p><h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h4><p>[Backtracking]</p><p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p><pre><code class="kotlin">val ret7 = mutableListOf&lt;List&lt;Int&gt;&gt;();fun permute(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;    permuteRecur(nums, mutableListOf())    return ret7&#125;fun permuteRecur(nums: IntArray, tracer: MutableList&lt;Int&gt;) &#123;    if (tracer.size == nums.size) &#123;        ret7.add(tracer.toList())        return    &#125;    for (i in nums) &#123;        if (!tracer.contains(i)) &#123;            tracer.add(i)            permuteRecur(nums, tracer)            tracer.remove(i)        &#125;    &#125;&#125;//Space O(1)val ret8 = mutableListOf&lt;List&lt;Int&gt;&gt;();fun permute(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;    permuteRecur(nums, 0)    return ret8&#125;fun permuteRecur(nums: IntArray, startIndex: Int) &#123;    if (startIndex == nums.size) &#123;        ret8.add(nums.toList())        return    &#125;    for (index in startIndex .. nums.size - 1) &#123;        swap(nums, index, startIndex)        permuteRecur(nums, startIndex + 1)        swap(nums, index, startIndex)    &#125;&#125;fun swap(x: IntArray, a: Int, b: Int) &#123;    val t = x[a]    x[a] = x[b]    x[b] = t&#125;</code></pre><h4 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h4><p>[Backtracking]</p><p>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.</p><pre><code class="kotlin">val ret9 = mutableListOf&lt;List&lt;Int&gt;&gt;()fun permuteUnique(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;  nums.sort()  permuteUnique(nums, BooleanArray(nums.size), LinkedList())  return ret9&#125;fun permuteUnique(nums: IntArray, visited: BooleanArray, path: LinkedList&lt;Int&gt;) &#123;  if (path.size == nums.size ) &#123;    ret9.add(path.toList())    return  &#125;  for (i in 0 .. nums.size - 1) &#123;    if (i != 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]) &#123;      continue    &#125;    if (visited[i]) &#123;      continue    &#125;    path.add(nums[i])    visited[i] = true    permuteUnique(nums, visited, path)    visited[i] = false    path.removeLast()  &#125;&#125;</code></pre><p>Note: 开始遍历了之后就不用判断相同的上一个</p><h4 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. Rotate Image</h4><p>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).</p><p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p><pre><code class="kotlin">fun rotate(matrix: Array&lt;IntArray&gt;): Unit &#123;  var level = 0  val end = matrix.size - 1  while (matrix.size - 2 * level &gt;= 2) &#123;    for (i in level .. matrix.size - level - 2) &#123;      //(level, i)  -&gt; (i, end - level)      val leftTop = matrix[level][i]      val rightTop = matrix[i][end - level]      val rightBottom = matrix[end - level][end - i]      val leftBottom = matrix[end - i][level]      matrix[level][i] = leftBottom      matrix[i][end - level] = leftTop      matrix[end - level][end - i] = rightTop      matrix[end - i][level] = rightBottom    &#125;    level++  &#125;&#125;</code></pre><p>Note: 注意边界条件</p><h4 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h4><p>[HashTable]</p><p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.</p><p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><pre><code class="kotlin">fun groupAnagrams(strs: Array&lt;String&gt;): List&lt;List&lt;String&gt;&gt; &#123;    val map = mutableMapOf&lt;String, MutableList&lt;String&gt;&gt;()    for (s in strs) &#123;        val chars = s.toCharArray()        chars.sort()        val key = String(chars)        if (map.containsKey(key)) &#123;            map[key]?.add(s)        &#125; else &#123;            map[key] = mutableListOf(s)        &#125;    &#125;    val values = map.values    val ret = mutableListOf&lt;List&lt;String&gt;&gt;()    values.forEach &#123;        ret.add(it)    &#125;    return ret&#125;</code></pre><h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h4><p>[Divide Conquer]</p><p>Implement pow(x, n), which calculates x raised to the power n (i.e. xn).</p><pre><code class="kotlin">//递归：fun myPow(x: Double, n: Int): Double &#123;    if (n &lt; 0) &#123;        return 1.0f / myPowRecur(x, Math.abs(n))    &#125; else &#123;        return myPowRecur(x, Math.abs(n))    &#125;&#125;fun myPowRecur(x: Double, n: Int): Double &#123;    if (n == 1) &#123;        return x    &#125; else if (n == 0) &#123;        return 1.0    &#125;    val part = myPowRecur(x, n / 2)    if (n % 2 == 0) &#123;        return part * part    &#125; else &#123;        return part * part * x    &#125;&#125;//迭代：fun myPow(x: Double, n: Int): Double &#123;    var ret = 1.0    var N = Math.abs(n.toLong())    var tmp = x    while (N &gt; 0) &#123;        if (N and 1 == 1L) &#123;            ret *= tmp        &#125;        N = N shr  1        tmp *= tmp    &#125;    return if (n &gt; 0) ret else 1.0 / ret&#125;</code></pre><p>Note: 指数二进制移位</p><h4 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a>51. N-Queens</h4><p>[Backtracking]</p><p>The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.</p><p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p><p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space, respectively.</p><pre><code class="kotlin">val ret = mutableListOf&lt;List&lt;String&gt;&gt;()fun solveNQueens(n: Int): List&lt;List&lt;String&gt;&gt; &#123;    solveNQueensRecur(n, 0, IntArray(n)&#123;-1&#125;)    return ret&#125;fun solveNQueensRecur(n: Int, row: Int, path: IntArray) &#123;    //check （row - 1）already placed    if (row == path.size) &#123;        val listStr = mutableListOf&lt;String&gt;()        val tmp = StringBuilder()        for (i in path) &#123;            tmp.clear()            for (j in 0 .. row - 1) &#123;                if (i == j) &#123;                    tmp.append(&quot;Q&quot;)                &#125; else &#123;                    tmp.append(&quot;.&quot;)                &#125;            &#125;            listStr.add(tmp.toString())        &#125;        ret.add(listStr)        return    &#125;    for (i in 0 .. n - 1) &#123;        path[row] = i        if (!checkPathIsValid(path, row)) &#123;            continue        &#125;        solveNQueensRecur(n, row + 1, path)        path[row] = -1    &#125;&#125;fun checkPathIsValid(path: IntArray, row: Int) : Boolean &#123;    if (row &gt;= 1) &#123;        val cur = path[row]        for (k in row - 1 downTo 0) &#123;            if (cur == path[k]) &#123;                return false            &#125;            if ((path[k] + row - k) == cur || (path[k] - (row - k)) == cur) &#123;                return false            &#125;        &#125;    &#125;    return true&#125;</code></pre><h4 id="52-N-Queens-II"><a href="#52-N-Queens-II" class="headerlink" title="52. N-Queens II"></a>52. N-Queens II</h4><p>The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.</p><p>Given an integer n, return the number of distinct solutions to the n-queens puzzle.</p><pre><code class="kotlin">var ret2 = 0fun solveNQueensRecur(n: Int, row: Int, path: IntArray) &#123;    //check （row - 1）already placed    if (row == path.size) &#123;        ret2++        return    &#125;    for (i in 0 .. n - 1) &#123;        path[row] = i        if (!checkPathIsValid(path, row)) &#123;            continue        &#125;        solveNQueensRecur(n, row + 1, path)        path[row] = -1    &#125;&#125;fun checkPathIsValid(path: IntArray, row: Int) : Boolean &#123;    if (row &gt;= 1) &#123;        val cur = path[row]        for (k in row - 1 downTo 0) &#123;            if (cur == path[k]) &#123;                return false            &#125;            if ((path[k] + row - k) == cur || (path[k] - (row - k)) == cur) &#123;                return false            &#125;        &#125;    &#125;    return true&#125;fun totalNQueens(n: Int): Int &#123;    solveNQueensRecur(n, 0, IntArray(n)&#123;-1&#125;)    return ret2&#125;</code></pre><h4 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h4><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><pre><code class="kotlin">fun maxSubArray(nums: IntArray): Int &#123;    var subMax = nums[0]     var max = subMax    for (i in 1 .. nums.size - 1) &#123;         if (subMax &lt; 0) &#123;            subMax = nums[i]        &#125; else &#123;            subMax += nums[i]        &#125;        max = Math.max(max, subMax)    &#125;    return max&#125;</code></pre><p>Note: 动态规划， 状态压缩，只取最大的那个</p><h4 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a>54. Spiral Matrix</h4><p>Given an m x n matrix, return all elements of the matrix in spiral order.</p><pre><code class="kotlin">fun spiralOrder(matrix: Array&lt;IntArray&gt;): List&lt;Int&gt; &#123;    val ret = mutableListOf&lt;Int&gt;()    var left = 0    var top = 0    var right = matrix[0].size - 1    var bottom = matrix.size - 1    while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;        for (i in left .. right) &#123;            ret.add(matrix[top][i])        &#125;        for (i in top + 1 .. bottom) &#123;            ret.add(matrix[i][right])        &#125;        if (bottom  &gt; top &amp;&amp; right &gt; left) &#123;            for (i in right - 1 downTo left) &#123;                ret.add(matrix[bottom][i])            &#125;            for (i in bottom - 1 downTo top + 1) &#123;                ret.add(matrix[i][left])            &#125;        &#125;        left++        top++        bottom--        right--    &#125;    return ret&#125;</code></pre><p>Note: bottom  &gt; top &amp;&amp; right &gt; left  不能转向的判断</p><h4 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. Jump Game</h4><p>[Greedy]</p><p>Given an array of non-negative integers nums, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><pre><code class="kotlin">fun canJump(nums: IntArray): Boolean &#123;    if (nums.size == 1) &#123;        return true    &#125;    var barrier = 0    var max = nums[0]    for (i in 0 .. nums.size - 2) &#123;        max = Math.max(max, i + nums[i])        if (barrier == i) &#123;            if (barrier &gt;= max) &#123;                return false            &#125;            barrier = max        &#125;        if (max &gt;= nums.size - 1) &#123;            return true        &#125;    &#125;    return false&#125;</code></pre><h4 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h4><p>Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p><pre><code class="kotlin">fun merge(intervals: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; &#123;//        for (i in 0 .. intervals.size - 2) &#123;//            for (j in i + 1 .. intervals.size - 1) &#123;//                if (intervals[i][0] &gt; intervals[j][0]) &#123;//                    val tmp = intervals[i]//                    intervals[i] = intervals[j]//                    intervals[j] = tmp//                &#125;//            &#125;//        &#125;    val ret = mutableListOf&lt;IntArray&gt;()    fun quickSort(arr: Array&lt;IntArray&gt;, start: Int, end: Int) &#123;        fun swap(arr: Array&lt;IntArray&gt;, i: Int, j: Int) &#123;            val tmp = arr[i]            arr[i] = arr[j]            arr[j] = tmp        &#125;        if (start &gt;= end) &#123;            return        &#125;        val mid = (start + end) / 2        swap(arr, mid, start)        val pivot = arr[start]        var last = start        var i = start + 1        while (i &lt;= end) &#123;            if (arr[i][0] &lt; pivot[0]) &#123;                swap(arr, i, ++last)            &#125;            i++        &#125;        swap(arr, last, start)        quickSort(arr, start, last - 1)        quickSort(arr, last + 1, end)    &#125;    quickSort(intervals, 0, intervals.size - 1)    ret.add(intervals[0])    for (i in 1 .. intervals.size - 1) &#123;        if (ret[ret.size - 1][1] &gt;= intervals[i][0]) &#123;            ret[ret.size - 1][0] = Math.min(intervals[i][0], ret[ret.size - 1][0])            ret[ret.size - 1][1] = Math.max(intervals[i][1], ret[ret.size - 1][1])        &#125; else &#123;            ret.add(intervals[i])        &#125;    &#125;    return ret.toTypedArray()&#125;</code></pre><p>Note： 快排快慢指针的运用</p><h4 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a>57. Insert Interval</h4><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><pre><code class="kotlin">fun insert(intervals: Array&lt;IntArray&gt;, newInterval: IntArray): Array&lt;IntArray&gt; &#123;    val newIntervalList = intervals.toMutableList()    var i = 0    while (i &lt;= newIntervalList.size - 1) &#123;        if (newIntervalList[i][0] &gt; newInterval[0]) &#123;            newIntervalList.add(i, newInterval)            break        &#125;        i++    &#125;    if (newIntervalList.size == intervals.size) &#123;        newIntervalList.add(newInterval)    &#125;    val ret = mutableListOf&lt;IntArray&gt;()    ret.add(newIntervalList[0])    for (j in 1 .. newIntervalList.size - 1) &#123;        if (ret[ret.size - 1][1] &gt;= newIntervalList[j][0]) &#123;            ret[ret.size - 1][0] = Math.min(newIntervalList[j][0], ret[ret.size - 1][0])            ret[ret.size - 1][1] = Math.max(newIntervalList[j][1], ret[ret.size - 1][1])        &#125; else &#123;            ret.add(newIntervalList[j])        &#125;    &#125;    return ret.toTypedArray()&#125;</code></pre><h4 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. Length of Last Word</h4><p>Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0.</p><p>A word is a maximal substring consisting of non-space characters only.</p><pre><code class="kotlin">fun lengthOfLastWord(s: String): Int &#123;    var ret = 0    var end = s.length - 1    //trim tail    while (end &gt;= 0) &#123;        if (s[end] != &#39; &#39;) &#123;            break        &#125; else &#123;            end--        &#125;    &#125;    while (end &gt;= 0) &#123;        if (s[end] == &#39; &#39;) &#123;            break        &#125; else &#123;            end--            ret++        &#125;    &#125;    return ret&#125;</code></pre><h4 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a>59. Spiral Matrix II</h4><p>Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.</p><pre><code class="kotlin">fun generateMatrix(n: Int): Array&lt;IntArray&gt; &#123;    val ret = Array(n) &#123; IntArray(n) &#125;    var x = 1    var left = 0    var top = 0    var right = n - 1    var bottom = n - 1    while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;        for (i in left .. right) &#123;            ret[top][i] = x++        &#125;        for (i in top + 1 .. bottom) &#123;            ret[i][right] = x++        &#125;        for (i in right - 1 downTo left) &#123;            ret[bottom][i] = x++        &#125;        for (i in bottom - 1 downTo top + 1) &#123;            ret[i][left] = x++        &#125;        top++        left++        right--        bottom--    &#125;    return ret&#125;</code></pre><h4 id="60-Permutation-Sequence"><a href="#60-Permutation-Sequence" class="headerlink" title="60. Permutation Sequence"></a>60. Permutation Sequence</h4><p>The set [1, 2, 3, …, n] contains a total of n! unique permutations.</p><p>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</p><pre><code>&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;</code></pre><p>Given n and k, return the kth permutation sequence.</p><pre><code class="kotlin">fun getPermutation(n: Int, k: Int): String &#123;  val exponents = IntArray(n)  exponents[0] = 1  for (i in 1 .. n - 1) &#123;    exponents[i] = i * exponents[i - 1]  &#125;  val ret = StringBuilder()  val readySelectArr = (1..n).toMutableList()  var k = k - 1  for (i in n downTo 1) &#123;    val cur = k / exponents[i - 1]    ret.append(readySelectArr.removeAt(cur))    k -= cur * exponents[i - 1]  &#125;  return ret.toString()&#125;</code></pre><p>Note: 注意数组下标从0开始，即求k-1个</p><h4 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. Rotate List</h4><p>Given the head of a linked list, rotate the list to the right by k places.</p><pre><code class="kotlin">fun rotateRight(head: ListNode?, k: Int): ListNode? &#123;    if (head?.next == null) &#123;        return head    &#125;    var size = 0    var tmp = head    while (tmp != null) &#123;        tmp = tmp.next        size++    &#125;    val dummyHead = ListNode(0)    dummyHead.next = head    var n = k % size    while (n &gt; 0) &#123;        var cur = dummyHead.next        var curNext = cur?.next        while (curNext?.next != null) &#123;            cur = cur?.next            curNext = curNext.next        &#125;        cur?.next = null        curNext?.next = dummyHead.next        dummyHead.next = curNext        n--    &#125;    return dummyHead.next&#125;//way 2:fun rotateRight(head: ListNode?, k: Int): ListNode? &#123;    if (head?.next == null) &#123;        return head    &#125;    var size = 1    var iter = head    while (iter?.next != null) &#123;        iter = iter.next        size++    &#125;    iter?.next = head// tail    var pre = size - k % size    iter = head    while (pre &gt; 1) &#123;        iter = iter?.next        pre --    &#125;    val ret = iter?.next    iter?.next = null    return ret&#125;</code></pre><p>Note: 利用求余数的方法得到有效的的旋转次数。 way 2 闭合环遍历断开</p><h4 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h4><p>[Dynamic Programing]</p><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><pre><code class="kotlin">fun uniquePaths(m: Int, n: Int): Int &#123;    val dp = IntArray(n)    for (i in 0..n - 1) &#123;        dp[i] = 1    &#125;    for (i in 1..m - 1) &#123;        for (j in 1..n - 1) &#123;            dp[j] = dp[j - 1] + dp[j]        &#125;    &#125;    return dp[n - 1]&#125;</code></pre><p>Note: 回溯，递归超时;  滚动数组优化空间</p><h4 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a>63. Unique Paths II</h4><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p>An obstacle and space is marked as 1 and 0 respectively in the grid.</p><pre><code class="kotlin">fun uniquePathsWithObstacles(obstacleGrid: Array&lt;IntArray&gt;): Int &#123;    val m = obstacleGrid.size    val n = obstacleGrid[0].size    if (obstacleGrid[m - 1][n - 1] == 1) &#123;        return 0    &#125;    val dp = IntArray(n) &#123; 0 &#125;    for (i in 0..n - 1) &#123;        if (obstacleGrid[0][i] == 1) &#123;            break        &#125;        dp[i] = 1    &#125;    for (i in 1 .. m - 1) &#123;        for (j in 0 .. n - 1) &#123;            if (j == 0) &#123;                if (obstacleGrid[i][0] == 1) &#123;                    dp[j] = 0                &#125;            &#125; else &#123;                val part1 = if(obstacleGrid[i][j] == 1) 0 else dp[j]                val part2 = if(obstacleGrid[i][j] == 1) 0 else dp[j - 1]                dp[j] = part1 + part2            &#125;        &#125;    &#125;    return dp[n - 1]&#125;</code></pre><p>Note：状态压缩</p><h4 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h4><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p><p>Note: You can only move either down or right at any point in time.</p><pre><code class="kotlin">fun minPathSum(grid: Array&lt;IntArray&gt;): Int &#123;    val m = grid.size    val n = grid[0].size    val dp = IntArray(n)    dp[0] = grid[0][0]    for (i in 1..n - 1) &#123;        dp[i] = grid[0][i] + dp[i - 1]    &#125;    for (i in 1..m - 1) &#123;        for (j in 0..n - 1) &#123;            if (j == 0) &#123;                dp[j] = grid[i][j] + dp[j]            &#125; else &#123;                dp[j] = grid[i][j] + Math.min(dp[j - 1], dp[j])            &#125;        &#125;    &#125;    return dp[n - 1]&#125;</code></pre><h3 id="65-Valid-Number"><a href="#65-Valid-Number" class="headerlink" title="65. Valid Number"></a>65. Valid Number</h3><p>[String | FSM]</p><p>A valid number can be split up into these components (in order):</p><pre><code>A decimal number or an integer.(Optional) An &#39;e&#39; or &#39;E&#39;, followed by an integer.</code></pre><p>A decimal number can be split up into these components (in order):</p><pre><code>(Optional) A sign character (either &#39;+&#39; or &#39;-&#39;).One of the following formats:    At least one digit, followed by a dot &#39;.&#39;.    At least one digit, followed by a dot &#39;.&#39;, followed by at least one digit.    A dot &#39;.&#39;, followed by at least one digit.</code></pre><p>An integer can be split up into these components (in order):</p><pre><code>(Optional) A sign character (either &#39;+&#39; or &#39;-&#39;).At least one digit.</code></pre><p>For example, all the following are valid numbers: [“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”], while the following are not valid numbers: [“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”].</p><p>Given a string s, return true if s is a valid number.</p><pre><code class="kotlin">data class ContextData(var decimal: Boolean, var exponential: Boolean)enum class StateMachine &#123;    INVALID &#123;        override fun next(c: Char, context: ContextData): StateMachine &#123;            TODO(&quot;Not yet implemented&quot;)        &#125;    &#125;,    START &#123;        override fun next(c: Char, context: ContextData): StateMachine &#123;            if ((c == &#39;+&#39; || c == &#39;-&#39;)) &#123;                return INTEGER            &#125; else if (c.isDigit()) &#123;                context.decimal = true                return INTEGER            &#125; else if (c == &#39;.&#39;) &#123;                return FRACTION            &#125; else &#123;                return INVALID            &#125;        &#125;    &#125;,    INTEGER &#123;        override fun next(c: Char, context: ContextData): StateMachine &#123;            if (c.isDigit()) &#123;                context.decimal = true                return this            &#125; else if (c == &#39;.&#39;) &#123;                return FRACTION            &#125; else if (c == &#39;e&#39; || c == &#39;E&#39;) &#123;                context.exponential = false                return E_SIGN            &#125; else &#123;                return INVALID            &#125;        &#125;    &#125;,    FRACTION &#123;        override fun next(c: Char, context: ContextData): StateMachine &#123;            if (c.isDigit()) &#123;                context.decimal = true                return this            &#125; else if (c == &#39;e&#39; || c == &#39;E&#39;) &#123;                context.exponential = false                return E_SIGN            &#125; else &#123;                return INVALID            &#125;        &#125;    &#125;,    E_SIGN &#123;        override fun next(c: Char, context: ContextData): StateMachine &#123;            if (!context.decimal) &#123;                return INVALID            &#125;            if (c == &#39;+&#39; || c == &#39;-&#39;) &#123;                context.exponential = false                return E_INTEGER            &#125; else if (c.isDigit())&#123;                context.exponential = true                return E_INTEGER            &#125; else &#123;                return INVALID            &#125;        &#125;    &#125;,    E_INTEGER &#123;        override fun next(c: Char, context: ContextData): StateMachine &#123;            if (!context.decimal) &#123;                return INVALID            &#125; else if (c.isDigit()) &#123;                context.exponential = true                return this            &#125; else &#123;                return INVALID            &#125;        &#125;    &#125;;    abstract fun next(c: Char, context: ContextData): StateMachine&#125;fun isNumber(s: String): Boolean &#123;    val context = ContextData(false, true)    var stateMachine = StateMachine.START    for (c in s) &#123;        stateMachine = stateMachine.next(c, context)        if (stateMachine == StateMachine.INVALID) &#123;            return false        &#125;    &#125;    return context.decimal &amp;&amp; context.exponential&#125;</code></pre><h4 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a>66. Plus One</h4><p>[Array]</p><p>Given a non-empty array of decimal digits representing a non-negative integer, increment one to the integer.</p><p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.</p><p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><pre><code class="kotlin">fun plusOne(digits: IntArray): IntArray &#123;    var carry = 1    for (i in digits.size - 1 downTo 0) &#123;        if (carry == 0) &#123;            break        &#125;        val add = digits[i] + carry        digits[i] = add % 10        carry = add / 10    &#125;    if (carry == 1) &#123;        return IntArray(digits.size + 1)&#123;            if (it == 0) &#123;                1            &#125; else &#123;                0            &#125;        &#125;    &#125; else &#123;        return digits    &#125;&#125;</code></pre><h4 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67. Add Binary"></a>67. Add Binary</h4><p>Given two binary strings a and b, return their sum as a binary string.</p><pre><code class="kotlin">fun addBinary(a: String, b: String): String &#123;    val ret = StringBuilder()    var ia = a.length - 1    var ib = b.length - 1    var carry = &#39;0&#39;    while (true) &#123;        val ca = if (ia &gt;= 0) a[ia--] else &#39;0&#39;        val cb = if (ib &gt;= 0) b[ib--] else &#39;0&#39;        if (ca == cb) &#123;            if (ca == &#39;0&#39;) &#123;                ret.append(carry)                carry = &#39;0&#39;            &#125; else &#123;                ret.append(carry)                carry = &#39;1&#39;            &#125;        &#125; else &#123;            if (carry == &#39;1&#39;) &#123;                ret.append(&#39;0&#39;)            &#125; else &#123;                ret.append(&#39;1&#39;)            &#125;        &#125;        if (ia &lt; 0 &amp;&amp; ib &lt; 0) &#123;            if (carry == &#39;1&#39;) &#123;                ret.append(&#39;1&#39;)            &#125;            break        &#125;    &#125;    return ret.reverse().toString()&#125;</code></pre><h4 id="68-Text-Justification"><a href="#68-Text-Justification" class="headerlink" title="68. Text Justification"></a>68. Text Justification</h4><p>Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.</p><p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly maxWidth characters.</p><p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p><p>For the last line of text, it should be left justified and no extra space is inserted between words.</p><p>Note:</p><ul><li>A word is defined as a character sequence consisting of non-space characters only.</li><li>Each word’s length is guaranteed to be greater than 0 and not exceed maxWidth.</li><li>The input array words contains at least one word.</li></ul><pre><code class="kotlin">fun fullJustify(words: Array&lt;String&gt;, maxWidth: Int): List&lt;String&gt; &#123;    fun appendBlankChars(builder: StringBuilder, n: Int) &#123;        for (i in 1..n) &#123;            builder.append(&quot; &quot;)        &#125;    &#125;    fun processLine(startIndex: Int, endIndex: Int): String &#123;        var totalBlankLen = 0        for (i in startIndex..endIndex) &#123;            totalBlankLen += words[i].length        &#125;        totalBlankLen = maxWidth - totalBlankLen        val intervals = endIndex - startIndex        val lineStr = StringBuilder()        if (intervals == 0) &#123;            lineStr.append(words[startIndex])            appendBlankChars(lineStr, maxWidth - lineStr.length)        &#125; else &#123;            val blanksOfInterval = IntArray(intervals)            var i = 0            while (totalBlankLen &gt; 0) &#123;                blanksOfInterval[i]++                i++                if (i == blanksOfInterval.size) &#123;                    i = 0                &#125;                totalBlankLen--            &#125;            var j = 0            for (i in startIndex..endIndex) &#123;                lineStr.append(words[i])                if (i != endIndex) &#123;                    appendBlankChars(lineStr, blanksOfInterval[j++])                &#125;            &#125;        &#125;        return lineStr.toString()    &#125;    val ret = mutableListOf&lt;String&gt;()    var curLineWidth = 0    var startWordIndex = 0    var endWordIndex = 0    for (wordIndex in 0..words.size - 1) &#123;        curLineWidth = curLineWidth + words[wordIndex].length        if (curLineWidth == maxWidth) &#123;            endWordIndex = wordIndex            ret.add(processLine(startWordIndex, endWordIndex))            curLineWidth = 0            startWordIndex = endWordIndex + 1        &#125; else if (curLineWidth &lt; maxWidth) &#123;            curLineWidth++            continue        &#125; else &#123; //curLineWidth &gt; maxWidth            endWordIndex = wordIndex - 1            ret.add(processLine(startWordIndex, endWordIndex))            startWordIndex = wordIndex            curLineWidth = words[startWordIndex].length + 1        &#125;    &#125;    if (startWordIndex &lt;= words.size - 1) &#123;        val lineStr = StringBuilder()        for (i in startWordIndex..words.size - 1) &#123;            lineStr.append(words[i])            if (i != words.size - 1) &#123;                lineStr.append(&quot; &quot;)            &#125;        &#125;        appendBlankChars(lineStr, maxWidth - lineStr.length)        ret.add(lineStr.toString())    &#125;    return ret&#125;</code></pre><h4 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a>69. Sqrt(x)</h4><p>Given a non-negative integer x, compute and return the square root of x.</p><p>Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.</p><pre><code class="kotlin">fun mySqrt(x: Int): Int &#123;    var startVal = 1    var endVal = x    while (startVal &lt;= endVal) &#123;        val mid = startVal + (endVal - startVal) / 2        if (mid &gt; Int.MAX_VALUE / mid) &#123;            endVal = mid - 1            continue        &#125;        val v = mid * mid        if (v == x) &#123;            return mid        &#125; else if (v &gt; x) &#123;            endVal = mid - 1        &#125; else &#123;            startVal = mid + 1        &#125;    &#125;    return endVal&#125;</code></pre><p>Note: 防止溢出操作</p><h4 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h4><p>[Dynamic Progroming]</p><p>You are climbing a staircase. It takes n steps to reach the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><pre><code class="kotlin">fun climbStairs(n: Int): Int &#123;  var first = 1  var second = 1  for (i in 2 .. n) &#123;    val tmp = first    first += second    second = tmp  &#125;  return first&#125;</code></pre><h4 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a>71. Simplify Path</h4><p>Given a string path, which is an absolute path (starting with a slash ‘/‘) to a file or directory in a Unix-style file system, convert it to the simplified canonical path.</p><p>In a Unix-style file system, a period ‘.’ refers to the current directory, a double period ‘..’ refers to the directory up a level, and any multiple consecutive slashes (i.e. ‘//‘) are treated as a single slash ‘/‘. For this problem, any other format of periods such as ‘…’ are treated as file/directory names.</p><p>The canonical path should have the following format:</p><ul><li>The path starts with a single slash ‘/‘.</li><li>Any two directories are separated by a single slash ‘/‘.</li><li>The path does not end with a trailing ‘/‘.</li><li>The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period ‘.’ or double period ‘..’)</li></ul><p>Return the simplified canonical path.</p><pre><code class="kotlin">enum class PathState &#123;  INIT,  SlashStart,  DotStart,  DotEnd,  CHAR&#125;fun simplifyPath(path: String): String &#123;  var curSlashStart = 0  var state = PathState.INIT  val stack = LinkedList&lt;String&gt;()  for ((index, c) in path.withIndex()) &#123;    if (c == &#39;/&#39;) &#123;      if (state == PathState.INIT) &#123;        curSlashStart = index        state = PathState.SlashStart      &#125; else if (state == PathState.DotStart) &#123;        state = PathState.SlashStart        curSlashStart = index      &#125; else if (state == PathState.DotEnd) &#123;        if (!stack.isEmpty()) &#123;          stack.pop()        &#125;        state = PathState.SlashStart        curSlashStart = index      &#125; else if (state == PathState.CHAR) &#123;        stack.push(path.substring(curSlashStart + 1..index - 1))        curSlashStart = index        state = PathState.SlashStart      &#125; else if (state == PathState.SlashStart) &#123;        curSlashStart = index      &#125;    &#125; else if (c == &#39;.&#39;) &#123;      if (state == PathState.SlashStart) &#123;        state = PathState.DotStart      &#125; else if (state == PathState.DotStart) &#123;        state = PathState.DotEnd      &#125; else if (state == PathState.DotEnd) &#123;        state = PathState.CHAR      &#125;    &#125; else &#123;      state = PathState.CHAR    &#125;  &#125;  if (state == PathState.DotEnd) &#123;    if (stack.isNotEmpty()) &#123;      stack.pop()    &#125;  &#125; else if (state == PathState.CHAR) &#123;    stack.push(path.substring(curSlashStart + 1..path.length - 1))  &#125;  val ret = StringBuilder()  ret.append(&quot;/&quot;)  while (stack.isNotEmpty()) &#123;    ret.append(stack.removeLast())    ret.append(&quot;/&quot;)  &#125;  if (ret.length &gt; 1) &#123;    ret.deleteCharAt(ret.length - 1)  &#125;  return ret.toString()&#125;</code></pre><h4 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h4><p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.</p><p>You have the following three operations permitted on a word:</p><ul><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ul><pre><code class="kotlin">fun minDistance(word1: String, word2: String): Int &#123;    val A = word1.length    val B = word2.length    if (A * B == 0) &#123;        return A + B    &#125;    val dp = Array(A + 1) &#123; IntArray(B + 1) &#125;    for (i in 0 .. A) &#123;        dp[i][0] = i    &#125;    for (i in 0 .. B) &#123;        dp[0][i] = i    &#125;    for (i in 1 .. A) &#123;        for (j in 1 ..B) &#123;            dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)            if (word1[i - 1] == word2[j - 1]) &#123;                dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i][j])            &#125; else &#123;                dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, dp[i][j])            &#125;        &#125;    &#125;    return dp[A][B]&#125;</code></pre><h4 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73. Set Matrix Zeroes"></a>73. Set Matrix Zeroes</h4><p>Given an m x n matrix. If an element is 0, set its entire row and column to 0. Do it in-place.</p><p>Follow up:</p><ul><li>A straight forward solution using O(mn) space is probably a bad idea.</li><li>A simple improvement uses O(m + n) space, but still not the best solution.</li><li>Could you devise a constant space solution? </li></ul><pre><code class="kotlin">fun setZeroes(matrix: Array&lt;IntArray&gt;): Unit &#123;    val m = matrix.size    val n = matrix[0].size    var row0Zero = false    var col0Zero = false    for (i in 0..m - 1) &#123;        if (matrix[i][0] == 0) &#123;            col0Zero = true            break        &#125;    &#125;    for (i in 0..n - 1) &#123;        if (matrix[0][i] == 0) &#123;            row0Zero = true            break        &#125;    &#125;    for (i in 1..m - 1) &#123;        for (j in 1..n - 1) &#123;            if (matrix[i][j] == 0) &#123;                matrix[0][j] = 0                matrix[i][0] = 0            &#125;        &#125;    &#125;    for (i in 1..m - 1) &#123;        for (j in 1..n - 1) &#123;            if (matrix[0][j] == 0 || matrix[i][0] == 0) &#123;                matrix[i][j] = 0            &#125;        &#125;    &#125;    if (col0Zero) &#123;        for (i in 0..m - 1) &#123;            matrix[i][0] = 0        &#125;    &#125;    if (row0Zero) &#123;        for (i in 0..n - 1) &#123;            matrix[0][i] = 0        &#125;    &#125;&#125;</code></pre><p>Note: O(1)空间</p><h4 id="74-Search-a-2D-Matrix"><a href="#74-Search-a-2D-Matrix" class="headerlink" title="74. Search a 2D Matrix"></a>74. Search a 2D Matrix</h4><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted from left to right.</li><li>The first integer of each row is greater than the last integer of the previous row.</li></ul><pre><code class="kotlin">fun searchMatrix(matrix: Array&lt;IntArray&gt;, target: Int): Boolean &#123;    val m = matrix.size    val n = matrix[0].size    var start = 0    var end = m * n - 1    while (start &lt;= end) &#123;        val mid = (start + end) / 2        val midVal = matrix[mid / n][mid % n]        if (target == midVal) &#123;            return true        &#125; else if (target &gt; midVal) &#123;            start = mid + 1        &#125; else &#123;            end = mid - 1        &#125;    &#125;    return false&#125;</code></pre><h5 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a>75. Sort Colors</h5><p>Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p><p>We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.</p><pre><code class="kotlin">//counter sortfun sortColors(nums: IntArray): Unit &#123;    val counter = IntArray(3)    for (v in nums) &#123;        counter[v]++    &#125;    var i = 0    for ((index, c) in counter.withIndex()) &#123;        for (ci in 1..c) &#123;            nums[i++] = index        &#125;    &#125;&#125;//two pointerfun sortColors(nums: IntArray): Unit &#123;    fun swap(i: Int, j: Int) &#123;        val tmp = nums[i]        nums[i] = nums[j]        nums[j] = tmp    &#125;    var left = 0    var right = nums.size - 1    var i = 0    while (i &lt;= right) &#123;        if (nums[i] == 0) &#123;            swap(i, left)            left++        &#125; else if (nums[i] == 2) &#123;            swap(i, right)            right--            if (nums[i] != 1) &#123;                i--            &#125;        &#125;        i++    &#125;&#125;</code></pre><h4 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h4><p>[Sliding Window | Hash Table | Two Pointers]</p><p>Given two strings s and t, return the minimum window in s which will contain all the characters in t. If there is no such window in s that covers all characters in t, return the empty string “”.</p><p>Note that If there is such a window, it is guaranteed that there will always be only one unique minimum window in s.</p><pre><code class="kotlin">fun minWindow(s: String, t: String): String &#123;    val tMap = mutableMapOf&lt;Char, Int&gt;()    for (c in t) &#123;        tMap[c] = tMap.getOrDefault(c, 0) + 1    &#125;    var found =  false    var minStartIndex = 0    var minEndIndex = s.length - 1    var startIndex = 0    var endIndex = 0    var count = t.length    while (endIndex &lt; s.length) &#123;        val endEntryCnt = tMap.get(s[endIndex])        if (endEntryCnt != null) &#123;            tMap.put(s[endIndex], endEntryCnt - 1)            if (endEntryCnt &gt; 0) &#123;                count--            &#125;        &#125;        while (count == 0) &#123;            found = true            if (endIndex - startIndex &lt; minEndIndex - minStartIndex) &#123;                minStartIndex = startIndex                minEndIndex = endIndex            &#125;            val startEntryCnt = tMap.get(s[startIndex])            if (startEntryCnt != null) &#123;                tMap.put(s[startIndex], startEntryCnt + 1)                if (startEntryCnt + 1 &gt; 0) &#123;                    count++                &#125;            &#125;            startIndex++        &#125;        endIndex++    &#125;    return if (found) s.substring(minStartIndex..minEndIndex) else &quot;&quot;&#125;</code></pre><p>Note: 注意t会有重复的子串</p><h4 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h4><p>Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].</p><p>You may return the answer in any order.</p><pre><code class="kotlin">val ret8 = mutableListOf&lt;List&lt;Int&gt;&gt;()fun combine(n: Int, k: Int): List&lt;List&lt;Int&gt;&gt; &#123;    combineRecur(n, 1, k, mutableListOf())    return ret8&#125;fun combineRecur(n: Int, start:Int, k: Int, path: MutableList&lt;Int&gt;)&#123;    if (k == 0) &#123;        ret8.add(ArrayList(path))        return    &#125;    for (i in start..n) &#123;        path.add(i)        combineRecur(n, i + 1, k - 1, path)        path.removeAt(path.size - 1)    &#125;&#125;</code></pre><h4 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h4><p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><pre><code class="kotlin">val ret10 = mutableListOf&lt;List&lt;Int&gt;&gt;()fun subsets(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;    subsetsRecur(nums, 0, mutableListOf())    return ret10&#125;fun subsetsRecur(nums: IntArray, start: Int, path: MutableList&lt;Int&gt;) &#123;    ret10.add(ArrayList(path))    if (start == nums.size || path.size == nums.size) &#123;        return    &#125;    for (i in start..nums.size - 1) &#123;        path.add(nums[i])        subsetsRecur(nums, i + 1, path)        path.removeAt(path.size - 1)    &#125;&#125;</code></pre><h4 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h4><p>Given an m x n grid of characters board and a string word, return true if word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><pre><code class="kotlin">fun exist(board: Array&lt;CharArray&gt;, word: String): Boolean &#123;    val visited = Array(board.size)&#123;BooleanArray(board[0].size)&#125;    for (i in 0..board.size - 1) &#123;        for (j in 0..board[0].size - 1) &#123;            if (existRecur(i, j, board, word, 0, visited)) &#123;                return true            &#125;        &#125;    &#125;    return false&#125;fun existRecur(i: Int, j:Int, board: Array&lt;CharArray&gt;, word: String, wordCur: Int, visited: Array&lt;BooleanArray&gt;): Boolean &#123;    if (i &lt; 0 || i &gt; board.size - 1 || j &lt; 0 || j &gt; board[0].size - 1 || visited[i][j] ||board[i][j] != word[wordCur]) &#123;        return false    &#125;    visited[i][j] = true    if (wordCur == word.length - 1) &#123;        return true    &#125;    if (existRecur(i, j - 1, board, word, wordCur + 1, visited)) &#123;        return true    &#125;    if (existRecur(i, j + 1, board, word, wordCur + 1, visited)) &#123;        return true    &#125;    if (existRecur(i - 1, j, board, word, wordCur + 1, visited)) &#123;        return true    &#125;    if (existRecur(i + 1, j, board, word, wordCur + 1, visited)) &#123;        return true    &#125;    visited[i][j] = false    return false&#125;</code></pre><h4 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80. Remove Duplicates from Sorted Array II"></a>80. Remove Duplicates from Sorted Array II</h4><p>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.</p><p>Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory.</p><p>Clarification:</p><p>Confused why the returned value is an integer, but your answer is an array?</p><p>Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller.</p><p>Internally you can think of this:</p><p>// nums is passed in by reference. (i.e., without making a copy)<br>int len = removeDuplicates(nums);</p><p>// any modification to nums in your function would be known by the caller.<br>// using the length returned by your function, it prints the first len elements.<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p><pre><code class="kotlin">fun removeDuplicates(nums: IntArray): Int &#123;    if (nums.size &lt;= 2) &#123;        return 2    &#125;    nums.sort()    var slow = 2    for (fast in 2..nums.size - 1) &#123;        if (nums[slow - 2] != nums[fast]) &#123;            nums[slow] = nums[fast]            slow++        &#125;    &#125;    return slow&#125;</code></pre><p>Note: 移动慢指针条件； 和慢指针前两个元素对比</p><h4 id="81-Search-in-Rotated-Sorted-Array-II"><a href="#81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="81. Search in Rotated Sorted Array II"></a>81. Search in Rotated Sorted Array II</h4><p> There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).</p><p>Before being passed to your function, nums is rotated at an unknown pivot index k (0 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].</p><p>Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.</p><pre><code class="kotlin">fun search(nums: IntArray, target: Int): Boolean &#123;    var start = 0    var end = nums.size - 1    while (start &lt;= end) &#123;        val mid = (start + end) / 2        if (nums[mid] == target) &#123;            return true        &#125; else &#123;            if (nums[mid] == nums[start] &amp;&amp; nums[mid] == nums[end]) &#123;                start++                end--            &#125; else  if (nums[mid] &lt;= nums[end]) &#123;//right sorted                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) &#123;                    start = mid + 1                &#125; else &#123;                    end = mid - 1                &#125;            &#125; else if (nums[mid] &gt;= nums[start]) &#123;//left sorted                if (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;                    end = mid - 1                &#125; else &#123;                    start = mid + 1                &#125;            &#125;        &#125;    &#125;    return false&#125;</code></pre><h4 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82. Remove Duplicates from Sorted List II"></a>82. Remove Duplicates from Sorted List II</h4><p>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.</p><pre><code class="kotlin">fun deleteDuplicates(head: ListNode?): ListNode? &#123;    val dummyNode = ListNode(0, head)    var pre = dummyNode    var cur = head    while (cur != null) &#123;        if (cur.`val` == cur.next?.`val`) &#123;            var tmp = cur            while (tmp != null &amp;&amp; tmp.`val` == tmp.next?.`val`) &#123;                tmp = tmp.next            &#125;            cur = tmp?.next            pre.next = cur        &#125; else &#123;            pre = cur            cur = cur.next        &#125;    &#125;    return dummyNode.next&#125;</code></pre><h4 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a>83. Remove Duplicates from Sorted List</h4><p>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.</p><pre><code class="kotlin">fun deleteDuplicates(head: ListNode?): ListNode? &#123;    var cur = head    while (cur?.next != null) &#123;        if (cur.`val` == cur.next?.`val`) &#123;            cur.next = cur.next?.next        &#125; else &#123;            cur = cur.next        &#125;    &#125;    return head&#125;</code></pre><p>!!!先跳过Hard….</p><h4 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a>86. Partition List</h4><p>Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><pre><code class="kotlin">fun partition(head: ListNode?, x: Int): ListNode? &#123;    val dummyHeadLeft = ListNode(0)    var curLeft = dummyHeadLeft    val dummyHeadRight = ListNode(0)    var curRight = dummyHeadRight    var cur = head    while (cur != null) &#123;        if (cur.`val` &lt; x) &#123;            curLeft.next = cur            curLeft = cur        &#125; else&#123;            curRight.next = cur            curRight = cur        &#125;        cur = cur.next    &#125;    //merge two list    curRight.next = null    curLeft.next = dummyHeadRight.next    return dummyHeadLeft.next&#125;</code></pre><p>Note: 注意出现循环链表</p><h4 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a>88. Merge Sorted Array</h4><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p>The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has a size equal to m + n such that it has enough space to hold additional elements from nums2.</p><pre><code class="kotlin">fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit &#123;    if (n &lt;=0) &#123;        return    &#125;    var cur = nums1.size - 1    var p1 = m - 1    var p2 = n - 1    while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) &#123;        if (nums1[p1] &gt; nums2[p2]) &#123;            nums1[cur--] = nums1[p1--]        &#125; else &#123;            nums1[cur--] = nums2[p2--]        &#125;    &#125;    while (p2 &gt;= 0) &#123;        nums1[cur--] = nums2[p2--]    &#125;&#125;</code></pre><h4 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89. Gray Code"></a>89. Gray Code</h4><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p><p>Given an integer n representing the total number of bits in the code, return any sequence of gray code.</p><p>A gray code sequence must begin with 0.</p><pre><code class="kotlin">val grayCodeRet = mutableListOf&lt;Int&gt;()fun grayCode(n: Int): List&lt;Int&gt; &#123;    val path = StringBuilder()    grayCodeRecur(0, n, true, path)    path.deleteCharAt(path.length - 1)    grayCodeRecur(1, n, false, path)    //println(grayCodeRet)    return grayCodeRet&#125;fun grayCodeRecur(cur: Int, n: Int, left: Boolean, path: StringBuilder) &#123;    path.append(cur)    if (path.length &gt;= n) &#123;        grayCodeRet.add(Integer.parseInt(path.toString(), 2))        return    &#125;    if (left) &#123;        grayCodeRecur(0, n, true, path)        path.deleteCharAt(path.length - 1)        grayCodeRecur(1, n, false, path)        path.deleteCharAt(path.length - 1)    &#125; else &#123;        grayCodeRecur(1, n, true, path)        path.deleteCharAt(path.length - 1)        grayCodeRecur(0, n, false, path)        path.deleteCharAt(path.length - 1)    &#125;&#125;</code></pre><h4 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h4><p>Given an integer array nums that may contain duplicates, return all possible subsets (the power set).</p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><pre><code class="kotlin">val ret11 = mutableListOf&lt;List&lt;Int&gt;&gt;()fun subsetsWithDup(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;    nums.sort()    subsetsWithDupRecur(nums, 0, mutableListOf())    return ret11&#125;fun subsetsWithDupRecur(nums: IntArray, start: Int, path: MutableList&lt;Int&gt;) &#123;    ret11.add(ArrayList(path))    if (start &gt;= nums.size) &#123;        return    &#125;    for (i in start..nums.size - 1) &#123;        if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123;            continue        &#125;        path.add(nums[i])        subsetsWithDupRecur(nums, i + 1, path)        path.removeAt(path.size - 1)    &#125;&#125;</code></pre><h4 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h4><p>A message containing letters from A-Z can be encoded into numbers using the following mapping:</p><p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”</p><p>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into:</p><pre><code>&quot;AAJF&quot; with the grouping (1 1 10 6)&quot;KJF&quot; with the grouping (11 10 6)</code></pre><p>Note that the grouping (1 11 06) is invalid because “06” cannot be mapped into ‘F’ since “6” is different from “06”.</p><p>Given a string s containing only digits, return the number of ways to decode it.</p><p>The answer is guaranteed to fit in a 32-bit integer.</p><pre><code class="kotlin">fun numDecodings(s: String): Int &#123;    val dp = IntArray(s.length + 1)    dp[0] = 1    for (i in 0..s.length - 1) &#123;        if (s[i] != &#39;0&#39;) &#123;            dp[i + 1] = dp[i]        &#125;        if (i &gt; 0 &amp;&amp; s[i - 1] != &#39;0&#39; &amp;&amp; ((s[i - 1] - &#39;0&#39;) * 10 + (s[i] - &#39;0&#39;)) &lt;= 26) &#123;            dp[i + 1] += dp[i - 1]        &#125;    &#125;    return dp[s.length]&#125;</code></pre><h4 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a>92. Reverse Linked List II</h4><p>Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.</p><pre><code class="kotlin">fun reverseBetween(head: ListNode?, left: Int, right: Int): ListNode? &#123;    val dummyHead = ListNode(0)    dummyHead.next = head    var cur = head    var i = 1    var before: ListNode? = null    while (i &lt; left) &#123;        before = cur        cur = cur?.next        i++    &#125;    val rangeTail = cur    var after = cur    var pre: ListNode? = null    while (cur != null &amp;&amp; i &lt;= right) &#123;        val next = cur.next        cur.next = pre        pre = cur        cur = next        i++        after = next    &#125;    val rangeHead = pre    before?.next = rangeHead    rangeTail?.next = after    if (before == null) &#123;        return rangeHead    &#125; else &#123;        return dummyHead.next    &#125;&#125;</code></pre><h4 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a>93. Restore IP Addresses</h4><p>Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order.</p><p>A valid IP address consists of exactly four integers, each integer is between 0 and 255, separated by single dots and cannot have leading zeros. For example, “0.1.2.201” and “192.168.1.1” are valid IP addresses and “0.011.255.245”, “192.168.1.312” and “<a href="mailto:192.168@1.1">192.168@1.1</a>“ are invalid IP addresses. </p><pre><code class="kotlin">val ret = mutableListOf&lt;String&gt;()fun restoreIpAddresses(s: String): List&lt;String&gt; &#123;    restoreIpAddressesRecur(s, 0, mutableListOf())    return ret&#125;fun restoreIpAddressesRecur(s: String, start: Int, path: MutableList&lt;String&gt;) &#123;    if (path.size == 4 &amp;&amp; start == s.length) &#123;        val builder = StringBuilder()        for (it in path) &#123;            builder.append(it).append(&#39;.&#39;)        &#125;        builder.deleteCharAt(builder.length - 1)        ret.add(builder.toString())        return    &#125;    for (i in start .. s.length - 1) &#123;        if (path.size == 3 &amp;&amp; (s.length - 1 - start) &gt; 3) &#123;            break        &#125;        if (i - start &gt; 0 &amp;&amp; s[start] == &#39;0&#39;) &#123;            break        &#125;        val item = s.subSequence(start .. i).toString()        if (Integer.parseInt(item) &gt; 255) &#123;            break        &#125;        path.add(item)        restoreIpAddressesRecur(s, i + 1, path)        path.removeAt(path.size - 1)    &#125;&#125;</code></pre><h4 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h4><p>Given the root of a binary tree, return the inorder traversal of its nodes’ values.</p><pre><code class="kotlin">//递归fun inorderTraversal(root: TreeNode?): List&lt;Int&gt; &#123;    val ret = mutableListOf&lt;Int&gt;()    inorderTraversalRecur(root, ret)    return ret&#125;fun inorderTraversalRecur(node: TreeNode?, path: MutableList&lt;Int&gt;) &#123;    if (node == null) &#123;        return    &#125;    inorderTraversalRecur(node.left, path)    path.add(node.`val`)    inorderTraversalRecur(node.right, path)&#125;//迭代fun inorderTraversal(root: TreeNode?): List&lt;Int&gt; &#123;    val ret = mutableListOf&lt;Int&gt;()    val stack: Deque&lt;TreeNode&gt; = LinkedList&lt;TreeNode&gt;()    var cur = root    while (cur != null || stack.isNotEmpty()) &#123;        while (cur != null) &#123;            stack.push(cur)            cur = cur.left        &#125;        cur = stack.pop()        ret.add(cur.`val`)        cur = cur.right    &#125;    return ret&#125;</code></pre><h4 id="95-Unique-Binary-Search-Trees-II"><a href="#95-Unique-Binary-Search-Trees-II" class="headerlink" title="95. Unique Binary Search Trees II"></a>95. Unique Binary Search Trees II</h4><p>Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.</p><pre><code class="kotlin">fun generateTrees(n: Int): List&lt;TreeNode?&gt; &#123;    return generateTreesInternal(IntArray(n) &#123;        it + 1    &#125;, 0, n - 1)&#125;fun generateTreesInternal(arr: IntArray, start: Int, end: Int): List&lt;TreeNode?&gt; &#123;    val ret = mutableListOf&lt;TreeNode?&gt;()    if (start &gt; end) &#123;        ret.add(null)        return ret    &#125;    for (i in start..end) &#123;        val leftTrees = generateTreesInternal(arr, start, i - 1)        val rightTrees = generateTreesInternal(arr, i + 1, end)        for (left in leftTrees) &#123;            for (right in rightTrees) &#123;                val root = TreeNode(arr[i])                root.left = left                root.right = right                ret.add(root)            &#125;        &#125;    &#125;    return ret&#125;</code></pre><h4 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h4><p>Given an integer n, return the number of structurally unique BST’s (binary search trees) which has exactly n nodes of unique values from 1 to n.</p><pre><code class="kotin">//Divide Conquerfun numTrees(n: Int): Int &#123;    return numTreesRecur(1, n)&#125;fun numTreesRecur(start: Int, end: Int) : Int&#123;    var ret = 0    if (start &gt; end) &#123;        return 1    &#125;    for (i in start..end) &#123;        val leftNum = numTreesRecur(start, i - 1)        val rightNum = numTreesRecur(i + 1, end)        ret += leftNum * rightNum    &#125;    return ret&#125;//Dynamic Programingfun numTrees(n: Int): Int &#123;    val G = IntArray(n + 1)    G[0] = 1    G[1] = 1    for (i in 2 .. n) &#123;        for (k in 1..i) &#123;            G[i] += G[k - 1] * G [i - k]        &#125;    &#125;    return G[n]&#125;</code></pre><p>Note: DP的状态转移方程可以从分治推导出来</p><h4 id="97-Interleaving-String"><a href="#97-Interleaving-String" class="headerlink" title="97. Interleaving String"></a>97. Interleaving String</h4><p>Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.</p><p>An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that:</p><ul><li>s = s1 + s2 + … + sn</li><li>t = t1 + t2 + … + tm</li><li>|n - m| &lt;= 1</li><li>The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + … or t1 + s1 + t2 + s2 + t3 + s3 + …</li></ul><p>Note: a + b is the concatenation of strings a and b.</p><pre><code class="kotlin">//递归超时.....:fun isInterleave(s1: String, s2: String, s3: String): Boolean &#123;    return isInterleave(s1, s1.length - 1, s2, s2.length - 1, s3, s3.length - 1)&#125;fun isInterleave(s1: String, i1: Int, s2: String, i2: Int, s3: String, i3: Int): Boolean &#123;    if (i1 &lt; 0 &amp;&amp; i2 &lt; 0 &amp;&amp; i3 &lt; 0) &#123;        return true    &#125;        if (i1 &gt;=0 &amp;&amp; i3 &gt;= 0 &amp;&amp; s1[i1] == s3[i3] &amp;&amp; isInterleave(s1, i1 - 1, s2, i2, s3, i3 - 1)) &#123;        return true    &#125; else if (i2 &gt;= 0 &amp;&amp; i3 &gt;= 0 &amp;&amp; s2[i2] == s3[i3] &amp;&amp; isInterleave(s1, i1, s2, i2 - 1, s3, i3 - 1)) &#123;        return true    &#125; else &#123;        return false    &#125;&#125;//DP:fun isInterleave(s1: String, s2: String, s3: String): Boolean &#123;    if (s1.length + s2.length != s3.length) &#123;        return false    &#125;    val dp = Array(s1.length + 1) &#123;BooleanArray(s2.length + 1)&#125;    dp[0][0] = true    for (i in 0 .. s1.length) &#123;        for (j in 0 .. s2.length) &#123;            if (i &gt; 0 &amp;&amp; s3[i + j - 1] == s1[i - 1] &amp;&amp; dp[i - 1][j]) &#123;                dp[i][j] = true            &#125;            if (j &gt; 0 &amp;&amp; s3[i + j - 1] == s2[j - 1] &amp;&amp; dp[i][j - 1]) &#123;                dp[i][j] = true            &#125;        &#125;    &#125;    return dp[s1.length][s2.length]&#125;</code></pre><h4 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h4><p>Given the root of a binary tree, determine if it is a valid binary search tree (BST).</p><p>A valid BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><pre><code class="kotlin">//递归：var pre: Int? = nullfun isValidBST(root: TreeNode?): Boolean &#123;    if (root == null) &#123;        return true    &#125;    if (!isValidBST(root.left)) &#123;        return false    &#125;    println(root.`val`)    if (pre != null &amp;&amp; root.`val` &lt;= pre!!) &#123;        return false    &#125; else &#123;        pre = root.`val`        return isValidBST(root.right)    &#125;&#125;//迭代fun isValidBST(root: TreeNode?): Boolean &#123;    var pre: Int? = null    val stack = LinkedList&lt;TreeNode&gt;()    var cur = root    while (cur != null || stack.isNotEmpty()) &#123;        while (cur != null) &#123;            stack.push(cur)            cur = cur.left        &#125;        val top = stack.pop()        if (pre != null &amp;&amp; top.`val` &lt;= pre) &#123;            return false        &#125; else &#123;            pre = top.`val`        &#125;        cur = top.right    &#125;    return true&#125;</code></pre><h4 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a>100. Same Tree</h4><p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p><p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p><pre><code class="kotlin">fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean &#123;    if (p?.`val` != q?.`val`) &#123;        return false    &#125;    if (p == null &amp;&amp; q == null) &#123;        return true    &#125;    return isSameTree(p?.left, q?.left) &amp;&amp; isSameTree(p?.right, q?.right)&#125;</code></pre><h4 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h4><p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p><pre><code class="kotlin">fun isSymmetric(root: TreeNode?): Boolean &#123;    return isSymmetricRecur(root?.left, root?.right)&#125;fun isSymmetricRecur(L: TreeNode?, R: TreeNode?): Boolean &#123;    if (L == null &amp;&amp; R == null) &#123;        return true    &#125; else if (L == null || R == null) &#123;        return false    &#125;    if (L.`val` != R.`val`) &#123;        return false    &#125;    if (!isSymmetricRecur(L.left, R.right)) &#123;        return false    &#125;    if (!isSymmetricRecur(L.right, R.left)) &#123;        return false    &#125;    return true&#125;</code></pre><h4 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h4><p>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p><pre><code class="kotlin">fun levelOrder(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; &#123;    val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()    if (root == null) &#123;        return ret    &#125;    val queue: Queue&lt;TreeNode&gt; = LinkedList()    queue.offer(root)    var curLevelCnt = 1    var nextLevelCnt = 0    var tmpList = mutableListOf&lt;Int&gt;()    while (queue.isNotEmpty()) &#123;        val node: TreeNode = queue.remove()        tmpList.add(node.`val`)        curLevelCnt--        if (node.left != null) &#123;            queue.offer(node.left)            nextLevelCnt++        &#125;        if (node.right != null) &#123;            queue.offer(node.right)            nextLevelCnt++        &#125;        if (curLevelCnt == 0) &#123;            ret.add(tmpList)            tmpList = mutableListOf()            curLevelCnt = nextLevelCnt            nextLevelCnt = 0        &#125;    &#125;    return ret&#125;</code></pre><h4 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h4><p>Given the root of a binary tree, return the zigzag level order traversal of its nodes’ values. (i.e., from left to right, then right to left for the next level and alternate between).</p><pre><code class="kotlin">    fun zigzagLevelOrder(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; &#123;        val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()        if (root == null) &#123;            return ret        &#125;        val queue: Queue&lt;TreeNode&gt; = LinkedList()        queue.offer(root)        var curLevelCnt = 1        var nextLevelCnt = 0        var level = 0        var tmpList = mutableListOf&lt;Int&gt;()        while (queue.isNotEmpty()) &#123;            val node: TreeNode = queue.remove()            tmpList.add(node.`val`)            curLevelCnt--            if (node.left != null) &#123;                queue.offer(node.left)                nextLevelCnt++            &#125;            if (node.right != null) &#123;                queue.offer(node.right)                nextLevelCnt++            &#125;            if (curLevelCnt == 0) &#123;                if (level % 2 == 1) &#123;                    ret.add(tmpList.reversed())                &#125; else &#123;                    ret.add(tmpList)                &#125;                level++                tmpList = mutableListOf()                curLevelCnt = nextLevelCnt                nextLevelCnt = 0            &#125;        &#125;        return ret    &#125;</code></pre><h4 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h4><p>Given the root of a binary tree, return its maximum depth.</p><p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><pre><code class="kotlin">fun maxDepth(root: TreeNode?): Int &#123;    return maxDepthRecur(root, 0)&#125;fun maxDepthRecur(root: TreeNode?, level: Int): Int &#123;    if (root == null) &#123;        return level    &#125;    return Math.max(maxDepthRecur(root.left, level + 1),            maxDepthRecur(root.right, level + 1))&#125;</code></pre><h4 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h4><p>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p><pre><code class="kotlin">fun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? &#123;    val inorderIndexMap = mutableMapOf&lt;Int, Int&gt;()    for ((index, value) in inorder.withIndex()) &#123;        inorderIndexMap[value] = index    &#125;    return buildTreeHelper(0, preorder.size - 1, 0, inorder.size - 1, preorder, inorderIndexMap)&#125;fun buildTreeHelper(pL: Int, pR: Int, iL: Int, iR: Int, preorder: IntArray, inorderIndexMap: Map&lt;Int, Int&gt;): TreeNode? &#123;    if (pL &gt; pR || iL &gt; iR) &#123;        return null    &#125;    val iIndex: Int? = inorderIndexMap.get(preorder[pL])    val root = TreeNode(preorder[pL])    iIndex!!    root.left = buildTreeHelper(pL + 1, pL + iIndex - iL, iL, iIndex - 1, preorder, inorderIndexMap)    root.right = buildTreeHelper(pR - (iR - iIndex) + 1, pR, iIndex + 1, iR, preorder, inorderIndexMap)    return root&#125;</code></pre><p>Note: 利用中序遍历确定左右子树的范围</p><h4 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h4><p>Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.</p><pre><code class="kotlin">fun buildTree(inorder: IntArray, postorder: IntArray): TreeNode? &#123;    val inorderMap = mutableMapOf&lt;Int, Int&gt;()    for ((index, value) in inorder.withIndex()) &#123;        inorderMap[value] = index    &#125;    return buildTreeHelper(0, postorder.size - 1, 0, inorder.size - 1, postorder, inorderMap)&#125;fun buildTreeHelper(pL: Int, pR: Int, iL: Int, iR: Int, postorder: IntArray, inorderMap: Map&lt;Int, Int&gt;): TreeNode? &#123;    if (pL &gt; pR || iL &gt; iR) &#123;        return null    &#125;    val root = TreeNode(postorder[pR])    val index = inorderMap[root.`val`]    index!!    root.left = buildTreeHelper(pL, pL + (index - iL) - 1, iL, index - 1, postorder, inorderMap)    root.right = buildTreeHelper(pL + (index - iL), pR - 1, index + 1, iR, postorder, inorderMap)    return root&#125;</code></pre><h4 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107.Binary Tree Level Order Traversal II"></a>107.Binary Tree Level Order Traversal II</h4><p>Given the root of a binary tree, return the bottom-up level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root).</p><pre><code class="kotlin">fun levelOrderBottom(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; &#123;  val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()  if (root == null) &#123;    return ret  &#125;  val queue = LinkedList&lt;TreeNode&gt;()  queue.offer(root)  var currentLevelCnt = 1  var nextLevelCnt = 0  var tmpList = mutableListOf&lt;Int&gt;()  while (queue.isNotEmpty()) &#123;    val node = queue.remove()    tmpList.add(node.`val`)    currentLevelCnt--    if (node.left != null) &#123;      queue.offer(node.left)      nextLevelCnt++    &#125;    if (node.right != null) &#123;      queue.offer(node.right)      nextLevelCnt++    &#125;    if (currentLevelCnt == 0) &#123;      currentLevelCnt = nextLevelCnt      nextLevelCnt = 0      ret.add(tmpList)      tmpList = mutableListOf()    &#125;  &#125;  ret.reverse()  return ret&#125;</code></pre><h4 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. Convert Sorted Array to Binary Search Tree</h4><p>Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.</p><p>A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p><pre><code class="kotlin">fun sortedArrayToBST(nums: IntArray): TreeNode? &#123;    return sortedArrayToBSTHelper(nums, 0, nums.size - 1)&#125;fun sortedArrayToBSTHelper(nums: IntArray, start: Int, end: Int): TreeNode? &#123;    if (start &gt; end) &#123;        return null    &#125;    val mid = (start + end) / 2    val root = TreeNode(nums[mid])    root.left = sortedArrayToBSTHelper(nums, start, mid - 1)    root.right = sortedArrayToBSTHelper(nums, mid + 1, end)    return root&#125;</code></pre><h4 id="109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="109. Convert Sorted List to Binary Search Tree"></a>109. Convert Sorted List to Binary Search Tree</h4><p>Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><pre><code class="kotlin">fun sortedListToBST(head: ListNode?): TreeNode? &#123;    val list = mutableListOf&lt;Int&gt;()    var tmp = head    while (tmp != null) &#123;        list.add(tmp.`val`)        tmp = tmp.next    &#125;    return sortedListToBSTHelper(list, 0, list.size - 1)&#125;fun sortedListToBSTHelper(list: List&lt;Int&gt;, start: Int, end: Int): TreeNode? &#123;    if (start &gt; end) &#123;        return null    &#125;    val mid = (start + end) / 2    val root = TreeNode(list[mid])    root.left = sortedListToBSTHelper(list, start, mid - 1)    root.right = sortedListToBSTHelper(list, mid + 1, end)    return root&#125;</code></pre><h4 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. Balanced Binary Tree</h4><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><ul><li>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</li></ul><pre><code class="kotlin">fun isBalanced(root: TreeNode?): Boolean &#123;    return isBalancedHelper(root, 0) &gt;= 0&#125;fun isBalancedHelper(root: TreeNode?, level: Int): Int &#123;    if (root == null) &#123;        return level    &#125;    val leftLevel = isBalancedHelper(root.left, level + 1)    val rightLevel = isBalancedHelper(root.right, level + 1)    if (leftLevel == -1 || rightLevel == -1 || Math.abs(leftLevel - rightLevel) &gt; 1) &#123;        return -1    &#125; else &#123;        return Math.max(leftLevel, rightLevel)    &#125;&#125;</code></pre><h4 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h4><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p>Note: A leaf is a node with no children.</p><pre><code class="kotlin">fun minDepth(root: TreeNode?): Int &#123;    if (root == null) &#123;        return 0    &#125;    return minDepthHelper(root, 1)&#125;fun minDepthHelper(root: TreeNode?, level: Int): Int &#123;    if (root?.left == null &amp;&amp; root?.right == null) &#123;        return level    &#125;    if (root.left == null) &#123;        return minDepthHelper(root.right, level + 1)    &#125; else if (root.right == null)&#123;        return minDepthHelper(root.left, level + 1)    &#125; else  &#123;        return Math.min(minDepthHelper(root.right, level + 1), minDepthHelper(root.left, level + 1))    &#125;&#125;</code></pre><h4 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a>112. Path Sum</h4><p>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</p><p>A leaf is a node with no children.</p><pre><code class="kotlin">fun hasPathSum(root: TreeNode?, targetSum: Int): Boolean &#123;    if (root == null) &#123;        return false    &#125;    return hasPathSumHelper(root, root.`val`, targetSum)&#125;fun hasPathSumHelper(root: TreeNode, curSum: Int, targetSum: Int): Boolean &#123;    if (root.left == null &amp;&amp; root.right == null) &#123;        if (curSum == targetSum) &#123;            return true        &#125;    &#125;    var ret = false    root.left?.also &#123;        ret = ret or hasPathSumHelper(it, curSum + it.`val`, targetSum)    &#125;    root.right?.also &#123;        ret = ret or hasPathSumHelper(it, curSum + it.`val`, targetSum)    &#125;    return ret&#125;</code></pre><h4 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a>113. Path Sum II</h4><p>Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path’s sum equals targetSum.</p><p>A leaf is a node with no children.</p><pre><code class="kotlin">fun pathSum(root: TreeNode?, targetSum: Int): List&lt;List&lt;Int&gt;&gt; &#123;    val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()    if (root == null) &#123;        return ret    &#125;    val backtrace = mutableListOf&lt;Int&gt;()    backtrace.add(root.`val`)    pathSumHelper(root, targetSum, root.`val`, backtrace, ret)    return ret&#125;fun pathSumHelper(root: TreeNode, targetSum: Int, curSum: Int,                    backtrace: MutableList&lt;Int&gt;, ret: MutableList&lt;List&lt;Int&gt;&gt;) &#123;    if (root.left == null &amp;&amp; root.right == null) &#123;        if (targetSum == curSum) &#123;            ret.add(backtrace.toList())            return        &#125;    &#125;    root.left?.also &#123;        backtrace.add(it.`val`)        pathSumHelper(it, targetSum, curSum + it.`val`, backtrace, ret)        backtrace.removeAt(backtrace.lastIndex)    &#125;    root.right?.also &#123;        backtrace.add(it.`val`)        pathSumHelper(it, targetSum, curSum + it.`val`, backtrace, ret)        backtrace.removeAt(backtrace.lastIndex)    &#125;&#125;</code></pre><h4 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h4><p>Given the root of a binary tree, flatten the tree into a “linked list”:</p><ul><li><p>The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.</p></li><li><p>The “linked list” should be in the same order as a pre-order traversal of the binary tree.</p></li></ul><pre><code class="kotlin">fun flatten(root: TreeNode?): Unit &#123;    flattenHelper(root)&#125;fun flattenHelper(root: TreeNode?): TreeNode? &#123;    if (root == null) &#123;        return null    &#125;    val R = root.right    root.right = flattenHelper(root.left)    root.left = null    var tmp: TreeNode = root    while (tmp.right != null) &#123;        tmp = tmp.right!!    &#125;    tmp.right = flattenHelper(R)    return root&#125;</code></pre><h4 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. Populating Next Right Pointers in Each Node</h4><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><p>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}</p><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p><p>Initially, all next pointers are set to NULL.</p><p>Follow up:</p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li></ul><pre><code class="kotlin">fun connect(root: Node?): Node? &#123;    if (root == null) &#123;        return null    &#125;    val queue = LinkedList&lt;Node&gt;()    queue.offer(root)    var curentLevelCnt = 1    var nextLevelCnt = 0    var lastNode: Node? = null    while (queue.isNotEmpty()) &#123;        val node = queue.remove()        if (lastNode != null) &#123;            lastNode.next = node        &#125;        lastNode = node        curentLevelCnt--        if (node.left != null) &#123;            queue.offer(node.left)            nextLevelCnt++        &#125;        if (node.right != null) &#123;            queue.offer(node.right)            nextLevelCnt++        &#125;        if (curentLevelCnt == 0) &#123;            lastNode = null            curentLevelCnt = nextLevelCnt            nextLevelCnt = 0        &#125;    &#125;    return root&#125;</code></pre><h4 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a>117. Populating Next Right Pointers in Each Node II</h4><p>Same as 116</p><h4 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a>118. Pascal’s Triangle</h4><p>Given an integer numRows, return the first numRows of Pascal’s triangle.</p><pre><code class="kotlin">fun generate(numRows: Int): List&lt;List&lt;Int&gt;&gt; &#123;    val ret = mutableListOf&lt;List&lt;Int&gt;&gt;()    if (numRows == 0) &#123;        return ret    &#125;    ret.add(listOf(1))    if (numRows == 1) &#123;        return ret    &#125;    ret.add(listOf(1,1))    for (i in 2 .. numRows - 1) &#123;        val tmp = mutableListOf&lt;Int&gt;()        tmp.add(1)        for (k in 1 .. i - 1) &#123;            tmp.add(ret[i - 1][k - 1] + ret[i - 1][k])        &#125;        tmp.add(1)        ret.add(tmp)    &#125;    return ret&#125;</code></pre><h4 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119. Pascal’s Triangle II"></a>119. Pascal’s Triangle II</h4><p>Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle.</p><pre><code class="kotlin">fun getRow(rowIndex: Int): List&lt;Int&gt; &#123;    val dpArray = IntArray(rowIndex + 1)    if (rowIndex &gt;= 0) &#123;        dpArray[0] = 1    &#125;    if (rowIndex &gt;= 1) &#123;        dpArray[0] = 1        dpArray[1] = 1    &#125;    if (rowIndex &gt;= 2) &#123;        for (i in 2 .. rowIndex) &#123;            for (k in i - 1 downTo 1) &#123;                dpArray[k] = dpArray[k] + dpArray[k - 1]            &#125;            dpArray[i] = 1        &#125;    &#125;    return dpArray.toList()&#125;</code></pre><h4 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h4><p>Given a triangle array, return the minimum path sum from top to bottom.</p><p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.</p><pre><code class="kotlin">fun minimumTotal(triangle: List&lt;List&lt;Int&gt;&gt;): Int &#123;    val dArray = IntArray(triangle[triangle.lastIndex].size)    dArray[0] = triangle[0][0]    for (i in 1 .. triangle.lastIndex) &#123;        val rowArray = triangle[i]        dArray[rowArray.lastIndex] = dArray[rowArray.lastIndex - 1] + rowArray[rowArray.lastIndex]        for (k in rowArray.lastIndex - 1 downTo 1) &#123;            dArray[k] = Math.min(rowArray[k] + dArray[k - 1], rowArray[k] + dArray[k])        &#125;        dArray[0] = dArray[0] + rowArray[0]    &#125;    var ret = Int.MAX_VALUE    for (v in dArray) &#123;        ret = Math.min(v, ret)    &#125;    return ret&#125;</code></pre><p>Note: Dynamic Programing</p><h4 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h4><p>You are given an array prices where prices[i] is the price of a given stock on the ith day.</p><p>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</p><p>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</p><pre><code class="kotlin">fun maxProfit(prices: IntArray): Int &#123;    val dp = IntArray(prices.size)    dp[0] = 0    var minPrice = prices[0]    for (i in 1 .. prices.lastIndex) &#123;        if (prices[i] &lt; minPrice) &#123;            minPrice = prices[i]            dp[i] = dp[i - 1]        &#125; else &#123;            dp[i] = Math.max(dp[i - 1], prices[i] - minPrice)        &#125;    &#125;    return dp[dp.lastIndex]&#125;</code></pre><p>Note: 动态规划方程: dp[i] = max(dp[i - 1], arr[i] - minPrice)</p><h4 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h4><p>[Greedy]</p><p>You are given an array prices where prices[i] is the price of a given stock on the ith day.</p><p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p><p>Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p><pre><code class="kotlin">fun maxProfit(prices: IntArray): Int &#123;    var ans = 0    for (i in 1 .. prices.size - 1) &#123;        ans += Math.max(0, prices[i] - prices[i - 1])    &#125;    return ans&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Leetcode-Kotlin-解题记录&quot;&gt;&lt;a href=&quot;#Leetcode-Kotlin-解题记录&quot; class=&quot;headerlink&quot; title=&quot;Leetcode Kotlin 解题记录&quot;&gt;&lt;/a&gt;Leetcode Kotlin 解题记录&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://wujingchao.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>又发现了一个原生 Android Bug</title>
    <link href="http://wujingchao.github.io/2020/11/27/notification_delegate/"/>
    <id>http://wujingchao.github.io/2020/11/27/notification_delegate/</id>
    <published>2020-11-26T16:00:00.000Z</published>
    <updated>2024-12-07T09:27:38.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="又发现了一个原生Android-Bug"><a href="#又发现了一个原生Android-Bug" class="headerlink" title="又发现了一个原生Android Bug"></a>又发现了一个原生Android Bug</h3><p>最近在做推送，有一个接口可以给别的应用代发通知，可以不用拉起进程，这样做应该是比较省电，不用唤醒进程。</p><pre><code class="java">NotificationManager.notifyAsPackage()</code></pre><p>但是有一个问题，创建一个振动和声音开启的NotificationChannel，在这个Channel上发送通知振动会失效，并且系统会报错误日志。单独振动和单独声音的Channel是正常的，看了下NotificationManagerService的代码，发现是在18年的时候，这个特性刚加不久，就被一个三星的哥们改出问题了，之后也没有去修复，很是烦恼…. 正常的应用使用通知是不会有问题的，就是代发通知会出现。</p><p>这个接口日常用的不多，基本没有人使用，在AOSP里面搜索都没有人使用，决定修改源码，再给Google的committer发个邮件看看，希望能够有回应吧。下面是邮件内容:</p><hr><p>I found that the Android notification delegate  has a bug. The  vibration does not take effect when the vibration and sound exist at the same time:</p><p><em>NotificationManager.notifyAsPackage()</em></p><p>System will log a exception : </p><pre><code>2020-11-27 16:22:27.341 1307-10892/system_process E/AppOps: checkOperation  java.lang.SecurityException: Specified package com.xxxx.xxxx.push under uid 10225 but it is really 1000    at com.android.server.appop.AppOpsService.verifyAndGetBypass(AppOpsService.java:4007)    at com.android.server.appop.AppOpsService.checkOperationUnchecked(AppOpsService.java:2979)    at com.android.server.appop.AppOpsService.checkOperationImpl(AppOpsService.java:2962)    at com.android.server.appop.AppOpsService.checkOperationInternal(AppOpsService.java:2943)    at com.android.server.appop.AppOpsService.checkOperation(AppOpsService.java:2932)    at com.android.server.appop.AppOpsService.checkAudioOperationImpl(AppOpsService.java:3026)    at com.android.server.appop.AppOpsService.checkAudioOperation(AppOpsService.java:3014)    at android.app.AppOpsManager.checkAudioOpNoThrow(AppOpsManager.java:7788)    at com.android.server.VibratorService.getAppOpMode(VibratorService.java:1094)    at com.android.server.VibratorService.shouldVibrate(VibratorService.java:1126)    at com.android.server.VibratorService.startVibrationLocked(VibratorService.java:919)    at com.android.server.VibratorService.vibrate(VibratorService.java:814)    at android.os.SystemVibrator.vibrate(SystemVibrator.java:235)    at com.android.server.notification.NotificationManagerService.lambda$playVibration$5$NotificationManagerService(NotificationManagerService.java:7143)    at com.android.server.notification.-$$Lambda$NotificationManagerService$BDavS_Sg4m_dKO3ZgtuCsFeqqms.run(Unknown Source:6)    at java.lang.Thread.run(Thread.java:923)</code></pre><p>This is the first commit, add notification delegate post feature:</p><p><a href="https://android.googlesource.com/platform/frameworks/base/+/a7ba45acb1e18e654d9861ee57c0ae1e6ebfbef9^!/services/core/java/com/android/server/notification/NotificationManagerService.java">feature commit</a></p><p>Then this submitted commit:</p><p><a href="https://android.googlesource.com/platform/frameworks/base/+/de93388430b25225033dbe7dc8f5d02a8c1307e5^!/services/core/java/com/android/server/notification/NotificationManagerService.java">bug commit</a></p><p>change </p><pre><code>  mVibrator.vibrate(record.sbn.getUid(), record.sbn.**getPackageName**(),    effect, &quot;Notification (delayed)&quot;, record.getAudioAttributes());</code></pre><p>to </p><pre><code>  mVibrator.vibrate(record.sbn.getUid(), record.sbn.**getOpPkg**(),   effect, &quot;Notification (delayed)&quot;, record.getAudioAttributes());</code></pre><p>Cause AppOpsManager check that the package does not match the uid</p><p>Please check the bug,  thanks!</p><hr><p>提了Patch不给我合，算了，遇到这个问题的小伙伴自己修改下….</p><p><a href="https://android-review.googlesource.com/c/platform/frameworks/base/+/1514786">https://android-review.googlesource.com/c/platform/frameworks/base/+/1514786</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;又发现了一个原生Android-Bug&quot;&gt;&lt;a href=&quot;#又发现了一个原生Android-Bug&quot; class=&quot;headerlink&quot; title=&quot;又发现了一个原生Android Bug&quot;&gt;&lt;/a&gt;又发现了一个原生Android Bug&lt;/h3&gt;&lt;p&gt;最近
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>(转)矛盾论</title>
    <link href="http://wujingchao.github.io/2020/10/05/contridiction/"/>
    <id>http://wujingchao.github.io/2020/10/05/contridiction/</id>
    <published>2020-10-05T03:49:50.000Z</published>
    <updated>2024-12-07T09:22:43.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="矛盾论"><a href="#矛盾论" class="headerlink" title="矛盾论"></a>矛盾论</h3><p>(一九三七年八月）  </p><blockquote><p>这篇哲学论文，是毛泽东继《实践论》之后，为了同一的目的，即为了克服存在于中国共产党内的严重的教条主义思想而写的，曾在延安的抗日军事政治大学作过讲演。在收入本书第一版的时候，作者作了部分的补充、删节和修改。   </p></blockquote><p>　　事物的矛盾法则，即对立统一的法则，是唯物辩证法的最根本的法则。列宁说：“就本来的意义讲，辩证法是研究对象的本质自身中的矛盾。”⑴列宁常称这个法则为辩证法的本质，又称之为辩证法的核心⑵。因此，我们在研究这个法则时，不得不涉及广泛的方面，不得不涉及许多的哲学问题。如果我们将这些问题都弄清楚了，我们就在根本上懂得了唯物辩证法。这些问题是：两种宇宙观；矛盾的普遍性；矛盾的特殊性；主要的矛盾和主要的矛盾方面；矛盾诸方面的同一性和斗争性；对抗在矛盾中的地位。<br>　　苏联哲学界在最近数年中批判了德波林学派⑶的唯心论，这件事引起了我们的极大的兴趣。德波林的唯心论在中国共产党内发生了极坏的影响，我们党内的教条主义思想不能说和这个学派的作风没有关系。因此，我们现在的哲学研究工作，应当以扫除教条主义思想为主要的目标。   </p><h2 id="一-两种宇宙观"><a href="#一-两种宇宙观" class="headerlink" title="一　两种宇宙观"></a>一　两种宇宙观</h2><p>　　在人类的认识史中，从来就有关于宇宙发展法则的两种见解，一种是形而上学的见解，一种是辩证法的见解，形成了互相对立的两种宇宙观。列宁说：“对于发展（进化）所持的两种基本的（或两种可能的？或两种在历史上常见的？）观点是：（一）认为发展是减少和增加，是重复；（二）认为发展是对立的统一（统一物分成为两个互相排斥的对立，而两个对立又互相关联着）。”⑷列宁说的就是这两种不同的宇宙观。<br>　　形而上学，亦称玄学。这种思想，无论在中国，在欧洲，在一个很长的历史时间内，是属于唯心论的宇宙观，并在人们的思想中占了统治的地位。在欧洲，资产阶级初期的唯物论，也是形而上学的。由于欧洲许多国家的社会经济情况进到了资本主义高度发展的阶段，生产力、阶级斗争和科学均发展到了历史上未有过的水平，工业无产阶级成为历史发展的最伟大的动力，因而产生了马克思主义的唯物辩证法的宇宙观。于是，在资产阶级那里，除了公开的极端露骨的反动的唯心论之外，还出现了庸俗的进化论，出来对抗唯物辩证法。<br>　　所谓形而上学的或庸俗进化论的宇宙观，就是用孤立的、静止的和片面的观点去看世界。这种宇宙观把世界一切事物，一切事物的形态和种类，都看成是永远彼此孤立和永远不变化的。如果说有变化，也只是数量的增减和场所的变更。而这种增减和变更的原因，不在事物的内部而在事物的外部，即是由于外力的推动。形而上学家认为，世界上各种不同事物和事物的特性，从它们一开始存在的时候就是如此。后来的变化，不过是数量上的扩大或缩小。他们认为一种事物永远只能反复地产生为同样的事物，而不能变化为另一种不同的事物。在形而上学家看来，资本主义的剥削，资本主义的竞争，资本主义社会的个人主义思想等，就是在古代的奴隶社会里，甚至在原始社会里，都可以找得出来，而且会要永远不变地存在下去。说到社会发展的原因，他们就用社会外部的地理、气候等条件去说明。他们简单地从事物外部去找发展的原因，否认唯物辩证法所主张的事物因内部矛盾引起发展的学说。因此，他们不能解释事物的质的多样性，不能解释一种质变为他种质的现象。这种思想，在欧洲，在十七世纪和十八世纪是机械唯物论，在十九世纪末和二十世纪初则有庸俗进化论。在中国，则有所谓“天不变，道亦不变”⑸的形而上学的思想，曾经长期地为腐朽了的封建统治阶级所拥护。近百年来输入了欧洲的机械唯物论和庸俗进化论，则为资产阶级所拥护。<br>　　和形而上学的宇宙观相反，唯物辩证法的宇宙观主张从事物的内部、从一事物对他事物的关系去研究事物的发展，即把事物的发展看做是事物内部的必然的自己的运动，而每一事物的运动都和它的周围其他事物互相联系着和互相影响着。事物发展的根本原因，不是在事物的外部而是在事物的内部，在于事物内部的矛盾性。任何事物内部都有这种矛盾性，因此引起了事物的运动和发展。事物内部的这种矛盾性是事物发展的根本原因，一事物和他事物的互相联系和互相影响则是事物发展的第二位的原因。这样，唯物辩证法就有力地反对了形而上学的机械唯物论和庸俗进化论的外因论或被动论。这是清楚的，单纯的外部原因只能引起事物的机械的运动，即范围的大小，数量的增减，不能说明事物何以有性质上的千差万别及其互相变化。事实上，即使是外力推动的机械运动，也要通过事物内部的矛盾性。植物和动物的单纯的增长，数量的发展，主要地也是由于内部矛盾所引起的。同样，社会的发展，主要地不是由于外因而是由于内因。许多国家在差不多一样的地理和气候的条件下，它们发展的差异性和不平衡性，非常之大。同一个国家吧，在地理和气候并没有变化的情形下，社会的变化却是很大的。帝国主义的俄国变为社会主义的苏联，封建的闭关锁国的日本变为帝国主义的日本，这些国家的地理和气候并没有变化。长期地被封建制度统治的中国，近百年来发生了很大的变化，现在正在变化到一个自由解放的新中国的方向去，中国的地理和气候并没有变化。整个地球及地球各部分的地理和气候也是变化着的，但以它们的变化和社会的变化相比较，则显得很微小，前者是以若干万年为单位而显现其变化的，后者则在几千年、几百年、几十年、甚至几年或几个月（在革命时期）内就显现其变化了。按照唯物辩证法的观点，自然界的变化，主要地是由于自然界内部矛盾的发展。社会的变化，主要地是由于社会内部矛盾的发展，即生产力和生产关系的矛盾，阶级之间的矛盾，新旧之间的矛盾，由于这些矛盾的发展，推动了社会的前进，推动了新旧社会的代谢。唯物辩证法是否排除外部的原因呢？并不排除。唯物辩证法认为外因是变化的条件，内因是变化的根据，外因通过内因而起作用。鸡蛋因得适当的温度而变化为鸡子，但温度不能使石头变为鸡子，因为二者的根据是不同的。各国人民之间的互相影响是时常存在的。在资本主义时代，特别是在帝国主义和无产阶级革命的时代，各国在政治上、经济上和文化上的互相影响和互相激动，是极其巨大的。十月社会主义革命不只是开创了俄国历史的新纪元，而且开创了世界历史的新纪元，影响到世界各国内部的变化，同样地而且还特别深刻地影响到中国内部的变化，但是这种变化是通过了各国内部和中国内部自己的规律性而起的。两军相争，一胜一败，所以胜败，皆决于内因。胜者或因其强，或因其指挥无误，败者或因其弱，或因其指挥失宜，外因通过内因而引起作用。一九二七年中国大资产阶级战败了无产阶级，是通过中国无产阶级内部的（中国共产党内部的）机会主义而起作用的。当着我们清算了这种机会主义的时候，中国革命就重新发展了。后来，中国革命又受了敌人的严重的打击，是因为我们党内产生了冒险主义。当着我们清算了这种冒险主义的时候，我们的事业就又重新发展了。由此看来，一个政党要引导革命到胜利，必须依靠自己政治路线的正确和组织上的巩固。<br>　　辩证法的宇宙观，不论在中国，在欧洲，在古代就产生了。但是古代的辩证法带着自发的朴素的性质，根据当时的社会历史条件，还不可能有完备的理论，因而不能完全解释宇宙，后来就被形而上学所代替。生活在十八世纪末和十九世纪初期的德国著名哲学家黑格尔，对于辩证法曾经给了很重要的贡献，但是他的辩证法却是唯心的辩证法。直到无产阶级运动的伟大的活动家马克思和恩格斯综合了人类认识史的积极的成果，特别是批判地吸取了黑格尔的辩证法的合理的部分，创造了辩证唯物论和历史唯物论这个伟大的理论，才在人类认识史上起了一个空前的大革命。后来，经过列宁和斯大林，又发展了这个伟大的理论。这个理论一经传到中国来，就在中国思想界引起了极大的变化。<br>　　这个辩证法的宇宙观，主要地就是教导人们要善于去观察和分析各种事物的矛盾的运动，并根据这种分析，指出解决矛盾的方法。因此，具体地了解事物矛盾这一个法则，对于我们是非常重要的。   </p><h2 id="二-矛盾的普遍性"><a href="#二-矛盾的普遍性" class="headerlink" title="二　矛盾的普遍性"></a>二　矛盾的普遍性</h2><p>　　为了叙述的便利起见，我在这里先说矛盾的普遍性，再说矛盾的特殊性。这是因为马克思主义的伟大的创造者和继承者马克思、恩格斯、列宁、斯大林他们发现了唯物辩证法的宇宙观，已经把唯物辩证法应用在人类历史的分析和自然历史的分析的许多方面，应用在社会的变革和自然的变革（例如在苏联）的许多方面，获得了极其伟大的成功，矛盾的普遍性已经被很多人所承认，因此，关于这个问题只需要很少的话就可以说明白；而关于矛盾的特殊性的问题，则还有很多的同志，特别是教条主义者，弄不清楚。他们不了解矛盾的普遍性即寓于矛盾的特殊性之中。他们也不了解研究当前具体事物的矛盾的特殊性，对于我们指导革命实践的发展有何等重要的意义。因此，关于矛盾的特殊性的问题应当着重地加以研究，并用足够的篇幅加以说明。为了这个缘故，当着我们分析事物矛盾的法则的时候，我们就先来分析矛盾的普遍性的问题，然后再着重地分析矛盾的特殊性的问题，最后仍归到矛盾的普遍性的问题。<br>　　矛盾的普遍性或绝对性这个问题有两方面的意义。其一是说，矛盾存在于一切事物的发展过程中；其二是说，每一事物的发展过程中存在着自始至终的矛盾运动。<br>　　恩格斯说：“运动本身就是矛盾。”⑹列宁对于对立统一法则所下的定义，说它就是“承认（发现）自然界（精神和社会两者也在内）的一切现象和过程都含有互相矛盾、互相排斥、互相对立的趋向”⑺。这些意见是对的吗？是对的。一切事物中包含的矛盾方面的相互依赖和相互斗争，决定一切事物的生命，推动一切事物的发展。没有什么事物是不包含矛盾的，没有矛盾就没有世界。<br>　　矛盾是简单的运动形式（例如机械性的运动）的基础，更是复杂的运动形式的基础。<br>　　恩格斯这样说明过矛盾的普遍性：“如果简单的机械的移动本身包含着矛盾，那末，物质的更高的运动形式，特别是有机生命及其发展，就更加包含着矛盾。……生命首先就在于：生物在每一个瞬间是它自身，但却又是别的什么。所以，生命也是存在于物体和过程本身中的不断地自行产生并自行解决的矛盾；这一矛盾一停止，生命亦即停止，于是死就来到。同样，我们看到了，在思维的范围以内我们也不能避免矛盾，并且我们看到了，例如，人的内部无限的认识能力与此种认识能力仅在外部被局限的而且认识上也被局限的个别人们身上的实际的实现二者之间的矛盾，是在人类世代的无穷的——至少对于我们，实际上是无穷的——连续系列之中，是在无穷的前进运动之中解决的。”<br>　　“高等数学的主要基础之一，就是矛盾……”<br>　　“就是初等数学，也充满着矛盾。……”⑻<br>　　列宁也这样说明过矛盾的普遍性：“在数学中，正和负，微分和积分。<br>　　在力学中，作用和反作用。<br>　　在物理学中，阳电和阴电。<br>　　在化学中，原子的化合和分解。<br>　　在社会科学中，阶级斗争。”⑼<br>　　战争中的攻守，进退，胜败，都是矛盾着的现象。失去一方，他方就不存在。双方斗争而又联结，组成了战争的总体，推动了战争的发展，解决了战争的问题。<br>　　人的概念的每一差异，都应把它看作是客观矛盾的反映。客观矛盾反映入主观的思想，组成了概念的矛盾运动，推动了思想的发展，不断地解决了人们的思想问题。<br>　　党内不同思想的对立和斗争是经常发生的，这是社会的阶级矛盾和新旧事物的矛盾在党内的反映。党内如果没有矛盾和解决矛盾的思想斗争，党的生命也就停止了。<br>　　由此看来，不论是简单的运动形式，或复杂的运动形式，不论是客观现象，或思想现象，矛盾是普遍地存在着，矛盾存在于一切过程中，这一点已经弄清楚了。但是每一过程的开始阶段，是否也有矛盾存在呢？是否每一事物的发展过程具有自始至终的矛盾运动呢？<br>　　从苏联哲学界批判德波林学派的文章中看出，德波林学派有这样一种见解，他们认为矛盾不是一开始就在过程中出现，须待过程发展到一定的阶段才出现。那末，在那一时间以前，过程发展的原因不是由于内部的原因，而是由于外部的原因了。这样，德波林回到形而上学的外因论和机械论去了。拿这种见解去分析具体的问题，他们就看见在苏联条件下富农和一般农民之间只有差异，并无矛盾，完全同意了布哈林的意见。在分析法国革命时，他们就认为在革命前，工农资产阶级合组的第三等级中，也只有差异，并无矛盾。德波林学派这类见解是反马克思主义的。他们不知道世界上的每一差异中就已经包含着矛盾，差异就是矛盾。劳资之间，从两阶级发生的时候起，就是互相矛盾的，仅仅还没有激化而已。工农之间，即使在苏联的社会条件下，也有差异，它们的差异就是矛盾，仅仅不会激化成为对抗，不取阶级斗争的形态，不同于劳资间的矛盾；它们在社会主义建设中形成巩固的联盟，并在由社会主义走向共产主义的发展过程中逐渐地解决这个矛盾。这是矛盾的差别性的问题，不是矛盾的有无的问题。矛盾是普遍的、绝对的，存在于事物发展的一切过程中，又贯串于一切过程的始终。<br>　　新过程的发生是什么呢？这是旧的统一和组成此统一的对立成分让位于新的统一和组成此统一的对立成分，于是新过程就代替旧过程而发生。旧过程完结了，新过程发生了。新过程又包含着新矛盾，开始它自己的矛盾发展史。<br>　　事物发展过程的自始至终的矛盾运动，列宁指出马克思在《资本论》中模范地作了这样的分析。这是研究任何事物发展过程所必须应用的方法。列宁自己也正确地应用了它，贯彻于他的全部著作中。<br>　　“马克思在《资本论》中，首先分析的是资产阶级社会（商品社会）里最简单的、最普通的、最基本的、最常见的、最平常的、碰到亿万次的关系——商品交换。这一分析在这个最简单的现象之中（资产阶级社会的这个‘细胞’之中）暴露了现代社会的一切矛盾（以及一切矛盾的胚芽）。往后的叙述又向我们表明了这些矛盾和这个社会各个部分总和的自始至终的发展（增长与运动两者）。”<br>　　列宁说了上面的话之后，接着说道：“这应该是一般辩证法的……叙述（以及研究）方法。”⑽<br>　　中国共产党人必须学会这个方法，才能正确地分析中国革命的历史和现状，并推断革命的将来。   </p><h2 id="三-矛盾的特殊性"><a href="#三-矛盾的特殊性" class="headerlink" title="三　矛盾的特殊性"></a>三　矛盾的特殊性</h2><p>　　矛盾存在于一切事物发展的过程中，矛盾贯串于每一事物发展过程的始终，这是矛盾的普遍性和绝对性，前面已经说过了。现在来说矛盾的特殊性和相对性。<br>　　这个问题，应从几种情形中去研究。<br>　　首先是各种物质运动形式中的矛盾，都带特殊性。人的认识物质，就是认识物质的运动形式，因为除了运动的物质以外，世界上什么也没有，而物质的运动则必取一定的形式。对于物质的每一种运动形式，必须注意它和其他各种运动形式的共同点。但是，尤其重要的，成为我们认识事物的基础的东西，则是必须注意它的特殊点，就是说，注意它和其他运动形式的质的区别。只有注意了这一点，才有可能区别事物。任何运动形式，其内部都包含着本身特殊的矛盾。这种特殊的矛盾，就构成一事物区别于他事物的特殊的本质。这就是世界上诸种事物所以有千差万别的内在的原因，或者叫做根据。自然界存在着许多的运动形式，机械运动、发声、发光、发热、电流、化分、化合等等都是。所有这些物质的运动形式，都是互相依存的，又是本质上互相区别的。每一物质的运动形式所具有的特殊的本质，为它自己的特殊的矛盾所规定。这种情形，不但在自然界中存在着，在社会现象和思想现象中也是同样地存在着。每一种社会形式和思想形式，都有它的特殊的矛盾和特殊的本质。<br>　　科学研究的区分，就是根据科学对象所具有的特殊的矛盾性。因此，对于某一现象的领域所特有的某一种矛盾的研究，就构成某一门科学的对象。例如，数学中的正数和负数，机械学中的作用和反作用，物理学中的阴电和阳电，化学中的化分和化合，社会科学中的生产力和生产关系、阶级和阶级的互相斗争，军事学中的攻击和防御，哲学中的唯心论和唯物论、形而上学观和辩证法观等等，都是因为具有特殊的矛盾和特殊的本质，才构成了不同的科学研究的对象。固然，如果不认识矛盾的普遍性，就无从发现事物运动发展的普遍的原因或普遍的根据；但是，如果不研究矛盾的特殊性，就无从确定一事物不同于他事物的特殊的本质，就无从发现事物运动发展的特殊的原因，或特殊的根据，也就无从辨别事物，无从区分科学研究的领域。<br>　　就人类认识运动的秩序说来，总是由认识个别的和特殊的事物，逐步地扩大到认识一般的事物。人们总是首先认识了许多不同事物的特殊的本质，然后才有可能更进一步地进行概括工作，认识诸种事物的共同的本质。当着人们已经认识了这种共同的本质以后，就以这种共同的认识为指导，继续地向着尚未研究过的或者尚未深入地研究过的各种具体的事物进行研究，找出其特殊的本质，这样才可以补充、丰富和发展这种共同的本质的认识，而使这种共同的本质的认识不致变成枯槁的和僵死的东西。这是两个认识的过程：一个是由特殊到一般，一个是由一般到特殊。人类的认识总是这样循环往复地进行的，而每一次的循环（只要是严格地按照科学的方法）都可能使人类的认识提高一步，使人类的认识不断地深化。我们的教条主义者在这个问题上的错误，就是，一方面，不懂得必须研究矛盾的特殊性，认识各别事物的特殊的本质，才有可能充分地认识矛盾的普遍性，充分地认识诸种事物的共同的本质；另一方面，不懂得在我们认识了事物的共同的本质以后，还必须继续研究那些尚未深入地研究过的或者新冒出来的具体的事物。我们的教条主义者是懒汉，他们拒绝对于具体事物做任何艰苦的研究工作，他们把一般真理看成是凭空出现的东西，把它变成为人们所不能够捉摸的纯粹抽象的公式，完全否认了并且颠倒了这个人类认识真理的正常秩序。他们也不懂得人类认识的两个过程的互相联结——由特殊到一般，又由一般到特殊，他们完全不懂得马克思主义的认识论。<br>　　不但要研究每一个大系统的物质运动形式的特殊的矛盾性及其所规定的本质，而且要研究每一个物质运动形式在其发展长途中的每一个过程的特殊的矛盾及其本质。一切运动形式的每一个实在的非臆造的发展过程内，都是不同质的。我们的研究工作必须着重这一点，而且必须从这一点开始。<br>　　不同质的矛盾，只有用不同质的方法才能解决。例如，无产阶级和资产阶级的矛盾，用社会主义革命的方法去解决；人民大众和封建制度的矛盾，用民主革命的方法去解决；殖民地和帝国主义的矛盾，用民族革命战争的方法去解决；在社会主义社会中工人阶级和农民阶级的矛盾，用农业集体化和农业机械化的方法去解决；共产党内的矛盾，用批评和自我批评的方法去解决；社会和自然的矛盾，用发展生产力的方法去解决。过程变化，旧过程和旧矛盾消灭，新过程和新矛盾发生，解决矛盾的方法也因之而不同。俄国的二月革命和十月革命所解决的矛盾及其所用以解决矛盾的方法是根本上不相同的。用不同的方法去解决不同的矛盾，这是马克思列宁主义者必须严格地遵守的一个原则。教条主义者不遵守这个原则，他们不了解诸种革命情况的区别，因而也不了解应当用不同的方法去解决不同的矛盾，而只是千篇一律地使用一种自以为不可改变的公式到处硬套，这就只能使革命遭受挫折，或者将本来做得好的事情弄得很坏。<br>　　为要暴露事物发展过程中的矛盾在其总体上、在其相互联结上的特殊性，就是说暴露事物发展过程的本质，就必须暴露过程中矛盾各方面的特殊性，否则暴露过程的本质成为不可能，这也是我们作研究工作时必须十分注意的。<br>　　一个大的事物，在其发展过程中，包含着许多的矛盾。例如，在中国资产阶级民主革命过程中，有中国社会各被压迫阶级和帝国主义的矛盾，有人民大众和封建制度的矛盾，有无产阶级和资产阶级的矛盾，有农民及城市小资产阶级和资产阶级的矛盾，有各个反动的统治集团之间的矛盾等等，情形是非常复杂的。这些矛盾，不但各各有其特殊性，不能一律看待，而且每一矛盾的两方面，又各各有其特点，也是不能一律看待的。我们从事中国革命的人，不但要在各个矛盾的总体上，即矛盾的相互联结上，了解其特殊性，而且只有从矛盾的各个方面着手研究，才有可能了解其总体。所谓了解矛盾的各个方面，就是了解它们每一方面各占何等特定的地位，各用何种具体形式和对方发生互相依存又互相矛盾的关系，在互相依存又互相矛盾中，以及依存破裂后，又各用何种具体的方法和对方作斗争。研究这些问题，是十分重要的事情。列宁说：马克思主义的最本质的东西，马克思主义的活的灵魂，就在于具体地分析具体的情况⑾。就是说的这个意思。我们的教条主义者违背列宁的指示，从来不用脑筋具体地分析任何事物，做起文章或演说来，总是空洞无物的八股调，在我们党内造成了一种极坏的作风。<br>　　研究问题，忌带主观性、片面性和表面性。所谓主观性，就是不知道客观地看问题，也就是不知道用唯物的观点去看问题。这一点，我在《实践论》一文中已经说过了。所谓片面性，就是不知道全面地看问题。例如：只了解中国一方、不了解日本一方，只了解共产党一方、不了解国民党一方，只了解无产阶级一方、不了解资产阶级一方，只了解农民一方、不了解地主一方，只了解顺利情形一方、不了解困难情形一方，只了解过去一方、不了解将来一方，只了解个体一方、不了解总体一方，只了解缺点一方、不了解成绩一方，只了解原告一方、不了解被告一方，只了解革命的秘密工作一方、不了解革命的公开工作一方，如此等等。一句话，不了解矛盾各方的特点。这就叫做片面地看问题。或者叫做只看见局部，不看见全体，只看见树木，不看见森林。这样，是不能找出解决矛盾的方法的，是不能完成革命任务的，是不能做好所任工作的，是不能正确地发展党内的思想斗争的。孙子论军事说：“知彼知己，百战不殆。”⑿他说的是作战的双方。唐朝人魏徵说过：“兼听则明，偏信则暗。”⒀也懂得片面性不对。可是我们的同志看问题，往往带片面性，这样的人就往往碰钉子。《水浒传》上宋江三打祝家庄⒁，两次都因情况不明，方法不对，打了败仗。后来改变方法，从调查情形入手，于是熟悉了盘陀路，拆散了李家庄、扈家庄和祝家庄的联盟，并且布置了藏在敌人营盘里的伏兵，用了和外国故事中所说木马计⒂相像的方法，第三次就打了胜仗。《水浒传》上有很多唯物辩证法的事例，这个三打祝家庄，算是最好的一个。列宁说：“要真正地认识对象，就必须把握和研究它的一切方面、一切联系和‘媒介’。我们决不会完全地作到这一点，可是要求全面性，将使我们防止错误，防止僵化。”⒃我们应该记得他的话。表面性，是对矛盾总体和矛盾各方的特点都不去看，否认深入事物里面精细地研究矛盾特点的必要，仅仅站在那里远远地望一望，粗枝大叶地看到一点矛盾的形相，就想动手去解决矛盾（答复问题、解决纠纷、处理工作、指挥战争）。这样的做法，没有不出乱子的。中国的教条主义和经验主义的同志们所以犯错误，就是因为他们看事物的方法是主观的、片面的和表面的。片面性、表面性也是主观性，因为一切客观事物本来是互相联系的和具有内部规律的，人们不去如实地反映这些情况，而只是片面地或表面地去看它们，不认识事物的互相联系，不认识事物的内部规律，所以这种方法是主观主义的。<br>　　不但事物发展的全过程中的矛盾运动，在其相互联结上，在其各方情况上，我们必须注意其特点，而且在过程发展的各个阶段中，也有其特点，也必须注意。<br>　　事物发展过程的根本矛盾及为此根本矛盾所规定的过程的本质，非到过程完结之日，是不会消灭的；但是事物发展的长过程中的各个发展的阶段，情形又往往互相区别。这是因为事物发展过程的根本矛盾的性质和过程的本质虽然没有变化，但是根本矛盾在长过程中的各个发展阶段上采取了逐渐激化的形式。并且，被根本矛盾所规定或影响的许多大小矛盾中，有些是激化了，有些是暂时地或局部地解决了，或者缓和了，又有些是发生了，因此，过程就显出阶段性来。如果人们不去注意事物发展过程中的阶段性，人们就不能适当地处理事物的矛盾。<br>　　例如，自由竞争时代的资本主义发展为帝国主义，这时，无产阶级和资产阶级这两个根本矛盾着的阶级的性质和这个社会的资本主义的本质，并没有变化；但是，两阶级的矛盾激化了，独占资本和自由资本之间的矛盾发生了，宗主国和殖民地的矛盾激化了，各资本主义国家间的矛盾即由各国发展不平衡的状态而引起的矛盾特别尖锐地表现出来了，因此形成了资本主义的特殊阶段，形成了帝国主义阶段。列宁主义之所以成为帝国主义和无产阶级革命时代的马克思主义，就是因为列宁和斯大林正确地说明了这些矛盾，并正确地作出了解决这些矛盾的无产阶级革命的理论和策略。<br>　　拿从辛亥革命⒄开始的中国资产阶级民主革命过程的情形来看，也有了若干特殊阶段。特别是在资产阶级领导时期的革命和在无产阶级领导时期的革命，区别为两个很大不同的历史阶段。这就是：由于无产阶级的领导，根本地改变了革命的面貌，引出了阶级关系的新调度，农民革命的大发动，反帝国主义和反封建主义的革命彻底性，由民主革命转变到社会主义革命的可能性，等等。所有这些，都是在资产阶级领导革命时期不可能出现的。虽然整个过程中根本矛盾的性质，过程之反帝反封建的民主革命的性质（其反面是半殖民地半封建的性质），并没有变化，但是，在这长时间中，经过了辛亥革命失败和北洋军阀统治，第一次民族统一战线的建立和一九二四年至一九二七年的革命，统一战线破裂和资产阶级转入反革命，新的军阀战争，土地革命战争，第二次民族统一战线建立和抗日战争等等大事变，二十多年间经过了几个发展阶段。在这些阶段中，包含着有些矛盾激化了（例如土地革命战争和日本侵入东北四省⒅），有些矛盾部分地或暂时地解决了（例如北洋军阀的被消灭，我们没收了地主的土地），有些矛盾重新发生了（例如新军阀之间的斗争，南方各革命根据地丧失后地主又重新收回土地）等等特殊的情形。<br>　　研究事物发展过程中的各个发展阶段上的矛盾的特殊性，不但必须在其联结上、在其总体上去看，而且必须从各个阶段中矛盾的各个方面去看。<br>　　例如国共两党。国民党方面，在第一次统一战线时期，因为它实行了孙中山的联俄、联共、援助工农的三大政策，所以它是革命的、有朝气的，它是各阶级的民主革命的联盟。一九二七年以后，国民党变到了与此相反的方面，成了地主和大资产阶级的反动集团。一九三六年十二月西安事变⒆后又开始向停止内战、联合共产党共同反对日本帝国主义这个方面转变。这就是国民党在三个阶段上的特点。形成这些特点，当然有种种的原因。中国共产党方面，在第一次统一战线时期，它是幼年的党，它英勇地领导了一九二四年至一九二七年的革命；但在对于革命的性质、任务和方法的认识方面，却表现了它的幼年性，因此在这次革命的后期所发生的陈独秀主义⒇能够起作用，使这次革命遭受了失败。一九二七年以后，它又英勇地领导了土地革命战争，创立了革命的军队和革命的根据地，但是它也犯过冒险主义的错误，使军队和根据地都受了很大的损失。一九三五年以后，它又纠正了冒险主义的错误，领导了新的抗日的统一战线，这个伟大的斗争现在正在发展。在这个阶段上，共产党是一个经过了两次革命的考验、有了丰富的经验的党。这些就是中国共产党在三个阶段上的特点。形成这些特点也有种种的原因。不研究这些特点，就不能了解两党在各个发展阶段上的特殊的相互关系：统一战线的建立，统一战线的破裂，再一个统一战线的建立。而要研究两党的种种特点，更根本的就必须研究这两党的阶级基础以及因此在各个时期所形成的它们和其他方面的矛盾的对立。例如，国民党在它第一次联合共产党的时期，一方面有和国外帝国主义的矛盾，因而它反对帝国主义；另一方面有和国内人民大众的矛盾，它在口头上虽然允许给予劳动人民以许多的利益，但在实际上则只给予很少的利益，或者简直什么也不给。在它进行反共战争的时期，则和帝国主义、封建主义合作反对人民大众，一笔勾销了人民大众原来在革命中所争得的一切利益，激化了它和人民大众的矛盾。现在抗日时期，国民党和日本帝国主义有矛盾，它一面要联合共产党，同时它对共产党和国内人民并不放松其斗争和压迫。共产党则无论在哪一时期，均和人民大众站在一道，反对帝国主义和封建主义；但在现在的抗日时期，由于国民党表示抗日，它对国民党和国内封建势力，也就采取了缓和的政策。由于这些情况，所以或者造成了两党的联合，或者造成了两党的斗争，而且即使在两党联合的时期也有又联合又斗争的复杂的情况。如果我们不去研究这些矛盾方面的特点，我们就不但不能了解这两个党各各和其他方面的关系，也不能了解两党之间的相互关系。<br>　　由此看来，不论研究何种矛盾的特性——各个物质运动形式的矛盾，各个运动形式在各个发展过程中的矛盾，各个发展过程的矛盾的各方面，各个发展过程在其各个发展阶段上的矛盾以及各个发展阶段上的矛盾的各方面，研究所有这些矛盾的特性，都不能带主观随意性，必须对它们实行具体的分析。离开具体的分析，就不能认识任何矛盾的特性。我们必须时刻记得列宁的话：对于具体的事物作具体的分析。<br>　　这种具体的分析，马克思、恩格斯首先给了我们以很好的模范。<br>　　当马克思、恩格斯把这事物矛盾的法则应用到社会历史过程的研究的时候，他们看出生产力和生产关系之间的矛盾，看出剥削阶级和被剥削阶级之间的矛盾以及由于这些矛盾所产生的经济基础和政治及思想等上层建筑之间的矛盾，而这些矛盾如何不可避免地会在各种不同的阶级社会中，引出各种不同的社会革命。<br>　　马克思把这一法则应用到资本主义社会经济结构的研究的时候，他看出这一社会的基本矛盾在于生产的社会性和占有制的私人性之间的矛盾。这个矛盾表现于在各别企业中的生产的有组织性和在全社会中的生产的无组织性之间的矛盾。这个矛盾的阶级表现则是资产阶级和无产阶级之间的矛盾。<br>　　由于事物范围的极其广大，发展的无限性，所以，在一定场合为普遍性的东西，而在另一一定场合则变为特殊性。反之，在一定场合为特殊性的东西，而在另一一定场合则变为普遍性。资本主义制度所包含的生产社会化和生产资料私人占有制的矛盾，是所有有资本主义的存在和发展的各国所共有的东西，对于资本主义说来，这是矛盾的普遍性。但是资本主义的这种矛盾，乃是一般阶级社会发展在一定历史阶段上的东西，对于一般阶级社会中的生产力和生产关系的矛盾说来，这是矛盾的特殊性。然而，当着马克思把资本主义社会这一切矛盾的特殊性解剖出来之后，同时也就更进一步地、更充分地、更完全地把一般阶级社会中这个生产力和生产关系的矛盾的普遍性阐发出来了。<br>　　由于特殊的事物是和普遍的事物联结的，由于每一个事物内部不但包含了矛盾的特殊性，而且包含了矛盾的普遍性，普遍性即存在于特殊性之中，所以，当着我们研究一定事物的时候，就应当去发现这两方面及其互相联结，发现一事物内部的特殊性和普遍性的两方面及其互相联结，发现一事物和它以外的许多事物的互相联结。斯大林在他的名著《论列宁主义基础》一书中说明列宁主义的历史根源的时候，他分析了列宁主义所由产生的国际环境，分析了在帝国主义条件下已经发展到极点的资本主义的诸矛盾，以及这些矛盾使无产阶级革命成为直接实践的问题，并造成了直接冲击资本主义的良好的条件。不但如此，他又分析了为什么俄国成为列宁主义的策源地，分析了沙皇俄国当时是帝国主义一切矛盾的集合点以及俄国无产阶级所以能够成为国际的革命无产阶级的先锋队的原因。这样，斯大林分析了帝国主义的矛盾的普遍性，说明列宁主义是帝国主义和无产阶级革命时代的马克思主义；又分析了沙俄帝国主义在这一般矛盾中所具有的特殊性，说明俄国成了无产阶级革命理论和策略的故乡，而在这种特殊性中间就包含了矛盾的普遍性。斯大林的这种分析，给我们提供了认识矛盾的特殊性和普遍性及其互相联结的模范。<br>　　马克思和恩格斯，同样地列宁和斯大林，他们对于应用辩证法到客观现象的研究的时候，总是指导人们不要带上任何的主观随意性，而必须从客观的实际运动所包含的具体的条件，去看出这些现象中的具体的矛盾、矛盾各方面的具体的地位以及矛盾的具体的相互关系。我们的教条主义者因为没有这种研究态度，所以弄得一无是处。我们必须以教条主义的失败为鉴戒，学会这种研究态度，舍此没有第二种研究法。<br>　　矛盾的普遍性和矛盾的特殊性的关系，就是矛盾的共性和个性的关系。其共性是矛盾存在于一切过程中，并贯串于一切过程的始终，矛盾即是运动，即是事物，即是过程，也即是思想。否认事物的矛盾就是否认了一切。这是共通的道理，古今中外，概莫能外。所以它是共性，是绝对性。然而这种共性，即包含于一切个性之中，无个性即无共性。假如除去一切个性，还有什么共性呢？因为矛盾的各各特殊，所以造成了个性。一切个性都是有条件地暂时地存在的，所以是相对的。<br>　　这一共性个性、绝对相对的道理，是关于事物矛盾的问题的精髓，不懂得它，就等于抛弃了辩证法。   </p><h2 id="四-主要的矛盾和主要的矛盾方面"><a href="#四-主要的矛盾和主要的矛盾方面" class="headerlink" title="四　主要的矛盾和主要的矛盾方面"></a>四　主要的矛盾和主要的矛盾方面</h2><p>　　在矛盾特殊性的问题中，还有两种情形必须特别地提出来加以分析，这就是主要的矛盾和主要的矛盾方面。<br>　　在复杂的事物的发展过程中，有许多的矛盾存在，其中必有一种是主要的矛盾，由于它的存在和发展规定或影响着其他矛盾的存在和发展。<br>　　例如在资本主义社会中，无产阶级和资产阶级这两个矛盾着的力量是主要的矛盾；其他的矛盾力量，例如，残存的封建阶级和资产阶级的矛盾，农民小资产者和资产阶级的矛盾，无产阶级和农民小资产者的矛盾，自由资产阶级和垄断资产阶级的矛盾，资产阶级的民主主义和资产阶级的法西斯主义的矛盾，资本主义国家相互间的矛盾，帝国主义和殖民地的矛盾，以及其他的矛盾，都为这个主要的矛盾力量所规定、所影响。<br>　　半殖民地的国家如中国，其主要矛盾和非主要矛盾的关系呈现着复杂的情况。<br>　　当着帝国主义向这种国家举行侵略战争的时候，这种国家的内部各阶级，除开一些叛国分子以外，能够暂时地团结起来举行民族战争去反对帝国主义。这时，帝国主义和这种国家之间的矛盾成为主要的矛盾，而这种国家内部各阶级的一切矛盾（包括封建制度和人民大众之间这个主要矛盾在内），便都暂时地降到次要和服从的地位。中国一八四○年的鸦片战争（21），一八九四年的中日战争（22），一九○○年的义和团战争（23）和目前的中日战争，都有这种情形。<br>　　然而在另一种情形之下，则矛盾的地位起了变化。当着帝国主义不是用战争压迫而是用政治、经济、文化等比较温和的形式进行压迫的时候，半殖民地国家的统治阶级就会向帝国主义投降，二者结成同盟，共同压迫人民大众。这种时候，人民大众往往采取国内战争的形式，去反对帝国主义和封建阶级的同盟，而帝国主义则往往采取间接的方式去援助半殖民地国家的反动派压迫人民，而不采取直接行动，显出了内部矛盾的特别尖锐性。中国的辛亥革命战争，一九二四年至一九二七年的革命战争，一九二七年以后的十年土地革命战争，都有这种情形。还有半殖民地国家各个反动的统治集团之间的内战，例如在中国的军阀战争，也属于这一类。<br>　　当着国内革命战争发展到从根本上威胁帝国主义及其走狗国内反动派的存在的时候，帝国主义就往往采取上述方法以外的方法，企图维持其统治：或者分化革命阵线的内部，或者直接出兵援助国内反动派。这时，外国帝国主义和国内反动派完全公开地站在一个极端，人民大众则站在另一极端，成为一个主要矛盾，而规定或影响其他矛盾的发展状态。十月革命后各资本主义国家援助俄国反动派，是武装干涉的例子。一九二七年的蒋介石的叛变，是分化革命阵线的例子。<br>　　然而不管怎样，过程发展的各个阶段中，只有一种主要的矛盾起着领导的作用，是完全没有疑义的。<br>　　由此可知，任何过程如果有多数矛盾存在的话，其中必定有一种是主要的，起着领导的、决定的作用，其他则处于次要和服从的地位。因此，研究任何过程，如果是存在着两个以上矛盾的复杂过程的话，就要用全力找出它的主要矛盾。捉住了这个主要矛盾，一切问题就迎刃而解了。这是马克思研究资本主义社会告诉我们的方法。列宁和斯大林研究帝国主义和资本主义总危机的时候，列宁和斯大林研究苏联经济的时候，也告诉了这种方法。万千的学问家和实行家，不懂得这种方法，结果如堕烟海，找不到中心，也就找不到解决矛盾的方法。<br>　　不能把过程中所有的矛盾平均看待，必须把它们区别为主要的和次要的两类，着重于捉住主要的矛盾，已如上述。但是在各种矛盾之中，不论是主要的或次要的，矛盾着的两个方面，又是否可以平均看待呢？也是不可以的。无论什么矛盾，矛盾的诸方面，其发展是不平衡的。有时候似乎势均力敌，然而这只是暂时的和相对的情形，基本的形态则是不平衡。矛盾着的两方面中，必有一方面是主要的，他方面是次要的。其主要的方面，即所谓矛盾起主导作用的方面。事物的性质，主要地是由取得支配地位的矛盾的主要方面所规定的。<br>　　然而这种情形不是固定的，矛盾的主要和非主要的方面互相转化着，事物的性质也就随着起变化。在矛盾发展的一定过程或一定阶段上，主要方面属于甲方，非主要方面属于乙方；到了另一发展阶段或另一发展过程时，就互易其位置，这是依靠事物发展中矛盾双方斗争的力量的增减程度来决定的。<br>　　我们常常说“新陈代谢”这句话。新陈代谢是宇宙间普遍的永远不可抵抗的规律。依事物本身的性质和条件，经过不同的飞跃形式，一事物转化为他事物，就是新陈代谢的过程。任何事物的内部都有其新旧两个方面的矛盾，形成为一系列的曲折的斗争。斗争的结果，新的方面由小变大，上升为支配的东西；旧的方面则由大变小，变成逐步归于灭亡的东西。而一当新的方面对于旧的方面取得支配地位的时候，旧事物的性质就变化为新事物的性质。由此可见，事物的性质主要地是由取得支配地位的矛盾的主要方面所规定的。取得支配地位的矛盾的主要方面起了变化，事物的性质也就随着起变化。<br>　　在资本主义社会中，资本主义已从旧的封建主义社会时代的附庸地位，转化成了取得支配地位的力量，社会的性质也就由封建主义的变为资本主义的。在新的资本主义社会时代，封建势力则由原来处在支配地位的力量转化为附庸的力量，随着也就逐步地归于消灭了，例如英法诸国就是如此。随着生产力的发展，资产阶级由新的起进步作用的阶级，转化为旧的起反动作用的阶级，以至于最后被无产阶级所推翻，而转化为私有的生产资料被剥夺和失去权力的阶级，这个阶级也就要逐步归于消灭了。人数比资产阶级多得多、并和资产阶级同时生长、但被资产阶级统治着的无产阶级，是一个新的力量，它由初期的附属于资产阶级的地位，逐步地壮大起来，成为独立的和在历史上起主导作用的阶级，以至最后夺取政权成为统治阶级。这时，社会的性质，就由旧的资本主义的社会转化成了新的社会主义的社会。这就是苏联已经走过和一切其他国家必然要走的道路。<br>　　就中国的情形来说，帝国主义处在形成半殖民地这种矛盾的主要地位，压迫中国人民，中国则由独立国变为半殖民地。然而事情必然会变化，在双方斗争的局势中，中国人民在无产阶级领导之下所生长起来的力量必然会把中国由半殖民地变为独立国，而帝国主义则将被打倒，旧中国必然要变为新中国。<br>　　旧中国变为新中国，还包含着国内旧的封建势力和新的人民势力之间的情况的变化。旧的封建地主阶级将被打倒，由统治者变为被统治者，这个阶级也就会要逐步归于消灭。人民则将在无产阶级领导之下，由被统治者变为统治者。这时，中国社会的性质就会起变化，由旧的半殖民地和半封建的社会变为新的民主的社会。<br>　　这种互相转化的事情，过去已有经验。统治中国将近三百年的清朝帝国，曾在辛亥革命时期被打倒；而孙中山领导的革命同盟会，则曾经一度取得了胜利。在一九二四年至一九二七年的革命战争中，共产党和国民党联合的南方革命势力，曾经由弱小的力量变得强大起来，取得了北伐的胜利；而称雄一时的北洋军阀则被打倒了。一九二七年，共产党领导的人民力量，受了国民党反动势力的打击，变得很小了；但因肃清了自己内部的机会主义，就又逐步地壮大起来。在共产党领导的革命根据地内，农民由被统治者转化为统治者，地主则作了相反的转化。世界上总是这样以新的代替旧的，总是这样新陈代谢、除旧布新或推陈出新的。<br>　　革命斗争中的某些时候，困难条件超过顺利条件，在这种时候，困难是矛盾的主要方面，顺利是其次要方面。然而由于革命党人的努力，能够逐步地克服困难，开展顺利的新局面，困难的局面让位于顺利的局面。一九二七年中国革命失败后的情形，中国红军在长征（24）中的情形，都是如此。现在的中日战争，中国又处在困难地位，但是我们能够改变这种情况，使中日双方的情况发生根本的变化。在相反的情形之下，顺利也能转化为困难，如果是革命党人犯了错误的话。一九二四年至一九二七年的革命的胜利，变为失败了。一九二七年以后在南方各省发展起来的革命根据地，至一九三四年都失败了。<br>　　研究学问的时候，由不知到知的矛盾也是如此。当着我们刚才开始研究马克思主义的时候，对于马克思主义的无知或知之不多的情况，和马克思主义的知识之间，互相矛盾着。然而由于努力学习，可以由无知转化为有知，由知之不多转化为知之甚多，由对于马克思主义的盲目性改变为能够自由运用马克思主义。<br>　　有人觉得有些矛盾并不是这样。例如，生产力和生产关系的矛盾，生产力是主要的；理论和实践的矛盾，实践是主要的；经济基础和上层建筑的矛盾，经济基础是主要的：它们的地位并不互相转化。这是机械唯物论的见解，不是辩证唯物论的见解。诚然，生产力、实践、经济基础，一般地表现为主要的决定的作用，谁不承认这一点，谁就不是唯物论者。然而，生产关系、理论、上层建筑这些方面，在一定条件之下，又转过来表现其为主要的决定的作用，这也是必须承认的。当着不变更生产关系，生产力就不能发展的时候，生产关系的变更就起了主要的决定的作用。当着如同列宁所说“没有革命的理论，就不会有革命的运动”（25）的时候，革命理论的创立和提倡就起了主要的决定的作用。当着某一件事情（任何事情都是一样）要做，但是还没有方针、方法、计划或政策的时候，确定方针、方法、计划或政策，也就是主要的决定的东西。当着政治文化等等上层建筑阻碍着经济基础的发展的时候，对于政治上和文化上的革新就成为主要的决定的东西了。我们这样说，是否违反了唯物论呢？没有。因为我们承认总的历史发展中是物质的东西决定精神的东西，是社会的存在决定社会的意识；但是同时又承认而且必须承认精神的东西的反作用，社会意识对于社会存在的反作用，上层建筑对于经济基础的反作用。这不是违反唯物论，正是避免了机械唯物论，坚持了辩证唯物论。<br>　　在研究矛盾特殊性的问题中，如果不研究过程中主要的矛盾和非主要的矛盾以及矛盾之主要的方面和非主要的方面这两种情形，也就是说不研究这两种矛盾情况的差别性，那就将陷入抽象的研究，不能具体地懂得矛盾的情况，因而也就不能找出解决矛盾的正确的方法。这两种矛盾情况的差别性或特殊性，都是矛盾力量的不平衡性。世界上没有绝对地平衡发展的东西，我们必须反对平衡论，或均衡论。同时，这种具体的矛盾状况，以及矛盾的主要方面和非主要方面在发展过程中的变化，正是表现出新事物代替旧事物的力量。对于矛盾的各种不平衡情况的研究，对于主要的矛盾和非主要的矛盾、主要的矛盾方面和非主要的矛盾方面的研究，成为革命政党正确地决定其政治上和军事上的战略战术方针的重要方法之一，是一切共产党人都应当注意的。   </p><h2 id="五-矛盾诸方面的同一性和斗争性"><a href="#五-矛盾诸方面的同一性和斗争性" class="headerlink" title="五　矛盾诸方面的同一性和斗争性"></a>五　矛盾诸方面的同一性和斗争性</h2><p>　　在懂得了矛盾的普遍性和特殊性的问题之后，我们必须进而研究矛盾诸方面的同一性和斗争性的问题。<br>　　同一性、统一性、一致性、互相渗透、互相贯通、互相依赖（或依存）、互相联结或互相合作，这些不同的名词都是一个意思，说的是如下两种情形：第一、事物发展过程中的每一种矛盾的两个方面，各以和它对立着的方面为自己存在的前提，双方共处于一个统一体中；第二、矛盾着的双方，依据一定的条件，各向着其相反的方面转化。这些就是所谓同一性。<br>　　列宁说：“辩证法是这样的一种学说：它研究对立怎样能够是同一的，又怎样成为同一的（怎样变成同一的），——在怎样的条件之下它们互相转化，成为同一的，——为什么人的头脑不应当把这些对立看作死的、凝固的东西，而应当看作生动的、有条件的、可变动的、互相转化的东西。”（26）<br>　　列宁这段话是什么意思呢？<br>　　一切过程中矛盾着的各方面，本来是互相排斥、互相斗争、互相对立的。世界上一切事物的过程里和人们的思想里，都包含着这样带矛盾性的方面，无一例外。单纯的过程只有一对矛盾，复杂的过程则有一对以上的矛盾。各对矛盾之间，又互相成为矛盾。这样地组成客观世界的一切事物和人们的思想，并推使它们发生运动。<br>　　如此说来，只是极不同一，极不统一，怎样又说是同一或统一呢？<br>　　原来矛盾着的各方面，不能孤立地存在。假如没有和它作对的矛盾的一方，它自己这一方就失去了存在的条件。试想一切矛盾着的事物或人们心中矛盾着的概念，任何一方面能够独立地存在吗？没有生，死就不见；没有死，生也不见。没有上，无所谓下；没有下，也无所谓上。没有祸，无所谓福；没有福，也无所谓祸。没有顺利，无所谓困难；没有困难，也无所谓顺利。没有地主，就没有佃农；没有佃农，也就没有地主。没有资产阶级，就没有无产阶级；没有无产阶级，也就没有资产阶级。没有帝国主义的民族压迫，就没有殖民地和半殖民地；没有殖民地和半殖民地，也就没有帝国主义的民族压迫。一切对立的成分都是这样，因一定的条件，一面互相对立，一面又互相联结、互相贯通、互相渗透、互相依赖，这种性质，叫做同一性。一切矛盾着的方面都因一定条件具备着不同一性，所以称为矛盾。然而又具备着同一性，所以互相联结。列宁所谓辩证法研究“对立怎样能够是同一的”，就是说的这种情形。怎样能够呢？因为互为存在的条件。这是同一性的第一种意义。<br>　　然而单说了矛盾双方互为存在的条件，双方之间有同一性，因而能够共处于一个统一体中，这样就够了吗？还不够。事情不是矛盾双方互相依存就完了，更重要的，还在于矛盾着的事物的互相转化。这就是说，事物内部矛盾着的两方面，因为一定的条件而各向着和自己相反的方面转化了去，向着它的对立方面所处的地位转化了去。这就是矛盾的同一性的第二种意义。<br>　　为什么这里也有同一性呢？你们看，被统治的无产阶级经过革命转化为统治者，原来是统治者的资产阶级却转化为被统治者，转化到对方原来所占的地位。苏联已经是这样做了，全世界也将要这样做。试问其间没有在一定条件之下的联系和同一性，如何能够发生这样的变化呢？<br>　　曾在中国近代历史的一定阶段上起过某种积极作用的国民党，因为它的固有的阶级性和帝国主义的引诱（这些就是条件），在一九二七年以后转化为反革命，又由于中日矛盾的尖锐化和共产党的统一战线政策（这些就是条件），而被迫着赞成抗日。矛盾着的东西这一个变到那一个，其间包含了一定的同一性。<br>　　我们实行过的土地革命，已经是并且还将是这样的过程，拥有土地的地主阶级转化为失掉土地的阶级，而曾经是失掉土地的农民却转化为取得土地的小私有者。有无、得失之间，因一定条件而互相联结，二者具有同一性。在社会主义条件之下，农民的私有制又将转化为社会主义农业的公有制，苏联已经这样做了，全世界将来也会这样做。私产和公产之间有一条由此达彼的桥梁，哲学上名之曰同一性，或互相转化、互相渗透。<br>　　巩固无产阶级的专政或人民的专政，正是准备着取消这种专政，走到消灭任何国家制度的更高阶段去的条件。建立和发展共产党，正是准备着消灭共产党和一切政党制度的条件。建立共产党领导的革命军，进行革命战争，正是准备着永远消灭战争的条件。这许多相反的东西，同时却是相成的东西。<br>　　大家知道，战争与和平是互相转化的。战争转化为和平，例如第一次世界大战转化为战后的和平，中国的内战现在也停止了，出现了国内的和平。和平转化为战争，例如一九二七年的国共合作转化为战争，现在的世界和平局面也可能转化为第二次世界大战。为什么是这样？因为在阶级社会中战争与和平这样矛盾着的事物，在一定条件下具备着同一性。<br>　　一切矛盾着的东西，互相联系着，不但在一定条件之下共处于一个统一体中，而且在一定条件之下互相转化，这就是矛盾的同一性的全部意义。列宁所谓“怎样成为同一的（怎样变成同一的），——在怎样的条件之下它们互相转化，成为同一的”，就是这个意思。<br>　　“为什么人的头脑不应当把这些对立看作死的、凝固的东西，而应当看作生动的、有条件的、可变动的、互相转化的东西”呢？因为客观事物本来是如此的。客观事物中矛盾着的诸方面的统一或同一性，本来不是死的、凝固的，而是生动的、有条件的、可变动的、暂时的、相对的东西，一切矛盾都依一定条件向它们的反面转化着。这种情况，反映在人们的思想里，就成了马克思主义的唯物辩证法的宇宙观。只有现在的和历史上的反动的统治阶级以及为他们服务的形而上学，不是把对立的事物当作生动的、有条件的、可变动的、互相转化的东西去看，而是当作死的、凝固的东西去看，并且把这种错误的看法到处宣传，迷惑人民群众，以达其继续统治的目的。共产党人的任务就在于揭露反动派和形而上学的错误思想，宣传事物的本来的辩证法，促成事物的转化，达到革命的目的。<br>　　所谓矛盾在一定条件下的同一性，就是说，我们所说的矛盾乃是现实的矛盾，具体的矛盾，而矛盾的互相转化也是现实的、具体的。神话中的许多变化，例如《山海经》中所说的“夸父追日”（27），《淮南子》中所说的“羿射九日”（28），《西游记》中所说的孙悟空七十二变（29）和《聊斋志异》（30）中的许多鬼狐变人的故事等等，这种神话中所说的矛盾的互相变化，乃是无数复杂的现实矛盾的互相变化对于人们所引起的一种幼稚的、想象的、主观幻想的变化，并不是具体的矛盾所表现出来的具体的变化。马克思说：“任何神话都是用想象和借助想象以征服自然力，支配自然力，把自然力加以形象化；因而，随着这些自然力之实际上被支配，神话也就消失了。”（31）这种神话中的（还有童话中的）千变万化的故事，虽然因为它们想象出人们征服自然力等等，而能够吸引人们的喜欢，并且最好的神话具有“永久的魅力”（32）（马克思），但神话并不是根据具体的矛盾之一定的条件而构成的，所以它们并不是现实之科学的反映。这就是说，神话或童话中矛盾构成的诸方面，并不是具体的同一性，只是幻想的同一性。科学地反映现实变化的同一性的，就是马克思主义的辩证法。<br>　　为什么鸡蛋能够转化为鸡子，而石头不能够转化为鸡子呢？为什么战争与和平有同一性，而战争与石头却没有同一性呢？为什么人能生人不能生出其他的东西呢？没有别的，就是因为矛盾的同一性要在一定的必要的条件之下。缺乏一定的必要的条件，就没有任何的同一性。<br>　　为什么俄国在一九一七年二月的资产阶级民主革命和同年十月的无产阶级社会主义革命直接地联系着，而法国资产阶级革命没有直接地联系于社会主义的革命，一八七一年的巴黎公社终于失败了呢？为什么蒙古和中亚细亚的游牧制度又直接地和社会主义联系了呢？为什么中国的革命可以避免资本主义的前途，可以和社会主义直接联系起来，不要再走西方国家的历史老路，不要经过一个资产阶级专政的时期呢？没有别的，都是由于当时的具体条件。一定的必要的条件具备了，事物发展的过程就发生一定的矛盾，而且这种或这些矛盾互相依存，又互相转化，否则，一切都不可能。<br>　　同一性的问题如此。那末，什么是斗争性呢？同一性和斗争性的关系是怎样的呢？<br>　　列宁说：“对立的统一（一致、同一、合一），是有条件的、一时的、暂存的、相对的。互相排斥的对立的斗争则是绝对的，正如发展、运动是绝对的一样。”（33）<br>　　列宁这段话是什么意思呢？<br>　　一切过程都有始有终，一切过程都转化为它们的对立物。一切过程的常住性是相对的，但是一种过程转化为他种过程的这种变动性则是绝对的。<br>　　无论什么事物的运动都采取两种状态，相对地静止的状态和显著地变动的状态。两种状态的运动都是由事物内部包含的两个矛盾着的因素互相斗争所引起的。当着事物的运动在第一种状态的时候，它只有数量的变化，没有性质的变化，所以显出好似静止的面貌。当着事物的运动在第二种状态的时候，它已由第一种状态中的数量的变化达到了某一个最高点，引起了统一物的分解，发生了性质的变化，所以显出显著地变化的面貌。我们在日常生活中所看见的统一、团结、联合、调和、均势、相持、僵局、静止、有常、平衡、凝聚、吸引等等，都是事物处在量变状态中所显现的面貌。而统一物的分解，团结、联合、调和、均势、相持、僵局、静止、有常、平衡、凝聚、吸引等等状态的破坏，变到相反的状态，便都是事物在质变状态中、在一种过程过渡到他种过程的变化中所显现的面貌。事物总是不断地由第一种状态转化为第二种状态，而矛盾的斗争则存在于两种状态中，并经过第二种状态而达到矛盾的解决。所以说，对立的统一是有条件的、暂时的、相对的，而对立的互相排除的斗争则是绝对的。<br>　　前面我们曾经说，两个相反的东西中间有同一性，所以二者能够共处于一个统一体中，又能够互相转化，这是说的条件性，即是说在一定条件之下，矛盾的东西能够统一起来，又能够互相转化；无此一定条件，就不能成为矛盾，不能共居，也不能转化。由于一定的条件才构成了矛盾的同一性，所以说同一性是有条件的、相对的。这里我们又说，矛盾的斗争贯串于过程的始终，并使一过程向着他过程转化，矛盾的斗争无所不在，所以说矛盾的斗争性是无条件的、绝对的。<br>　　有条件的相对的同一性和无条件的绝对的斗争性相结合，构成了一切事物的矛盾运动。<br>　　我们中国人常说：“相反相成。”（34）就是说相反的东西有同一性。这句话是辩证法的，是违反形而上学的。“相反”就是说两个矛盾方面的互相排斥，或互相斗争。“相成”就是说在一定条件之下两个矛盾方面互相联结起来，获得了同一性。而斗争性即寓于同一性之中，没有斗争性就没有同一性。<br>　　在同一性中存在着斗争性，在特殊性中存在着普遍性，在个性中存在着共性。拿列宁的话来说，叫做“在相对的东西里面有着绝对的东西”（35）。   </p><h2 id="六-对抗在矛盾中的地位"><a href="#六-对抗在矛盾中的地位" class="headerlink" title="六　对抗在矛盾中的地位"></a>六　对抗在矛盾中的地位</h2><p>　　在矛盾的斗争性的问题中，包含着对抗是什么的问题。我们回答道：对抗是矛盾斗争的一种形式，而不是矛盾斗争的一切形式。<br>　　在人类历史中，存在着阶级的对抗，这是矛盾斗争的一种特殊的表现。剥削阶级和被剥削阶级之间的矛盾，无论在奴隶社会也好，封建社会也好，资本主义社会也好，互相矛盾着的两阶级，长期地并存于一个社会中，它们互相斗争着，但要待两阶级的矛盾发展到了一定的阶段的时候，双方才取外部对抗的形式，发展为革命。阶级社会中，由和平向战争的转化，也是如此。<br>　　炸弹在未爆炸的时候，是矛盾物因一定条件共居于一个统一体中的时候。待至新的条件（发火）出现，才发生了爆炸。自然界中一切到了最后要采取外部冲突形式去解决旧矛盾产生新事物的现象，都有与此相仿佛的情形。<br>　　认识这种情形，极为重要。它使我们懂得，在阶级社会中，革命和革命战争是不可避免的，舍此不能完成社会发展的飞跃，不能推翻反动的统治阶级，而使人民获得政权。共产党人必须揭露反动派所谓社会革命是不必要的和不可能的等等欺骗的宣传，坚持马克思列宁主义的社会革命论，使人民懂得，这不但是完全必要的，而且是完全可能的，整个人类的历史和苏联的胜利，都证明了这个科学的真理。<br>　　但是我们必须具体地研究各种矛盾斗争的情况，不应当将上面所说的公式不适当地套在一切事物的身上。矛盾和斗争是普遍的、绝对的，但是解决矛盾的方法，即斗争的形式，则因矛盾的性质不同而不相同。有些矛盾具有公开的对抗性，有些矛盾则不是这样。根据事物的具体发展，有些矛盾是由原来还非对抗性的，而发展成为对抗性的；也有些矛盾则由原来是对抗性的，而发展成为非对抗性的。<br>　　共产党内正确思想和错误思想的矛盾，如前所说，在阶级存在的时候，这是阶级矛盾对于党内的反映。这种矛盾，在开始的时候，或在个别的问题上，并不一定马上表现为对抗性的。但随着阶级斗争的发展，这种矛盾也就可能发展为对抗性的。苏联共产党的历史告诉我们：列宁、斯大林的正确思想和托洛茨基、布哈林等人的错误思想的矛盾，在开始的时候还没有表现为对抗的形式，但随后就发展为对抗的了。中国共产党的历史也有过这样的情形。我们党内许多同志的正确思想和陈独秀、张国焘（36）等人的错误思想的矛盾，在开始的时候也没有表现为对抗的形式，但随后就发展为对抗的了。目前我们党内的正确思想和错误思想的矛盾，没有表现为对抗的形式，如果犯错误的同志能够改正自己的错误，那就不会发展为对抗性的东西。因此，党一方面必须对于错误思想进行严肃的斗争，另方面又必须充分地给犯错误的同志留有自己觉悟的机会。在这样的情况下，过火的斗争，显然是不适当的。但如果犯错误的人坚持错误，并扩大下去，这种矛盾也就存在着发展为对抗性的东西的可能性。<br>　　经济上城市和乡村的矛盾，在资本主义社会里面（那里资产阶级统治的城市残酷地掠夺乡村），在中国的国民党统治区域里面（那里外国帝国主义和本国买办大资产阶级所统治的城市极野蛮地掠夺乡村），那是极其对抗的矛盾。但在社会主义国家里面，在我们的革命根据地里面，这种对抗的矛盾就变为非对抗的矛盾，而当到达共产主义社会的时候，这种矛盾就会消灭。<br>　　列宁说：“对抗和矛盾断然不同。在社会主义下，对抗消灭了，矛盾存在着。”（37）这就是说，对抗只是矛盾斗争的一种形式，而不是它的一切形式，不能到处套用这个公式。   </p><h2 id="七-结-论"><a href="#七-结-论" class="headerlink" title="七　结　　论"></a>七　结　　论</h2><p>　　说到这里，我们可以总起来说几句。事物矛盾的法则，即对立统一的法则，是自然和社会的根本法则，因而也是思维的根本法则。它是和形而上学的宇宙观相反的。它对于人类的认识史是一个大革命。按照辩证唯物论的观点看来，矛盾存在于一切客观事物和主观思维的过程中，矛盾贯串于一切过程的始终，这是矛盾的普遍性和绝对性。矛盾着的事物及其每一个侧面各有其特点，这是矛盾的特殊性和相对性。矛盾着的事物依一定的条件有同一性，因此能够共居于一个统一体中，又能够互相转化到相反的方面去，这又是矛盾的特殊性和相对性。然而矛盾的斗争则是不断的，不管在它们共居的时候，或者在它们互相转化的时候，都有斗争的存在，尤其是在它们互相转化的时候，斗争的表现更为显著，这又是矛盾的普遍性和绝对性。当着我们研究矛盾的特殊性和相对性的时候，要注意矛盾和矛盾方面的主要的和非主要的区别；当着我们研究矛盾的普遍性和斗争性的时候，要注意矛盾的各种不同的斗争形式的区别。否则就要犯错误。如果我们经过研究真正懂得了上述这些要点，我们就能够击破违反马克思列宁主义基本原则的不利于我们的革命事业的那些教条主义的思想；也能够使有经验的同志们整理自己的经验，使之带上原则性，而避免重复经验主义的错误。这些，就是我们研究矛盾法则的一些简单的结论。   </p><hr><p>　　注　　释<br>　　〔1〕 见列宁《黑格尔〈哲学史讲演录〉一书摘要》（《列宁全集》第55卷，人民出版社1990年版，第213页）。<br>　　〔2〕参见列宁《谈谈辩证法问题》：“统一物之分为两个部分以及对它的矛盾着的部分的认识……，是辩证法的实质（是辩证法的‘本质’之一，是它的基本的特点或特征之一，甚至可说是它的最基本的特点或特征）。”并参见《黑格尔〈逻辑学〉一书摘要》中关于“辩证法的要素”部分：“可以把辩证法简要地规定为关于对立面的统一的学说。这样就会抓住辩证法的核心，可是这需要说明和发挥。”（《列宁全集》第55卷，人民出版社1990年版，第305、192页）<br>　　〔3〕德波林（一八八一——一九六三），苏联哲学家。一九二九年当选为苏联科学院院士。三十年代初，苏联哲学界发动对德波林学派的批判，认为他们犯了理论脱离实践、哲学脱离政治等唯心主义性质的错误。<br>　　〔4〕见列宁《谈谈辩证法问题》。新的译文是：“有两种基本的（或两种可能的？或两种在历史上常见的？）发展（进化）观点：认为发展是减少和增加，是重复；以及认为发展是对立面的统一（统一物之分为两个互相排斥的对立面以及它们之间的相互关系）。”（《列宁全集》第55卷，人民出版社1990年版，第306页）<br>　　〔5〕见《汉书·董仲舒传》。董仲舒（公元前一七九——前一○四）是孔子学派在西汉的主要代表，他曾经对汉武帝说：“道之大原出于天，天不变，道亦不变。”“道”是中国古代哲学家的通用语，它的意义是“道路”或“道理”，可作“法则”或“规律”解说。<br>　　〔6〕 见恩格斯《反杜林论》第一编第十二节《辩证法。量和质》（《马克思恩格斯选集》第3卷，人民出版社1972年版，第160页）。<br>　　〔7〕见列宁《谈谈辩证法问题》。新的译文是：“承认（发现）自然界的（也包括精神的和社会的）一切现象和过程具有矛盾着的、相互排斥的、对立的倾向。”（《列宁全集》第55卷，人民出版社1990年版，第306页）<br>　　〔8〕以上所引恩格斯的三段话，均见恩格斯《反杜林论》第一编第十二节《辩证法。量和质》。其中第二段“高等数学的主要基础之一，就是矛盾……”，《反杜林论》中的原文是：“我们已经提到，高等数学的主要基础之一是这样一个矛盾：在一定条件下直线和曲线应当是一回事。高等数学还有另一个矛盾：在我们眼前相交的线，只要离开交点五六厘米，就应当认为是平行的、即使无限延长也不会相交的线。可是，高等数学利用这些和其他一些更加尖锐的矛盾获得了不仅是正确的、而且是初等数学所完全不能达到的成果。”（《马克思恩格斯选集》第3卷，人民出版社1972年版，第160—161页）<br>　　〔9〕 见列宁《谈谈辩证法问题》（《列宁全集》第55卷，人民出版社1990年版，第305—306页）。<br>　　〔10〕见列宁《谈谈辩证法问题》（《列宁全集》第55卷，人民出版社1990年版，第307页）。<br>　　〔11〕 参见本卷《中国革命战争的战略问题》注〔11〕。<br>　　〔12〕 见《孙子·谋攻》。<br>　　〔13〕 魏徵（五八○——六四三），唐代初期的政治活动家和历史学家。本文引语见《资治通鉴》卷一百九十二。<br>　　〔14〕《水浒传》是中国描写农民战争的著名小说。宋江是这部小说中农民武装的主要领袖。祝家庄在农民武装根据地梁山泊的附近，这个庄的统治者祝朝奉，是一个大恶霸地主。<br>　　〔15〕木马计是希腊神话中的一个著名故事。据传说，古希腊人攻打特洛伊城，很久打不下来。后来，他们伪装撤退，在城下营房中留下了一匹腹内藏有一批勇士的大木马。特洛伊人不知道这是敌人的计策，把木马作为战利品拉进城去。深夜，勇士们走出木马，利用特洛伊人毫无戒备的时机，配合城外的军队，迅速地夺取了特洛伊城。<br>　　〔16〕见列宁《再论工会、目前局势及托洛茨基同志和布哈林同志的错误》。新的译文是：“要真正地认识事物，就必须把握住、研究清楚它的一切方面、一切联系和‘中介’。我们永远也不会完全做到这一点，但是，全面性这一要求可以使我们防止犯错误和防止僵化。”（《列宁全集》第40卷，人民出版社1986年版，第291页）<br>　　〔17〕 见本卷《湖南农民运动考察报告》注〔3〕。<br>　　〔18〕 见本卷《论反对日本帝国主义的策略》注〔5〕。<br>　　〔19〕参见本卷《关于蒋介石声明的声明》注〔1〕。<br>　　〔20〕 见本卷《中国革命战争的战略问题》注〔4〕。<br>　　〔21〕见本卷《论反对日本帝国主义的策略》注〔35〕。<br>　　〔22〕一八九四年（甲午年）发生的中日战争，也称甲午战争。这次战争是日本军国主义者蓄意挑起的。日本军队先向朝鲜发动侵略并对中国的陆海军进行挑衅，继即大举侵入中国的东北。在战争中，中国军队曾经英勇作战，但是由于清朝政府的腐败以及缺乏坚决反对侵略的准备，中国方面遭到了失败。一八九五年，清朝政府和日本订立了可耻的马关条约，这个条约的主要内容是：中国割让台湾全岛及所有附属各岛屿、澎湖列岛和辽东半岛（后来在俄、德、法三国干涉下，日本同意由清政府偿付白银三千万两“赎还”该半岛），赔偿军费银二万万两，允许日本人在中国通商口岸开设工厂，开辟沙市、重庆、苏州、杭州等地为商埠。<br>　　〔23〕 见本卷《论反对日本帝国主义的策略》注〔37〕。<br>　　〔24〕 参见本卷《论反对日本帝国主义的策略》注〔22〕。<br>　　〔25〕见列宁《俄国社会民主党人的任务》（《列宁全集》第2卷，人民出版社1984年版，第443页）；并见列宁《怎么办？》第一章第四节（《列宁全集》第6卷，人民出版社1986年版，第23页）。<br>　　〔26〕见列宁《黑格尔〈逻辑学〉一书摘要》。新的译文是：“辩证法是一种学说，它研究对立面怎样才能够同一，是怎样（怎样成为）同一的——在什么条件下它们是相互转化而同一的，——为什么人的头脑不应该把这些对立面看作僵死的、凝固的东西，而应该看作活生生的、有条件的、活动的、彼此转化的东西。”（《列宁全集》第55卷，人民出版社1990年版，第90页）<br>　　〔27〕《山海经》是一部中国古代地理著作，其中记载了不少远古的神话传说。夸父是《山海经·海外北经》上记载的一个神人。据说：“夸父与日逐走。入日，渴欲得饮，饮于河渭。河渭不足，北饮大泽。未至，道渴而死。弃其杖，化为邓林。”<br>　　〔28〕羿是中国古代传说中的英雄，“射日”是关于他善射的著名故事。据西汉淮南王刘安（公元前二世纪人）及其门客所著《淮南子》一书说：“尧之时，十日并出，焦禾稼，杀草木，而民无所食。猰豸、凿齿、九婴、大风、封狶、修蛇，皆为民害。尧乃使羿……上射十日而下杀猰豸。……万民皆喜。”东汉著作家王逸（公元二世纪人）关于屈原诗篇《天问》的注释说：“淮南言，尧时十日并出，草木焦枯。尧命羿仰射十日，中其九日……留其一日。”<br>　　〔29〕《西游记》是明代作家吴承恩著的一部神话小说。孙悟空是书中的主角。他是一个神猴，有七十二变的法术，能够随意变成各式各样的鸟兽虫鱼草木器物或者人形。<br>　　〔30〕 《聊斋志异》是清代文学家蒲松龄著的短篇小说集，大部分是叙述神仙狐鬼的故事。<br>　　〔31〕见马克思《〈政治经济学批判〉导言》（《马克思恩格斯选集》第2卷，人民出版社1972年版，第113页）。<br>　　〔32〕见马克思《〈政治经济学批判〉导言》（《马克思恩格斯选集》第2卷，人民出版社1972年版，第114页）。<br>　　〔33〕见列宁《谈谈辩证法问题》。新的译文是：“对立面的统一（一致、同一、均势）是有条件的、暂时的、易逝的、相对的。相互排斥的对立面的斗争是绝对的，正如发展、运动是绝对的一样。”（《列宁全集》第55卷，人民出版社1990年版，第306页）<br>　　〔34〕见东汉著名史学家班固（三二——九二）所著《汉书·艺文志》，原文是：“诸子十家，其可观者，九家而已。皆起于王道既微，诸侯力政，时君世主，好恶殊方。是以九家之术，蜂出并作，各引一端，崇其所善，以此驰说，取合诸侯。其言虽殊，辟犹水火，相灭亦相生也。仁之与义，敬之与和，相反而皆相成也。”<br>　　〔35〕 见列宁《谈谈辩证法问题》。新的译文是：“相对中有绝对。”（《列宁全集》第55卷，人民出版社1990年版，第307页）<br>　　〔36〕见本卷《论反对日本帝国主义的策略》注〔24〕。<br>　　〔37〕见列宁《在尼·布哈林〈过渡时期经济学〉一书上作的批注和评论》（《列宁全集》第60卷，人民出版社1990年版，第282页）。   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;矛盾论&quot;&gt;&lt;a href=&quot;#矛盾论&quot; class=&quot;headerlink&quot; title=&quot;矛盾论&quot;&gt;&lt;/a&gt;矛盾论&lt;/h3&gt;&lt;p&gt;(一九三七年八月）  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇哲学论文，是毛泽东继《实践论》之后，为了同一的目的，即为了克服存
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>(转)实践论</title>
    <link href="http://wujingchao.github.io/2020/10/05/practice/"/>
    <id>http://wujingchao.github.io/2020/10/05/practice/</id>
    <published>2020-10-05T03:49:39.000Z</published>
    <updated>2024-12-07T09:28:42.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实践论"><a href="#实践论" class="headerlink" title="实践论"></a>实践论</h3><h4 id="论认识和实践的关系——知和行的关系"><a href="#论认识和实践的关系——知和行的关系" class="headerlink" title="论认识和实践的关系——知和行的关系"></a>论认识和实践的关系——知和行的关系</h4><p>（一九三七年七月）  </p><blockquote><p>在中国共产党内，曾经有一部分教条主义的同志长期拒绝中国革命的经验，否认“马克思主义不是教条而是行动的指南”这个真理，而只生吞活剥马克思主义书籍中的只言片语，去吓唬人们。还有另一部分经验主义的同志长期拘守于自身的片断经验，不了解理论对于革命实践的重要性，看不见革命的全局，虽然也是辛苦地——但却是盲目地在工作。这两类同志的错误思想，特别是教条主义思想，曾经在一九三一年至一九三四年使得中国革命受了极大的损失，而教条主义者却是披着马克思主义的外衣迷惑了广大的同志。毛泽东的《实践论》，是为着用马克思主义的认识论观点去揭露党内的教条主义和经验主义——特别是教条主义这些主观主义的错误而写的。因为重点是揭露看轻实践的教条主义这种主观主义，故题为《实践论》。毛泽东曾以这篇论文的观点在延安的抗日军事政治大学作过讲演。</p></blockquote><p>　　马克思以前的唯物论，离开人的社会性，离开人的历史发展，去观察认识问题，因此不能了解认识对社会实践的依赖关系，即认识对生产和阶级斗争的依赖关系。<br>　　首先，马克思主义者认为人类的生产活动是最基本的实践活动，是决定其他一切活动的东西。人的认识，主要地依赖于物质的生产活动，逐渐地了解自然的现象、自然的性质、自然的规律性、人和自然的关系；而且经过生产活动，也在各种不同程度上逐渐地认识了人和人的一定的相互关系。一切这些知识，离开生产活动是不能得到的。在没有阶级的社会中，每个人以社会一员的资格，同其他社会成员协力，结成一定的生产关系，从事生产活动，以解决人类物质生活问题。在各种阶级的社会中，各阶级的社会成员，则又以各种不同的方式，结成一定的生产关系，从事生产活动，以解决人类物质生活问题。这是人的认识发展的基本来源。<br>　　人的社会实践，不限于生产活动一种形式，还有多种其他的形式，阶级斗争，政治生活，科学和艺术的活动，总之社会实际生活的一切领域都是社会的人所参加的。因此，人的认识，在物质生活以外，还从政治生活文化生活中（与物质生活密切联系），在各种不同程度上，知道人和人的各种关系。其中，尤以各种形式的阶级斗争，给予人的认识发展以深刻的影响。在阶级社会中，每一个人都在一定的阶级地位中生活，各种思想无不打上阶级的烙印。<br>　　马克思主义者认为人类社会的生产活动，是一步又一步地由低级向高级发展，因此，人们的认识，不论对于自然界方面，对于社会方面，也都是一步又一步地由低级向高级发展，即由浅入深，由片面到更多的方面。在很长的历史时期内，大家对于社会的历史只能限于片面的了解，这一方面是由于剥削阶级的偏见经常歪曲社会的历史，另方面，则由于生产规模的狭小，限制了人们的眼界。人们能够对于社会历史的发展作全面的历史的了解，把对于社会的认识变成了科学，这只是到了伴随巨大生产力——大工业而出现近代无产阶级的时候，这就是马克思主义的科学。<br>　　马克思主义者认为，只有人们的社会实践，才是人们对于外界认识的真理性的标准。实际的情形是这样的，只有在社会实践过程中（物质生产过程中，阶级斗争过程中，科学实验过程中），人们达到了思想中所预想的结果时，人们的认识才被证实了。人们要想得到工作的胜利即得到预想的结果，一定要使自己的思想合于客观外界的规律性，如果不合，就会在实践中失败。人们经过失败之后，也就从失败取得教训，改正自己的思想使之适合于外界的规律性，人们就能变失败为胜利，所谓“失败者成功之母”，“吃一堑长一智”，就是这个道理。辩证唯物论的认识论把实践提到第一的地位，认为人的认识一点也不能离开实践，排斥一切否认实践重要性、使认识离开实践的错误理论。列宁这样说过：“实践高于（理论的）认识，因为它不但有普遍性的品格，而且还有直接现实性的品格。”⑴马克思主义的哲学辩证唯物论有两个最显著的特点：一个是它的阶级性，公然申明辩证唯物论是为无产阶级服务的；再一个是它的实践性，强调理论对于实践的依赖关系，理论的基础是实践，又转过来为实践服务。判定认识或理论之是否真理，不是依主观上觉得如何而定，而是依客观上社会实践的结果如何而定。真理的标准只能是社会的实践。实践的观点是辩证唯物论的认识论之第一的和基本的观点⑵。<br>　　然而人的认识究竟怎样从实践发生，而又服务于实践呢？这只要看一看认识的发展过程就会明了的。<br>　　原来人在实践过程中，开始只是看到过程中各个事物的现象方面，看到各个事物的片面，看到各个事物之间的外部联系。例如有些外面的人们到延安来考察，头一二天，他们看到了延安的地形、街道、屋宇，接触了许多的人，参加了宴会、晚会和群众大会，听到了各种说话，看到了各种文件，这些就是事物的现象，事物的各个片面以及这些事物的外部联系。这叫做认识的感性阶段，就是感觉和印象的阶段。也就是延安这些各别的事物作用于考察团先生们的感官，引起了他们的感觉，在他们的脑子中生起了许多的印象，以及这些印象间的大概的外部的联系，这是认识的第一个阶段。在这个阶段中，人们还不能造成深刻的概念，作出合乎论理（即合乎逻辑）的结论。<br>　　社会实践的继续，使人们在实践中引起感觉和印象的东西反复了多次，于是在人们的脑子里生起了一个认识过程中的突变（即飞跃），产生了概念。概念这种东西已经不是事物的现象，不是事物的各个片面，不是它们的外部联系，而是抓着了事物的本质，事物的全体，事物的内部联系了。概念同感觉，不但是数量上的差别，而且有了性质上的差别。循此继进，使用判断和推理的方法，就可产生出合乎论理的结论来。《三国演义》上所谓“眉头一皱计上心来”，我们普通说话所谓“让我想一想”，就是人在脑子中运用概念以作判断和推理的工夫。这是认识的第二个阶段。外来的考察团先生们在他们集合了各种材料，加上他们“想了一想”之后，他们就能够作出“共产党的抗日民族统一战线的政策是彻底的、诚恳的和真实的”这样一个判断了。在他们作出这个判断之后，如果他们对于团结救国也是真实的的话，那末他们就能够进一步作出这样的结论：“抗日民族统一战线是能够成功的。”这个概念、判断和推理的阶段，在人们对于一个事物的整个认识过程中是更重要的阶段，也就是理性认识的阶段。认识的真正任务在于经过感觉而到达于思维，到达于逐步了解客观事物的内部矛盾，了解它的规律性，了解这一过程和那一过程间的内部联系，即到达于论理的认识。重复地说，论理的认识所以和感性的认识不同，是因为感性的认识是属于事物之片面的、现象的、外部联系的东西，论理的认识则推进了一大步，到达了事物的全体的、本质的、内部联系的东西，到达了暴露周围世界的内在的矛盾，因而能在周围世界的总体上，在周围世界一切方面的内部联系上去把握周围世界的发展。<br>　　这种基于实践的由浅入深的辩证唯物论的关于认识发展过程的理论，在马克思主义以前，是没有一个人这样解决过的。马克思主义的唯物论，第一次正确地解决了这个问题，唯物地而且辩证地指出了认识的深化的运动，指出了社会的人在他们的生产和阶级斗争的复杂的、经常反复的实践中，由感性认识到论理认识的推移的运动。列宁说过：“物质的抽象，自然规律的抽象，价值的抽象以及其他等等，一句话，一切科学的（正确的、郑重的、非瞎说的）抽象，都更深刻、更正确、更完全地反映着自然。”⑶马克思列宁主义认为：认识过程中两个阶段的特性，在低级阶段，认识表现为感性的，在高级阶段，认识表现为论理的，但任何阶段，都是统一的认识过程中的阶段。感性和理性二者的性质不同，但又不是互相分离的，它们在实践的基础上统一起来了。我们的实践证明：感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻地感觉它。感觉只解决现象问题，理论才解决本质问题。这些问题的解决，一点也不能离开实践。无论何人要认识什么事物，除了同那个事物接触，即生活于（实践于）那个事物的环境中，是没有法子解决的。不能在封建社会就预先认识资本主义社会的规律，因为资本主义还未出现，还无这种实践。马克思主义只能是资本主义社会的产物。马克思不能在自由资本主义时代就预先具体地认识帝国主义时代的某些特异的规律，因为帝国主义这个资本主义最后阶段还未到来，还无这种实践，只有列宁和斯大林才能担当此项任务。马克思、恩格斯、列宁、斯大林之所以能够作出他们的理论，除了他们的天才条件之外，主要地是他们亲自参加了当时的阶级斗争和科学实验的实践，没有这后一个条件，任何天才也是不能成功的。“秀才不出门，全知天下事”，在技术不发达的古代只是一句空话，在技术发达的现代虽然可以实现这句话，然而真正亲知的是天下实践着的人，那些人在他们的实践中间取得了“知”，经过文字和技术的传达而到达于“秀才”之手，秀才乃能间接地“知天下事”。如果要直接地认识某种或某些事物，便只有亲身参加于变革现实、变革某种或某些事物的实践的斗争中，才能触到那种或那些事物的现象，也只有在亲身参加变革现实的实践的斗争中，才能暴露那种或那些事物的本质而理解它们。这是任何人实际上走着的认识路程，不过有些人故意歪曲地说些反对的话罢了。世上最可笑的是那些“知识里手”⑷，有了道听途说的一知半解，便自封为“天下第一”，适足见其不自量而已。知识的问题是一个科学问题，来不得半点的虚伪和骄傲，决定地需要的倒是其反面——诚实和谦逊的态度。你要有知识，你就得参加变革现实的实践。你要知道梨子的滋味，你就得变革梨子，亲口吃一吃。你要知道原子的组织同性质，你就得实行物理学和化学的实验，变革原子的情况。你要知道革命的理论和方法，你就得参加革命。一切真知都是从直接经验发源的。但人不能事事直接经验，事实上多数的知识都是间接经验的东西，这就是一切古代的和外域的知识。这些知识在古人在外人是直接经验的东西，如果在古人外人直接经验时是符合于列宁所说的条件“科学的抽象”，是科学地反映了客观的事物，那末这些知识是可靠的，否则就是不可靠的。所以，一个人的知识，不外直接经验的和间接经验的两部分。而且在我为间接经验者，在人则仍为直接经验。因此，就知识的总体说来，无论何种知识都是不能离开直接经验的。任何知识的来源，在于人的肉体感官对客观外界的感觉，否认了这个感觉，否认了直接经验，否认亲自参加变革现实的实践，他就不是唯物论者。“知识里手”之所以可笑，原因就是在这个地方。中国人有一句老话：“不入虎穴，焉得虎子。”这句话对于人们的实践是真理，对于认识论也是真理。离开实践的认识是不可能的。<br>　　为了明了基于变革现实的实践而产生的辩证唯物论的认识运动——认识的逐渐深化的运动，下面再举出几个具体的例子。<br>　　无产阶级对于资本主义社会的认识，在其实践的初期——破坏机器和自发斗争时期，他们还只在感性认识的阶段，只认识资本主义各个现象的片面及其外部的联系。这时，他们还是一个所谓“自在的阶级”。但是到了他们实践的第二个时期——有意识有组织的经济斗争和政治斗争的时期，由于实践，由于长期斗争的经验，经过马克思、恩格斯用科学的方法把这种种经验总结起来，产生了马克思主义的理论，用以教育无产阶级，这样就使无产阶级理解了资本主义社会的本质，理解了社会阶级的剥削关系，理解了无产阶级的历史任务，这时他们就变成了一个“自为的阶级”。<br>　　中国人民对于帝国主义的认识也是这样。第一阶段是表面的感性的认识阶段，表现在太平天国运动和义和团运动等笼统的排外主义的斗争上⑸。第二阶段才进到理性的认识阶段，看出了帝国主义内部和外部的各种矛盾，并看出了帝国主义联合中国买办阶级和封建阶级以压榨中国人民大众的实质，这种认识是从一九一九年五四运动⑹前后才开始的。<br>　　我们再来看战争。战争的领导者，如果他们是一些没有战争经验的人，对于一个具体的战争（例如我们过去十年的土地革命战争）的深刻的指导规律，在开始阶段是不了解的。他们在开始阶段只是身历了许多作战的经验，而且败仗是打得很多的。然而由于这些经验（胜仗，特别是败仗的经验），使他们能够理解贯串整个战争的内部的东西，即那个具体战争的规律性，懂得了战略和战术，因而能够有把握地去指导战争。此时，如果改换一个无经验的人去指导，又会要在吃了一些败仗之后（有了经验之后）才能理会战争的正确的规律。<br>　　常常听到一些同志在不能勇敢接受工作任务时说出来的一句话：没有把握。为什么没有把握呢？因为他对于这项工作的内容和环境没有规律性的了解，或者他从来就没有接触过这类工作，或者接触得不多，因而无从谈到这类工作的规律性。及至把工作的情况和环境给以详细分析之后，他就觉得比较地有了把握，愿意去做这项工作。如果这个人在这项工作中经过了一个时期，他有了这项工作的经验了，而他又是一个肯虚心体察情况的人，不是一个主观地、片面地、表面地看问题的人，他就能够自己做出应该怎样进行工作的结论，他的工作勇气也就可以大大地提高了。只有那些主观地、片面地和表面地看问题的人，跑到一个地方，不问环境的情况，不看事情的全体（事情的历史和全部现状），也不触到事情的本质（事情的性质及此一事情和其他事情的内部联系），就自以为是地发号施令起来，这样的人是没有不跌交子的。<br>　　由此看来，认识的过程，第一步，是开始接触外界事情，属于感觉的阶段。第二步，是综合感觉的材料加以整理和改造，属于概念、判断和推理的阶段。只有感觉的材料十分丰富（不是零碎不全）和合于实际（不是错觉），才能根据这样的材料造出正确的概念和论理来。<br>　　这里有两个要点必须着重指明。第一个，在前面已经说过的，这里再重复说一说，就是理性认识依赖于感性认识的问题。如果以为理性认识可以不从感性认识得来，他就是一个唯心论者。哲学史上有所谓“唯理论”一派，就是只承认理性的实在性，不承认经验的实在性，以为只有理性靠得住，而感觉的经验是靠不住的，这一派的错误在于颠倒了事实。理性的东西所以靠得住，正是由于它来源于感性，否则理性的东西就成了无源之水，无本之木，而只是主观自生的靠不住的东西了。从认识过程的秩序说来，感觉经验是第一的东西，我们强调社会实践在认识过程中的意义，就在于只有社会实践才能使人的认识开始发生，开始从客观外界得到感觉经验。一个闭目塞听、同客观外界根本绝缘的人，是无所谓认识的。认识开始于经验——这就是认识论的唯物论。<br>　　第二是认识有待于深化，认识的感性阶段有待于发展到理性阶段——这就是认识论的辩证法⑺。如果以为认识可以停顿在低级的感性阶段，以为只有感性认识可靠，而理性认识是靠不住的，这便是重复了历史上的“经验论”的错误。这种理论的错误，在于不知道感觉材料固然是客观外界某些真实性的反映（我这里不来说经验只是所谓内省体验的那种唯心的经验论），但它们仅是片面的和表面的东西，这种反映是不完全的，是没有反映事物本质的。要完全地反映整个的事物，反映事物的本质，反映事物的内部规律性，就必须经过思考作用，将丰富的感觉材料加以去粗取精、去伪存真、由此及彼、由表及里的改造制作工夫，造成概念和理论的系统，就必须从感性认识跃进到理性认识。这种改造过的认识，不是更空虚了更不可靠了的认识，相反，只要是在认识过程中根据于实践基础而科学地改造过的东西，正如列宁所说乃是更深刻、更正确、更完全地反映客观事物的东西。庸俗的事务主义家不是这样，他们尊重经验而看轻理论，因而不能通观客观过程的全体，缺乏明确的方针，没有远大的前途，沾沾自喜于一得之功和一孔之见。这种人如果指导革命，就会引导革命走上碰壁的地步。<br>　　理性认识依赖于感性认识，感性认识有待于发展到理性认识，这就是辩证唯物论的认识论。哲学上的“唯理论”和“经验论”都不懂得认识的历史性或辩证性，虽然各有片面的真理（对于唯物的唯理论和经验论而言，非指唯心的唯理论和经验论），但在认识论的全体上则都是错误的。由感性到理性之辩证唯物论的认识运动，对于一个小的认识过程（例如对于一个事物或一件工作的认识）是如此，对于一个大的认识过程（例如对于一个社会或一个革命的认识）也是如此。<br>　　然而认识运动至此还没有完结。辩证唯物论的认识运动，如果只到理性认识为止，那末还只说到问题的一半。而且对于马克思主义的哲学说来，还只说到非十分重要的那一半。马克思主义的哲学认为十分重要的问题，不在于懂得了客观世界的规律性，因而能够解释世界，而在于拿了这种对于客观规律性的认识去能动地改造世界。在马克思主义看来，理论是重要的，它的重要性充分地表现在列宁说过的一句话：“没有革命的理论，就不会有革命的运动。”⑻然而马克思主义看重理论，正是，也仅仅是，因为它能够指导行动。如果有了正确的理论，只是把它空谈一阵，束之高阁，并不实行，那末，这种理论再好也是没有意义的。认识从实践始，经过实践得到了理论的认识，还须再回到实践去。认识的能动作用，不但表现于从感性的认识到理性的认识之能动的飞跃，更重要的还须表现于从理性的认识到革命的实践这一个飞跃。抓着了世界的规律性的认识，必须把它再回到改造世界的实践中去，再用到生产的实践、革命的阶级斗争和民族斗争的实践以及科学实验的实践中去。这就是检验理论和发展理论的过程，是整个认识过程的继续。理论的东西之是否符合于客观真理性这个问题，在前面说的由感性到理性之认识运动中是没有完全解决的，也不能完全解决的。要完全地解决这个问题，只有把理性的认识再回到社会实践中去，应用理论于实践，看它是否能够达到预想的目的。许多自然科学理论之所以被称为真理，不但在于自然科学家们创立这些学说的时候，而且在于为尔后的科学实践所证实的时候。马克思列宁主义之所以被称为真理，也不但在于马克思、恩格斯、列宁、斯大林等人科学地构成这些学说的时候，而且在于为尔后革命的阶级斗争和民族斗争的实践所证实的时候。辩证唯物论之所以为普遍真理，在于经过无论什么人的实践都不能逃出它的范围。人类认识的历史告诉我们，许多理论的真理性是不完全的，经过实践的检验而纠正了它们的不完全性。许多理论是错误的，经过实践的检验而纠正其错误。所谓实践是真理的标准，所谓“生活、实践底观点，应该是认识论底首先的和基本的观点”⑼，理由就在这个地方。斯大林说得好：“理论若不和革命实践联系起来，就会变成无对象的理论，同样，实践若不以革命理论为指南，就会变成盲目的实践。”⑽<br>　　说到这里，认识运动就算完成了吗？我们的答复是完成了，又没有完成。社会的人们投身于变革在某一发展阶段内的某一客观过程的实践中（不论是关于变革某一自然过程的实践，或变革某一社会过程的实践），由于客观过程的反映和主观能动性的作用，使得人们的认识由感性的推移到了理性的，造成了大体上相应于该客观过程的法则性的思想、理论、计划或方案，然后再应用这种思想、理论、计划或方案于该同一客观过程的实践，如果能够实现预想的目的，即将预定的思想、理论、计划、方案在该同一过程的实践中变为事实，或者大体上变为事实，那末，对于这一具体过程的认识运动算是完成了。例如，在变革自然的过程中，某一工程计划的实现，某一科学假想的证实，某一器物的制成，某一农产的收获，在变革社会过程中某一罢工的胜利，某一战争的胜利，某一教育计划的实现，都算实现了预想的目的。然而一般地说来，不论在变革自然或变革社会的实践中，人们原定的思想、理论、计划、方案，毫无改变地实现出来的事，是很少的。这是因为从事变革现实的人们，常常受着许多的限制，不但常常受着科学条件和技术条件的限制，而且也受着客观过程的发展及其表现程度的限制（客观过程的方面及本质尚未充分暴露）。在这种情形之下，由于实践中发现前所未料的情况，因而部分地改变思想、理论、计划、方案的事是常有的，全部地改变的事也是有的。即是说，原定的思想、理论、计划、方案，部分地或全部地不合于实际，部分错了或全部错了的事，都是有的。许多时候须反复失败过多次，才能纠正错误的认识，才能到达于和客观过程的规律性相符合，因而才能够变主观的东西为客观的东西，即在实践中得到预想的结果。但是不管怎样，到了这种时候，人们对于在某一发展阶段内的某一客观过程的认识运动，算是完成了。<br>　　然而对于过程的推移而言，人们的认识运动是没有完成的。任何过程，不论是属于自然界的和属于社会的，由于内部的矛盾和斗争，都是向前推移向前发展的，人们的认识运动也应跟着推移和发展。依社会运动来说，真正的革命的指导者，不但在于当自己的思想、理论、计划、方案有错误时须得善于改正，如同上面已经说到的，而且在于当某一客观过程已经从某一发展阶段向另一发展阶段推移转变的时候，须得善于使自己和参加革命的一切人员在主观认识上也跟着推移转变，即是要使新的革命任务和新的工作方案的提出，适合于新的情况的变化。革命时期情况的变化是很急速的，如果革命党人的认识不能随之而急速变化，就不能引导革命走向胜利。<br>　　然而思想落后于实际的事是常有的，这是因为人的认识受了许多社会条件的限制的缘故。我们反对革命队伍中的顽固派，他们的思想不能随变化了的客观情况而前进，在历史上表现为右倾机会主义。这些人看不出矛盾的斗争已将客观过程推向前进了，而他们的认识仍然停止在旧阶段。一切顽固党的思想都有这样的特征。他们的思想离开了社会的实践，他们不能站在社会车轮的前头充任向导的工作，他们只知跟在车子后面怨恨车子走得太快了，企图把它向后拉，开倒车。<br>　　我们也反对“左”翼空谈主义。他们的思想超过客观过程的一定发展阶段，有些把幻想看作真理，有些则把仅在将来有现实可能性的理想，勉强地放在现时来做，离开了当前大多数人的实践，离开了当前的现实性，在行动上表现为冒险主义。<br>　　唯心论和机械唯物论，机会主义和冒险主义，都是以主观和客观相分裂，以认识和实践相脱离为特征的。以科学的社会实践为特征的马克思列宁主义的认识论，不能不坚决反对这些错误思想。马克思主义者承认，在绝对的总的宇宙发展过程中，各个具体过程的发展都是相对的，因而在绝对真理的长河中，人们对于在各个一定发展阶段上的具体过程的认识只具有相对的真理性。无数相对的真理之总和，就是绝对的真理⑾。客观过程的发展是充满着矛盾和斗争的发展，人的认识运动的发展也是充满着矛盾和斗争的发展。一切客观世界的辩证法的运动，都或先或后地能够反映到人的认识中来。社会实践中的发生、发展和消灭的过程是无穷的，人的认识的发生、发展和消灭的过程也是无穷的。根据于一定的思想、理论、计划、方案以从事于变革客观现实的实践，一次又一次地向前，人们对于客观现实的认识也就一次又一次地深化。客观现实世界的变化运动永远没有完结，人们在实践中对于真理的认识也就永远没有完结。马克思列宁主义并没有结束真理，而是在实践中不断地开辟认识真理的道路。我们的结论是主观和客观、理论和实践、知和行的具体的历史的统一，反对一切离开具体历史的“左”的或右的错误思想。<br>　　社会的发展到了今天的时代，正确地认识世界和改造世界的责任，已经历史地落在无产阶级及其政党的肩上。这种根据科学认识而定下来的改造世界的实践过程，在世界、在中国均已到达了一个历史的时节——自有历史以来未曾有过的重大时节，这就是整个儿地推翻世界和中国的黑暗面，把它们转变过来成为前所未有的光明世界。无产阶级和革命人民改造世界的斗争，包括实现下述的任务：改造客观世界，也改造自己的主观世界——改造自己的认识能力，改造主观世界同客观世界的关系。地球上已经有一部分实行了这种改造，这就是苏联。他们还正在促进这种改造过程。中国人民和世界人民也都正在或将要通过这样的改造过程。所谓被改造的客观世界，其中包括了一切反对改造的人们，他们的被改造，须要通过强迫的阶段，然后才能进入自觉的阶段。世界到了全人类都自觉地改造自己和改造世界的时候，那就是世界的共产主义时代。<br>　　通过实践而发现真理，又通过实践而证实真理和发展真理。从感性认识而能动地发展到理性认识，又从理性认识而能动地指导革命实践，改造主观世界和客观世界。实践、认识、再实践、再认识，这种形式，循环往复以至无穷，而实践和认识之每一循环的内容，都比较地进到了高一级的程度。这就是辩证唯物论的全部认识论，这就是辩证唯物论的知行统一观。   </p><hr><p>　　注　　释<br>　　〔1〕见列宁《黑格尔〈逻辑学〉一书摘要》。新的译文是：“实践高于（理论的）认识，因为它不仅具有普遍性的品格，而且还具有直接现实性的品格。”（《列宁全集》第55卷，人民出版社1990年版，第183页）<br>　　〔2〕参见马克思《关于费尔巴哈的提纲》（《马克思恩格斯选集》第1卷，人民出版社1972年版，第16—19页）和列宁《唯物主义和经验批判主义》第二章第六节（《列宁全集》第18卷，人民出版社1988年版，第144页）。<br>　　〔3〕 见列宁《黑格尔〈逻辑学〉一书摘要》（《列宁全集》第55卷，人民出版社1990年版，第142页）。<br>　　〔4〕里手，湖南方言，内行的意思。<br>　　〔5〕一九五一年三月二十七日，毛泽东在致李达的信中说：“《实践论》中将太平天国放在排外主义一起说不妥，出选集时拟加修改，此处暂仍照原。”<br>　　〔6〕五四运动是一九一九年五月四日发生的反帝反封建的爱国运动。当时，第一次世界大战刚刚结束，英、美、法、日、意等战胜国在巴黎召开对德和会，决定由日本继承德国在中国山东的特权。中国是参加对德宣战的战胜国之一，但北洋军阀政府却准备接受这个决定。五月四日，北京学生游行示威，反对帝国主义的这一无理决定和北洋军阀政府的妥协。这次运动迅速地获得了全国人民的响应，到六月三日以后，发展成为有工人阶级、城市小资产阶级和民族资产阶级参加的广大群众性的反帝反封建的爱国运动。五四运动也是反对封建文化的新文化运动。以一九一五年《青年杂志》（后改名《新青年》）创刊为起点的新文化运动，竖起“民主”和“科学”的旗帜，反对旧道德，提倡新道德，反对旧文学，提倡新文学。五四运动中的先进分子接受了马克思主义，使新文化运动发展成为马克思主义思想运动，他们致力于马克思主义同中国工人运动相结合，在思想上和干部上准备了中国共产党的成立。<br>　　〔7〕参见列宁《黑格尔〈逻辑学〉一书摘要》：“要理解，就必须从经验开始理解、研究，从经验上升到一般。”（《列宁全集》第55卷，人民出版社1990年版，第175页）<br>　　〔8〕见列宁《俄国社会民主党人的任务》（《列宁全集》第2卷，人民出版社1984年版，第443页）；并见列宁《怎么办？》第一章第四节（《列宁全集》第6卷，人民出版社1986年版，第23页）。<br>　　〔9〕 见列宁《唯物主义和经验批判主义》第二章第六节（《列宁全集》第18卷，人民出版社1988年版，第144页）。<br>　　〔10〕见斯大林《论列宁主义基础》第三部分《理论》。新的译文是：“离开革命实践的理论是空洞的理论，而不以革命理论为指南的实践是盲目的实践。”（《斯大林选集》上卷，人民出版社1979年版，第199—200页）<br>　　〔11〕参见列宁《唯物主义和经验批判主义》第二章第五节。原文是：“人类思维按其本性是能够给我们提供并且正在提供由相对真理的总和所构成的绝对真理的。”（《列宁全集》第18卷，人民出版社1988年版，第135页）   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实践论&quot;&gt;&lt;a href=&quot;#实践论&quot; class=&quot;headerlink&quot; title=&quot;实践论&quot;&gt;&lt;/a&gt;实践论&lt;/h3&gt;&lt;h4 id=&quot;论认识和实践的关系——知和行的关系&quot;&gt;&lt;a href=&quot;#论认识和实践的关系——知和行的关系&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一次技术分享:Android分区存储</title>
    <link href="http://wujingchao.github.io/2020/09/09/scope-storage/"/>
    <id>http://wujingchao.github.io/2020/09/09/scope-storage/</id>
    <published>2020-09-08T16:00:00.000Z</published>
    <updated>2024-12-07T09:31:05.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一次技术分享-Android分区存储"><a href="#一次技术分享-Android分区存储" class="headerlink" title="一次技术分享:Android分区存储"></a>一次技术分享:Android分区存储</h3><p><a href="https://view.officeapps.live.com/op/view.aspx?src=https://github.com/wujingchao/wujingchao.github.io/blob/master/assets/scope-storage.pptx?raw=true">PPT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一次技术分享-Android分区存储&quot;&gt;&lt;a href=&quot;#一次技术分享-Android分区存储&quot; class=&quot;headerlink&quot; title=&quot;一次技术分享:Android分区存储&quot;&gt;&lt;/a&gt;一次技术分享:Android分区存储&lt;/h3&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="scope" scheme="http://wujingchao.github.io/tags/scope/"/>
    
  </entry>
  
  <entry>
    <title>Ray Dalio 《原则》</title>
    <link href="http://wujingchao.github.io/2020/05/04/principle/"/>
    <id>http://wujingchao.github.io/2020/05/04/principle/</id>
    <published>2020-05-03T16:00:00.000Z</published>
    <updated>2024-12-07T09:29:04.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ray-Dalio-《原则》"><a href="#Ray-Dalio-《原则》" class="headerlink" title="Ray Dalio 《原则》"></a>Ray Dalio 《原则》</h3><ul><li>拥抱现实，应对现实<ul><li>做一个超级现实的人<ul><li>梦想+现实+决心=成功的生活</li></ul></li><li>真相是任何良好结果的根本依据</li><li>做到头脑极度开放、极度透明<ul><li>对于快速学习和有效改变而言，头脑极度开放、极度透明是价值无限的</li><li>不要担心其他人的看法，使之成为你的障碍</li><li>拥抱极度求真和极度透明将带来更有意义的工作和更有意义的人际关系</li></ul></li><li>观察自然，学习现实规律<ul><li>不要固守你对事物”应该“是什么样的看法，这将使你无法了解真实的情况</li><li>一个东西要”好“，就必须符合现实的规律，并促进整体的进化，这能带来最大的回报</li><li>进化是宇宙中最强大的力量，是唯一永恒的东西，是一切的驱动力</li><li>不进化就死亡</li></ul></li><li>进化是生命最大的成就和最大的回报<ul><li>个体的激励机制必须符合群体的目标</li><li>现实为了整体趋向最优化，而不是为了个体</li><li>通过快速试错以适应现实是无价的</li><li>意识到你既是一切又什么都不是，并决定你想成为什么样子</li><li>你的未来取决于你的视角</li></ul></li><li>理解自然提供的现实教训<ul><li>把你的进化最大化</li><li>记住”没有痛苦就没有收获“</li><li>自然的一项根本法则是，为了赢得力量，人必须努力突破极限，而这是痛苦的</li></ul></li><li>痛苦+反思=进步<ul><li>迎接而非躲避痛苦</li><li>接受严厉的爱</li></ul></li><li>考虑后续与再后续的结果</li><li>接受结果</li><li>从更高的层次俯视机器<ul><li>把自己想象成一部在大机器里运转的小机器，并明白你有能力改变你的机器以实现更好的结果</li><li>通过比较你实现的结果和你的目标，你就能确定如何改进你的机器</li><li>区别作为机器设计者的你和作为机器中工作的你</li><li>大多数人犯下的最大错误是不客观看待自己以及其他人，这导致他们一次次地栽在自己或其他人的弱点上</li><li>成功的人能超越自身，客观看待事物，并管理事物以塑造改变</li><li>在你不擅长的领域请教擅长的其他人，这是一个你无论如何都应该培养的出色技能，这将帮助你建立起安全的护栏，避免自己做错事</li><li>因为客观看待自身很困难，所以你需要依赖其他人的意见，以及全部证据</li><li>如果你的头脑足够开放，足够有决心，你几乎可以实现任何愿望</li></ul></li></ul></li><li>用五步流程实现你的人生愿望<ul><li>有明确的目标<ul><li>排列优先顺序：尽管你几乎可以得到你想要的任何东西，但你不可能得到你想要的所有东西</li><li>不要混淆欲望和目标</li><li>调和你的目标和欲望，以明确你在生活中真正想要的东西</li><li>不要把成功的装饰误认为成功本身</li><li>永远不要因为你觉得某个目标无法实现就否决它</li><li>谨记伟大的期望创造伟大的能力</li><li>如果你拥有灵活性并自我规则，那么几乎没有什么能阻止你成功</li><li>知道如何对待挫折和知道如何前进一样重要</li></ul></li><li>找出问题，并且不容忍问题<ul><li>把令人痛苦的问题视为考验你的潜在进步机会</li><li>不要逃避问题，因为问题根植于看起来并不美好的残酷现实</li><li>要精准地找到问题所在</li><li>不要问题的某个原因误认为问题本身</li><li>区分大问题和小问题</li><li>找出一个问题之后，不要容忍问题</li></ul></li><li>诊断问题，找到问题的根源<ul><li>先把问题弄明白，再决定怎么做</li><li>区分直接原因的根本原因</li><li>认识到了解（包括你自己）的特性，有助于对其形成合理预期</li></ul></li><li>规划方案<ul><li>前进之前先回顾</li><li>把你的问题看做一部机器产生的一系列结果</li><li>谨记实现你的目标通常有很多途径</li><li>把你的方案设想为一个电影剧本，然后循序渐进地思考由谁来做什么事</li><li>把你的方案写下来，让所有人能够看到</li><li>要明白，规划一个好的方案不一定需要很多时间</li></ul></li><li>坚定地从头到尾执行方案<ul><li>规划做得再好，不执行也无济于事</li><li>良好的工作习惯的重要性常被大大低估</li><li>建立清晰的衡量标准来确保你在严格执行方案</li></ul></li><li>谨记：如果你找到了解决方案，弱点是不重要的<ul><li>考察你犯错误的类型，并识别你通常在五步流程中哪一步上做的不好</li><li>每个人都至少有一个最大的弱点阻碍其成功，找到你的这个弱点并处理它</li></ul></li><li>理解你和其他人的“意境地图”和谦逊性</li></ul></li><li>做到头脑极度开放<ul><li>认识你的两大障碍<ul><li>理解你的自我意识障碍</li><li>“两个你”在争夺你的控制权</li><li>理解你的思维盲点障碍</li></ul></li><li>奉行头脑极度开放<ul><li>诚恳地相信你也许并不知道最好的解决办法是什么，并认识到，与你知道的东西相比，能不能妥善处理”不知道”才是最重要的</li><li>认识到决策应该分两步:先分析所有相关信息，然后做决定</li><li>不要担心自己的形象，只关心如何实现目标</li><li>认识到你不能”只产出不吸纳”</li><li>认识到为了能够从他人的角度看待事物，你必须暂时悬置判断，只有设身处地，你才能够合理评估另一种观点的价值</li><li>谨记，你是在寻找最好的答案，而不是自己能够得出的最好答案</li><li>搞清楚你是在争论还是在试图理解一个问题，并根据你和对方的可信度，想想哪种做法最合理</li></ul></li><li>领会并感激:深思熟虑的意见分歧</li><li>和可信的人、愿意表达分歧的人，一起审视你的观点<ul><li>为最坏的情况做准备，以尽量使其不那么糟糕</li></ul></li><li>识别你应当注意的头脑封闭和头脑开放的不同迹象</li><li>你觉得你如何做到头脑极度开放<ul><li>经常利用痛苦来引导自己进行高质量的思考</li><li>将头脑开放作为一种习惯</li><li>认识自己的思维盲点</li><li>假如很多可信的人都在说你正在做错事，只有你不这么看，你就想想自己是不是看偏了</li><li>冥想</li><li>重视证据，并鼓励其他人也这么做</li><li>尽力帮助其他人也保持头脑开放</li><li>使用以证据为基础的决策工具</li><li>知道什么时候应当停止为自己的观点辩护，信任自己的决策程序</li></ul></li></ul></li><li>理解人与人大不相同<ul><li>明白你和其他人的思维方式能带来的力量<ul><li>我们拥有各种天生的特征，既可能帮助自己，也可能伤害自己，取决于如何应用</li></ul></li><li>有意义的工作和有意义的人际关系，不仅是我们做出的美好选择，而且是我们天生的生理需求</li><li>理解大脑里的主要斗争，以及如何控制这些斗争，以实现你的愿望<ul><li>要明白，意识与潜意识在不断斗争</li><li>要知道最常发生的斗争是情绪和思考的斗争</li><li>调和你的情绪和思考</li><li>善择你的习惯</li><li>坚持友善的训练，较低层次的你养成好的习惯</li><li>理解右脑思维和左脑思维的差别</li><li>理解大脑可以改变的程度</li></ul></li><li>认识自己和他人的特性<ul><li>内向和外向</li><li>直觉与感知</li><li>思考与感觉</li><li>计划与发觉</li><li>创造者，推进者，改进者，贯彻者与变通者</li><li>关注任务与关注目标</li><li>塑造者是能从构想一路走到构想实现的人</li></ul></li><li>无论你要实现什么目标，让合适的人各司其职，你支持你的目标是成功的关键<ul><li>管理你自己，并协调其他人实现你的目标</li></ul></li></ul></li><li>学习如何有效决策<ul><li>要认识到: 影响好决策的最大威胁是有害的情绪。决策是一个两部流程，先了解后决定</li><li>综合分析眼前的形势<ul><li>你能做到的最重要的决定之一就是决定问谁</li><li>不要听信什么信什么</li><li>所有东西都是放在眼前看更大</li><li>不要夸大新东西的好处</li><li>不要过度分析细节</li></ul></li><li>综合分析变化中的形式<ul><li>始终记住改善事物的速度和水平以及两者的关系</li><li>不必过于精确</li><li>谨记28法则并明白关键性的20%是什么</li><li>不要做完美主义者</li></ul></li><li>高效地综合考虑各个层次<ul><li>用基线以上和基线以下来确定谈话位于哪一层</li><li>谨记决策需要在合理的层次作出，但也应在各层次之间保持一致</li><li>综合分析现实、理解如何行动的最好工具是逻辑、理性和常识</li></ul></li><li>根据预期价值做决策<ul><li>不管你要对的概率已经有多大提高，你的压力概率始终有价值</li><li>知道什么时候不去压住和知道什么时候压同样重要</li><li>最好的选择是好处多于坏处的选择，不是毫无坏处的选择</li></ul></li><li>比较更多信息带来的价值和不做决定造成的成本，决定优先顺序<ul><li>先把你的必做之事做完，再做你想做之事</li><li>你很可能没有时间处理不重要的事，那最好将它留着以免自己没有时间处理重要的事</li><li>不要把概率当作可能性</li></ul></li><li>简化</li><li>使用原则</li><li>对你的决策进行可信度加权</li><li>把你的原则转换成算法，让计算机和你一起决策</li><li>在深刻理解人工智能之前，不要过度信赖它</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Ray-Dalio-《原则》&quot;&gt;&lt;a href=&quot;#Ray-Dalio-《原则》&quot; class=&quot;headerlink&quot; title=&quot;Ray Dalio 《原则》&quot;&gt;&lt;/a&gt;Ray Dalio 《原则》&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;拥抱现实，应对现实&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="book" scheme="http://wujingchao.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>基金投资策略(2021年01月09日)</title>
    <link href="http://wujingchao.github.io/2020/03/18/fund/"/>
    <id>http://wujingchao.github.io/2020/03/18/fund/</id>
    <published>2020-03-17T16:00:00.000Z</published>
    <updated>2024-12-07T09:24:04.454Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原-基金网格策略"><a href="#原-基金网格策略" class="headerlink" title="(原)基金网格策略"></a><del>(原)基金网格策略</del></h3><p><del><a href="https://view.officeapps.live.com/op/view.aspx?src=https://github.com/wujingchao/wujingchao.github.io/blob/master/WAIT_AND_HOPE.xlsx?raw=true">XLS</a></del></p><h3 id="基金投资策略-2021年01月09日更新"><a href="#基金投资策略-2021年01月09日更新" class="headerlink" title="基金投资策略(2021年01月09日更新)"></a>基金投资策略(2021年01月09日更新)</h3><p>最近一年学习了许多股票基金投资相关的书籍，打破了以前的一些认知，以前运用的网格策略，低估值策略现在不是很看好，这些策略说到底都是在赚股价由于情绪波动的收益，典型的零和游戏，特别是网格，和投机没什么区别，即使在一段时期内有效，但是很难长期有效，不符合自己的投资价值理念，要避免这些短期的诱惑，做一名长期的价值投资者。</p><p>去年的收益严重跑输沪深300指数，不得不思考下原因，在18年和17年股市低落的时候捡了很多蓝筹价值股便宜的筹码，在19年股市稍稍上涨的时候就匆匆卖掉了，近日究其原因就是不理解其的价值导致。然后又买了很多策略指数，比如沪深300价值等，策略指数都是使用纯数据筛选出来的，成分股里面有大量的银行地产保险，虽然这些行业的价格低估，但是有特点是高负债，长期来看成长较缓慢或者没有成长，可能会一直低估。。</p><p>回归到股票投资的宗旨，买股票就是买公司，即赚取企业成长的价值，从这个角度出发，执行比较符合自己价值观投资策略，这样才能在市场严重回撤的时候坚定持有，并持续以好的价格不断买入，也不至于在市场涨了一点点就迅速止盈。</p><p>长期来看，优质企业的价格市场大部分时间都是有效的，除非出现了严重的泡沫，比如身边的人平时不买股票和基金都来参与了，这种情况可以考虑止盈。如果出现严重低估，那么就是大量买入的时候。以下是符合我投资理念的策略：</p><ul><li><p>买基金。对于业余的上班族来说，每天研究股票以及看盘不现实，会影响到正常的学习和生活，并且股权投资难度是很大的，让专业的人买帮我们。买基金是比较好的策略，如果由于市场情绪的影响，出现了严重的低估股票，可以尝试买入一些自己能力圈内了解的。(需要不断学习，看懂企业的前提下，不建议在不懂情况下碰股票，和赌博没什么区别)</p></li><li><p>选择基金经理。选择符合自己投资理念优秀的基金经理人，前十大股票仓位重仓，通常超过70%以上，低换手，意味着看好了一只股票就不会轻易换掉，除非公司的基本面出现了很大的变化。通常情况下重仓是风险很高，即人们常说的把鸡蛋放在一个篮子里面，但是如果投资过于分散会严重拉低收益，对于指数来说，里面存在着大量的垃圾股，很难赚取高于市场的平均回报，就像芒格说的，无知才是最大的风险。所以我认为把鸡蛋放在一个篮子里面，并且仔细看好你的篮子是一个很好的策略</p></li><li><p>选行业。选择长期看好的行业，消费，医疗，可以参考美国的股市，消费医疗是一条好的长期的赛道，很多大牛股都是从这里面出来的，比如苹果</p></li><li><p>好价格。经过2020年的上涨，消费医疗已经涨了很多，风险较高，目前不宜重仓进入，回撤较大容易影响到心态，可以等到比较大回调的时候再买入</p></li><li><p>定投或分批。但要尽可能的少操作，虽然定投是很好的方式，如果选择日投就很频繁了，月投，周投比较合适，如果在价格上涨过多的情况下，可以先把资金留着，下次有好的机会一起投入。真正的高手是在合适的时机一招制敌</p></li><li><p>闲余资金。最重要的一点就是使用长期闲余的资金，这样才能保持一个良好的心态，不影响到正常的工作和情绪，由于恐惧而止损造成永久性的亏损</p></li></ul><p>当然对于我们普通人来说，靠买股票和基金发达不太现实，努力工作学习，不断提升自己的专业技能才能走得远。投资的目的是希望以后能摆脱金钱束缚，把更多的时间放在自己喜欢的事上，且享受这个慢慢的过程。</p><p>最后，对于大多数人来说，投资是件反人性的事情，需要有良好的心态以及观念才能走得更长远：</p><p><img src="/assets/buffett.jpeg" alt="buffett"></p><blockquote><p>投资永远记住两条原则：</p><p>第一，永远不要亏损</p><p>第二，永远记住第一条</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原-基金网格策略&quot;&gt;&lt;a href=&quot;#原-基金网格策略&quot; class=&quot;headerlink&quot; title=&quot;(原)基金网格策略&quot;&gt;&lt;/a&gt;&lt;del&gt;(原)基金网格策略&lt;/del&gt;&lt;/h3&gt;&lt;p&gt;&lt;del&gt;&lt;a href=&quot;https://view.office
      
    
    </summary>
    
    
      <category term="fund" scheme="http://wujingchao.github.io/tags/fund/"/>
    
  </entry>
  
  <entry>
    <title>最简单的SSH / Frp内网穿透配置</title>
    <link href="http://wujingchao.github.io/2020/02/22/penetrate/"/>
    <id>http://wujingchao.github.io/2020/02/22/penetrate/</id>
    <published>2020-02-21T16:00:00.000Z</published>
    <updated>2024-12-07T09:27:58.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最简单的Ubuntu-SSH-Frp内网穿透配置"><a href="#最简单的Ubuntu-SSH-Frp内网穿透配置" class="headerlink" title="最简单的Ubuntu SSH / Frp内网穿透配置"></a>最简单的Ubuntu SSH / Frp内网穿透配置</h3><p>内网：家里或者公司的机器</p><p>公网：云服务器</p><p>外网：需要访问内网的机器</p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><h5 id="公网服务器配置"><a href="#公网服务器配置" class="headerlink" title="公网服务器配置"></a>公网服务器配置</h5><p>修改sshd配置/etc/ssh/sshd_config</p><pre><code>GatewayPorts yes</code></pre><p>除了开放sshd用的端口，还需要开放一个[公网服务器开放端口]，用作转发数据</p><h5 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h5><p>为了能够断开自动重连，安装autossh(ubuntu)</p><pre><code>sudo apt-get install autossh</code></pre><p>与公网服务器建立连接通道</p><pre><code>autossh -M [内网任意未使用端口] -NR [公网服务器开放端口]:127.0.0.1:[本地sshd端口] [公网服务器用户名]@[公网ip]//提示输入公网服务器密码</code></pre><p>-M 后面的这个参数端口貌似用echo service做监听重连的，没太看明白</p><p>-N  Do not execute a remote command.  This is useful for just forwarding ports</p><p>-R Specifies that connections to the given TCP port or Unix socket on the remote (server) host are to be forwarded to the local side</p><p>这样配置好以后，外网连上的[公网服务器开放端口]的数据就会转发到内网的[本地sshd端口]</p><h5 id="外网配置"><a href="#外网配置" class="headerlink" title="外网配置"></a>外网配置</h5><p>上面两部配置完成之后就可以远程ssh到内网了</p><pre><code>ssh [内网用户名]@[公网ip] -p [公网服务器开放端口]//提示输入内网服务器密码</code></pre><p>使用ssh开启隧道代理：</p><pre><code>ssh -nNTf -D [本地上网代理端口] [内网用户名]@[公网ip] -p [公网服务器开放端口]</code></pre><p>同样，可以使用autossh断连之后自动重连。需要把-nNTf参数放到后面，否则会将-f误认为是autossh的参数，无法提示输入密码：</p><pre><code>autossh -M 0  -D [本地上网代理端口]  [内网用户名]@[公网ip] -p [公网服务器开放端口] -nNTf</code></pre><p>有时候使用autossh也会断开，可以在/etc/ssh/config加上</p><pre><code>ServerAliveInterval 60 </code></pre><p>那么就会每隔60s,就会发一次消息，确保在线。如果还想继续处理其他未知的情况，使用暴力不断重连的命令</p><pre><code>while true; do [ssh链接命令]; sleep 5;done</code></pre><p>这样就开启了socket5协议代理，将浏览器或应用的代理设置为sockets://127.0.0.1:[本地上网代理端口]， 就可以成功穿透到内网了！</p><h3 id="Frp"><a href="#Frp" class="headerlink" title="Frp"></a>Frp</h3><p>发现有时候不稳定的时候ssh老是断开导致公网的服务器转发端口有时候监听失败，看了下Frp配置也比较简单，目前看来比较稳定。</p><h4 id="公网服务器配置-1"><a href="#公网服务器配置-1" class="headerlink" title="公网服务器配置"></a>公网服务器配置</h4><p>首先去Frp项目<a href="https://github.com/fatedier/frp/releases">下载</a>release软件，不同的操作系统都有包含，服务端和客户端都在一个包里面。</p><p>下载之后解压，配置服务端的配置文件 frps.ini</p><pre><code>[common]bind_port = &#123;frp监听端口&#125;dashboard_port = &#123;控制台端口，用作http协议访问&#125;dashboard_user = &#123;控制台用户名&#125;dashboard_pwd = &#123;控制台密码&#125;authentication_method = tokentoken = &#123;用于frp客户端访问验证&#125;</code></pre><p>之后直接运行可执行文件frps即可</p><h4 id="内网服务器配置"><a href="#内网服务器配置" class="headerlink" title="内网服务器配置"></a>内网服务器配置</h4><p>客户端配置文件frpc.ini:</p><pre><code>[common]server_addr = &#123;frp服务端公网ip&#125;server_port = &#123;frp服务端监听端口&#125;token= &#123;frp服务端访问令牌&#125;[ssh-mac] &#123;不同的客户端需要有不同的名字&#125;type = tcplocal_ip = 127.0.0.1local_port = &#123;sshd监听端口&#125;remote_port = &#123;用于转发数据的端口&#125;use_encryption = trueuse_compression = true</code></pre><p>之后直接运行可执行文件frpc即可</p><h4 id="外网配置-1"><a href="#外网配置-1" class="headerlink" title="外网配置"></a>外网配置</h4><p>上面两部配置好之后，就可以通过remote_port ssh到内网了，按照前面的命令配置ssh隧道代理！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最简单的Ubuntu-SSH-Frp内网穿透配置&quot;&gt;&lt;a href=&quot;#最简单的Ubuntu-SSH-Frp内网穿透配置&quot; class=&quot;headerlink&quot; title=&quot;最简单的Ubuntu SSH / Frp内网穿透配置&quot;&gt;&lt;/a&gt;最简单的Ubuntu S
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>再谈Android源码的C++智能指针</title>
    <link href="http://wujingchao.github.io/2019/11/18/android-sp/"/>
    <id>http://wujingchao.github.io/2019/11/18/android-sp/</id>
    <published>2019-11-17T16:00:00.000Z</published>
    <updated>2024-12-07T09:02:40.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="再谈Android源码的C-智能指针"><a href="#再谈Android源码的C-智能指针" class="headerlink" title="再谈Android源码的C++智能指针"></a>再谈Android源码的C++智能指针</h3><p>AOSP里面用到智能指针的地方太多，目前也有很多现成源码分析的文章，本文从引用的角度谈谈我对其的理解，尽量避免贴大量源代码，水平有限，可能有纰漏，也感谢帮忙指出。</p><h4 id="Java与C-对象的生命周期"><a href="#Java与C-对象的生命周期" class="headerlink" title="Java与C++对象的生命周期"></a>Java与C++对象的生命周期</h4><p>我们都知道，Java对象通过new关键字创建，之后就会再Java虚拟机的堆区创建一块内存区域，然后我们通过的类型变量去引用它，这个就是强引用。垃圾回收器(GC)会在适当的时刻，根据对象可达性(reachable)判断，是否回收相关的对象。</p><p>另外，当我们在长存对象里面引用对象的时，例如在Android的Activity内部使用Handler对象给主线程发消息，如果不使用静态的Hanlder对象的话，会导致对象持有外部的Activity对象，而消息Message对象会引用Handler对象，如果消息队列里面的对象一直没有得到处理，那么就会导致Activity对象得不到回收，所以我们就需要将Handler改为非内部类的实现方式，并且不能对Activity强引用。这个时候就需要对Activity弱引用， 不影响GC对Activity对象进行回收。</p><p>Java除了强引用，还有另外三种引用：</p><ul><li>SoftReference（软引用：会影响GC回收，取决于GC的实现，例如当内存不够用的时候才会回收这部分内存）</li><li>WeakReference（弱引用：不影响GC回收，当被回收之后，持有的对象会被清空）</li><li>PhantomReference（虚幻引用，不影响GC回收，并且访问不到持有的对象，被回收后能从引用队列里面访问到）</li></ul><p>对对象的引用从强到弱。</p><p>….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;再谈Android源码的C-智能指针&quot;&gt;&lt;a href=&quot;#再谈Android源码的C-智能指针&quot; class=&quot;headerlink&quot; title=&quot;再谈Android源码的C++智能指针&quot;&gt;&lt;/a&gt;再谈Android源码的C++智能指针&lt;/h3&gt;&lt;p&gt;AOSP
      
    
    </summary>
    
    
      <category term="sp,android" scheme="http://wujingchao.github.io/tags/sp-android/"/>
    
  </entry>
  
  <entry>
    <title>MacOS Scheme编译环境搭建</title>
    <link href="http://wujingchao.github.io/2019/02/17/scheme-env/"/>
    <id>http://wujingchao.github.io/2019/02/17/scheme-env/</id>
    <published>2019-02-16T16:00:00.000Z</published>
    <updated>2024-12-07T09:30:49.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MacOS-Scheme编译环境搭建"><a href="#MacOS-Scheme编译环境搭建" class="headerlink" title="MacOS Scheme编译环境搭建"></a>MacOS Scheme编译环境搭建</h3><p>安装的环境是开源的<a href="https://cisco.github.io/ChezScheme/">ChezScheme</a></p><p>下载ChezScheme</p><pre><code>git clone git@github.com:cisco/ChezScheme.git</code></pre><p>编译与安装：</p><pre><code>./configuresudo make install</code></pre><p>安装完成之后就可以直接在Shell里面使用ChezScheme的命令行交互环境， Ctrl + D退出:</p><p><img src="/assets/scheme-env1.png" alt="scheme-evn1"></p><p>如果不使用交互式环境，还可以让解释器直接解释文件：</p><p><img src="/assets/scheme-env2.png" alt="scheme-evn2"></p><p>为了更方便学习，还可以将环境集成到vscode里面：</p><p>安装支持语法高亮的插件 vscode-scheme:</p><p><img src="/assets/scheme-env3.png" alt="scheme-evn3"></p><p>支持快捷运行代码的插件 Code Runner:</p><p><img src="/assets/scheme-env4.png" alt="scheme-evn4"></p><p>配置Code Runner支持scheme：</p><p>在菜单 Code -&gt; Preferences -&gt; Settings里面搜索Run Code找到 Executor Map By File Extension：</p><p><img src="/assets/scheme-env5.png" alt="scheme-evn4"></p><p>点击 Edit in settings.json，在这个文件里面加上scheme文件的后缀配置，然后保存：</p><pre><code>    &quot;code-runner.executorMapByFileExtension&quot;: &#123;        &quot;.ss&quot;: &quot;scheme --quiet &lt; $fullFileName&quot;    &#125;</code></pre><p>在vscode里面新建ss后缀的scheme文件，点运行按钮就可以直接运行了，结果会在OUTPUT里面：</p><p><img src="/assets/scheme-env6.png" alt="scheme-evn4"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MacOS-Scheme编译环境搭建&quot;&gt;&lt;a href=&quot;#MacOS-Scheme编译环境搭建&quot; class=&quot;headerlink&quot; title=&quot;MacOS Scheme编译环境搭建&quot;&gt;&lt;/a&gt;MacOS Scheme编译环境搭建&lt;/h3&gt;&lt;p&gt;安装的环境是
      
    
    </summary>
    
    
      <category term="scheme,sicp" scheme="http://wujingchao.github.io/tags/scheme-sicp/"/>
    
  </entry>
  
  <entry>
    <title>Android锁屏下启动应用卡屏5秒的原因分析</title>
    <link href="http://wujingchao.github.io/2018/12/16/transition_delay/"/>
    <id>http://wujingchao.github.io/2018/12/16/transition_delay/</id>
    <published>2018-12-15T16:00:00.000Z</published>
    <updated>2024-12-07T09:32:49.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android锁屏下启动应用卡屏5秒的原因分析"><a href="#Android锁屏下启动应用卡屏5秒的原因分析" class="headerlink" title="Android锁屏下启动应用卡屏5秒的原因分析"></a>Android锁屏下启动应用卡屏5秒的原因分析</h3><p>最近分析一个问题，在锁屏窗口中启动应用会出现卡顿5秒，比如拨打电话，启动Google日历等。</p><p>拿拨打电话来举例，启动的action为 android.intent.action.CALL，对应处理的Activity在Telecom中：</p><pre><code>//packages/services/Telecomm/AndroidManifest.xml:&lt;activity android:name=&quot;.components.UserCallActivity&quot;        android:label=&quot;@string/userCallActivityLabel&quot;        android:theme=&quot;@style/Theme.Telecomm.Transparent&quot;        android:permission=&quot;android.permission.CALL_PHONE&quot;        android:excludeFromRecents=&quot;true&quot;        android:process=&quot;:ui&quot;&gt;    &lt;!-- CALL action intent filters for the various ways of initiating an outgoing call. --&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.CALL&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;data android:scheme=&quot;tel&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>出现卡屏的UserCallActivity比较特别，没有界面，启动之后就会在onCreate里面直接finish，其他的没有出现这个问题快捷方式都是在启动的Activity直接显示。</p><h4 id="WMS出现卡屏5秒的原因分析"><a href="#WMS出现卡屏5秒的原因分析" class="headerlink" title="WMS出现卡屏5秒的原因分析"></a>WMS出现卡屏5秒的原因分析</h4><p>启动Activity  com.android.server.telecom/.components.UserCallActivity的时候调用AMS的方法：</p><pre><code>com/android/server/am/ActivityStackSupervisor.java：final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,                                    boolean andResume, boolean checkConfig) throws RemoteException &#123;//…    if (mKeyguardController.isKeyguardLocked()) &#123;//锁屏状态下调用        r.notifyUnknownVisibilityLaunched();    &#125;//…&#125;</code></pre><p>接着调用ActivityRecord# notifyUnknownVisibilityLaunched方法：</p><pre><code>com/android/server/am/ActivityRecord.java：void notifyUnknownVisibilityLaunched() &#123;   // No display activities never add a window, so there is no point in waiting them for   // relayout.      if (!noDisplay) &#123;            mWindowContainerController.notifyUnknownVisibilityLaunched();      &#125;&#125;</code></pre><p>最终调用到UnknownAppVisibilityController#notifyLaunched方法，UnknownAppVisibilityController里面的成员变量mUnknownApps记录了锁屏状态下调用AppWindowToken的状态列表，它有几个状态：</p><p>UNKNOWN_STATE_WAITING_RESUME    等待执行完onResume<br>UNKNOWN_STATE_WAITING_RELAYOUT   等待执行完layout<br>UNKNOWN_STATE_WAITING_VISIBILITY_UPDATE   等待可见性的更新</p><p>目前看来这个类的目的就是控制锁屏界面下启动的Activity显示，要等待锁屏下开启的Activity完全显示以后才能显示其他的Activity，如果一直不显示也会其他被启动的Acitivity也有一个5s的超时被强制显示。</p><pre><code>com/android/server/wm/UnknownAppVisibilityController.java/** * Manages the set of &#123;@link AppWindowToken&#125;s for which we don&#39;t know yet whether it&#39;s visible or * not. This happens when starting an activity while the lockscreen is showing. In that case, the * keyguard flags an app might set influence it&#39;s visibility, so we wait until this is resolved to * start the transition to avoid flickers.（防止闪烁先显示Launcer，然后又快速地切换到显示目标Activity） */class UnknownAppVisibilityController &#123;    /**     * Notifies that &#123;@param appWindow&#125; has been launched behind Keyguard, and we need to wait * until it is resumed and relaid out to resolve the visibility.     * Keyguard状态下启动Activity的时候调用     */void notifyLaunched(@NonNull AppWindowToken appWindow) &#123;if (DEBUG_UNKNOWN_APP_VISIBILITY) &#123;            Slog.d(TAG, &quot;App launched appWindow=&quot; + appWindow);        &#125;        mUnknownApps.put(appWindow, UNKNOWN_STATE_WAITING_RESUME); &#125;/** * Notifies that &#123;@param appWindow&#125; has finished resuming.  Acitivty#onResume完成调用 */void notifyAppResumedFinished(@NonNull AppWindowToken appWindow) &#123;    if (mUnknownApps.containsKey(appWindow)            &amp;&amp; mUnknownApps.get(appWindow) == UNKNOWN_STATE_WAITING_RESUME) &#123;        if (DEBUG_UNKNOWN_APP_VISIBILITY) &#123;            Slog.d(TAG, &quot;App resume finished appWindow=&quot; + appWindow);        &#125;        mUnknownApps.put(appWindow, UNKNOWN_STATE_WAITING_RELAYOUT);    &#125;&#125;    /**     * Notifies that &#123;@param appWindow&#125; has relaid out.     * layout完成     */void notifyRelayouted(@NonNull AppWindowToken appWindow) &#123;     if (!mUnknownApps.containsKey(appWindow)) &#123;         return;     &#125;     if (DEBUG_UNKNOWN_APP_VISIBILITY) &#123;         Slog.d(TAG, &quot;App relayouted appWindow=&quot; + appWindow);     &#125;      int state = mUnknownApps.get(appWindow);        if (state == UNKNOWN_STATE_WAITING_RELAYOUT) &#123; //当layout完成并且可见，也会从集合里移除            mUnknownApps.put(appWindow, UNKNOWN_STATE_WAITING_VISIBILITY_UPDATE);            mService.notifyKeyguardFlagsChanged(this::notifyVisibilitiesUpdated);    &#125;&#125;     //在Activity#onDestroy方法执行完成通知AMS的时候才会调用，mUnknownApps移除对应的appWindow    void appRemovedOrHidden(@NonNull AppWindowToken appWindow) &#123;        if (DEBUG_UNKNOWN_APP_VISIBILITY) &#123;            Slog.d(TAG, &quot;App removed or hidden appWindow=&quot; + appWindow);        &#125;        mUnknownApps.remove(appWindow);    &#125;    //这个方法在AppTrasition的时候后判断是否有mUnknownApps存在    boolean allResolved() &#123;        return mUnknownApps.isEmpty();    &#125;｝</code></pre><p>下面是UnknownAppVisibility的日志，可以看到UserCallActivity的AppWindowToken被放到了mUnknownApps里面，过了5s之后才执行UserCallActivity#onDestory方法，从mUnknownApps里面移除。</p><pre><code>LOG:06-02 09:54:44.352 D/UnknownAppVisibility(  777): App launched appWindow=AppWindowToken&#123;99d9676 token=Token&#123;85511 ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288&#125;&#125;&#125;06-02 09:54:45.263 D/UnknownAppVisibility(  777): App resume finished appWindow=AppWindowToken&#123;99d9676 token=Token&#123;85511 ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288&#125;&#125;&#125;06-02 09:54:51.455 V/ActivityManagerService_Switch(  777): ACTIVITY DESTROYED: Token&#123;85511 ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288 f&#125;&#125; [这个地方的onDestroy不是正常finish后调用的，而是AMS的超时机制触发]06-02 09:54:51.460 D/UnknownAppVisibility(  777): App removed or hidden appWindow=AppWindowToken&#123;99d9676 token=Token&#123;85511 ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288&#125;&#125;&#125;</code></pre><p>在启动Activity的时候，会调用continueSurfaceLayout：</p><pre><code>com/android/server/am/ActivityStarter.java:private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,                        int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123;//…try &#123;    mService.mWindowManager.deferSurfaceLayout();    result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,            startFlags, doResume, options, inTask, outActivity);&#125; finally &#123;    mService.mWindowManager.continueSurfaceLayout();&#125;    return result;&#125;</code></pre><p>最终会调用到WindowSurfacePlacer # transitionGoodToGo这个方法，判断是否准备好可以执行transition：</p><pre><code>com/android/server/wm/WindowSurfacePlacer.java：int handleAppTransitionReadyLocked() &#123;   int appsCount = mService.mOpeningApps.size();   if (!transitionGoodToGo(appsCount, mTempTransitionReasons)) &#123;      return 0;｝//…if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, &quot;**** GOOD TO GO&quot;); mService.mH.removeMessages(H.APP_TRANSITION_TIMEOUT);//如果成功，从handler移除AppTransition超时处理//…&#125;//下面是个关键的地方， UnknownAppVisibilityController里面保存了在锁屏情况下启动Activity的AppWindowToken，导致不能正常的transitionprivate boolean transitionGoodToGo(int appsCount, SparseIntArray outReasons) &#123;    //...    if (!mService.mAppTransition.isTimeout()) &#123;        //...        if (!mService.mUnknownAppVisibilityController.allResolved()) &#123;            if (DEBUG_APP_TRANSITIONS) &#123;                Slog.v(TAG, &quot;unknownApps is not empty: &quot;                        + mService.mUnknownAppVisibilityController.getDebugMessage());            &#125;            return false;        &#125;        //....        return false;    &#125;    return true;&#125;</code></pre><pre><code>LOG06-02 09:54:45.229 V/WindowSurfacePlacer(  777): unknownApps is not empty: app=AppWindowToken&#123;99d9676 token=Token&#123;85511 ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288&#125;&#125;&#125; state=1//….06-02 09:54:45.278 V/WindowSurfacePlacer(  777): unknownApps is not empty: app=AppWindowToken&#123;99d9676 token=Token&#123;85511 ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288&#125;&#125;&#125; state=2//…    //private static final int UNKNOWN_STATE_WAITING_RESUME = 1;    //private static final int UNKNOWN_STATE_WAITING_RELAYOUT = 2;</code></pre><p>可以看到日志UserCallActivity的state一直处于1和2的状态，阻塞了不能正常的AppTrasition</p><p>尝试在加上条件测试看是否还会出现卡屏5s的现象:</p><pre><code>com/android/server/wm/WindowSurfacePlacer.java：if (!mService.mUnknownAppVisibilityController.allResolved()&amp;&amp;!mService.mUnknownAppVisibilityController.getDebugMessage().contains(“com.android.server.telecom/.components.UserCallActivity”)) &#123;    //…    return false;&#125;</code></pre><p>加上这个测试条件后就没有了卡屏5秒的情况，但是有了新问题，会出现flickers（闪烁），先显示Launcer，然后又快速地切换到显示InCallActivity。如果FUNC先解锁操作再执行拨打电话，也会出现同样的问题。这正是UnknownAppVisibilityController解决的问题。下面看UserCallActivity finish不掉的原因。</p><h4 id="AMS-finish没有立即触发onDestroy的原因分析"><a href="#AMS-finish没有立即触发onDestroy的原因分析" class="headerlink" title="AMS  finish没有立即触发onDestroy的原因分析"></a>AMS  finish没有立即触发onDestroy的原因分析</h4><p>正常的情况下，在Activity#onCreate方法中直接调用finish()，在之后的onPause方法调用AMS的activityPaused，就会直接调用IApplicationThread#scheduleDestroyActivity的方法通知Activity执行onDestroy，然后执行AMS的activityDestroyed，将UnknownAppVisibilityController里面的AppWindow移除。然而锁屏的的情况有区别：</p><pre><code>com/android/server/am/ActivityManagerService.java：@Overridepublic final void activityPaused(IBinder token) &#123;   //…   ActivityStack stack = ActivityRecord.getStackLocked(token);   if (stack != null) &#123;      stack.activityPausedLocked(token, false);   &#125;&#125;</code></pre><pre><code>com/android/server/am/ActivityStack.java:final void activityPausedLocked(IBinder token, boolean timeout) &#123;    final ActivityRecord r = isInStackLocked(token);    mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);    //…    completePauseLocked(true /* resumeNext */, null /* resumingActivity */);   //…&#125;private void completePauseLocked(boolean resumeNext, ActivityRecord resuming) &#123;    ActivityRecord prev = mPausingActivity;    if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Complete pause: &quot; + prev);    if (prev != null) &#123;        final boolean wasStopping = prev.state == STOPPING;        prev.state = ActivityState.PAUSED;        if (prev.finishing) &#123;            if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Executing finish of activity: &quot; + prev);            prev = finishCurrentActivityLocked(prev, FINISH_AFTER_VISIBLE, false);        &#125; else&#123;//...&#125;    &#125;&#125;final ActivityRecord finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj) &#123;    // First things first: if this activity is currently visible,    // and the resumed activity is not yet visible, then hold off on    // finishing until the resumed one becomes visible.    //这里的next是Launcher, r为UserCallActivity    final ActivityRecord next = mStackSupervisor.topRunningActivityLocked();    //可以看到上面的注释就是我们的这种场景     //在锁屏的情况下会走到分支mode为FINISH_AFTER_VISIBLE，r.visible为true    //关键的是next.nowVisible为false，即Launcher现在也是不可见的    //所以就会将UserCallActivity放到 mStoppingActivities里面    if (mode == FINISH_AFTER_VISIBLE &amp;&amp; (r.visible || r.nowVisible)            &amp;&amp; next != null &amp;&amp; !next.nowVisible) &#123;        if (!mStackSupervisor.mStoppingActivities.contains(r)) &#123;            addToStopping(r, false /* scheduleIdle */, false /* idleDelayed */);        &#125;        if (DEBUG_STATES) Slog.v(TAG_STATES,                &quot;Moving to STOPPING: &quot;+ r + &quot; (finish requested)&quot;);        r.state = STOPPING;        return r;    &#125;     //…    //非锁屏下走这个分支，这里就会scheduleDestroyActivity    if (mode == FINISH_IMMEDIATELY            || (prevState == ActivityState.PAUSED            &amp;&amp; (mode == FINISH_AFTER_PAUSE || mStackId == PINNED_STACK_ID))            || finishingActivityInNonFocusedStack            || prevState == STOPPING            || prevState == STOPPED            || prevState == ActivityState.INITIALIZING) &#123;             boolean activityRemoved = destroyActivityLocked(r, true, &quot;finish-imm&quot;);        //....        return activityRemoved ? null : r;    &#125;&#125;</code></pre><p>这个时候dumpsys activity的信息如下，UserCallActivity被加到了waittingToStop列表里，没有执行scheduleDestroyActivity方法：</p><pre><code>adb shell dumpsys activity:Activities waiting to stop:    TaskRecord&#123;28306a9 #433 A=com.android.server.telecom U=0 StackId=1 sz=1&#125;      Stop #0: ActivityRecord&#123;f676a30 u0 com.android.server.telecom/.components.UserCallActivity t433 f&#125;Activities waiting for another to become visible:    TaskRecord&#123;28306a9 #433 A=com.android.server.telecom U=0 StackId=1 sz=1&#125;      Wait #0: ActivityRecord&#123;f676a30 u0 com.android.server.telecom/.components.UserCallActivity t433 f&#125;// InCallActivity已经Resume等待显示ResumedActivity: ActivityRecord&#123;4cd5d55 u0 com.tct.dialer/com.android.incallui.InCallActivity t432&#125;</code></pre><p>之后的finish操作在ActivityManagerService#activityIdle方法中处理: (每次有Activity Resume完成，就会在主线程MessageQueue的Idler中调用，也有可能会在SystemServer中闲时调用)</p><pre><code>com/android/server/am/ActivityManagerService.java:@Overridepublic final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123;    synchronized (this) &#123;        ActivityStack stack = ActivityRecord.getStackLocked(token);        if (stack != null) &#123;            ActivityRecord r =                    mStackSupervisor.activityIdleInternalLocked(token, false /* fromTimeout */,                            false /* processPausingActivities */, config);        &#125;//….    &#125;&#125;</code></pre><p>接着调用ActivityStackSupervisor# activityIdleInternalLocked</p><pre><code>final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout,                                        boolean processPausingActivities, Configuration config) &#123;    if (DEBUG_ALL) Slog.v(TAG, &quot;Activity idle: &quot; + token);        // Atomically retrieve all of the other things to do.    //查找waitingToStop的Activity，如果这里能够找出来，那么在后面finish，调用Activity#onDestory    final ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(r,            true /* remove */, processPausingActivities);    NS = stops != null ? stops.size() : 0;    //…    // Stop any activities that are scheduled to do so but have been    // waiting for the next one to start.    for (int i = 0; i &lt; NS; i++) &#123;        r = stops.get(i);        final ActivityStack stack = r.getStack();        if (stack != null) &#123;            if (r.finishing) &#123;                stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false);            &#125; else &#123;                stack.stopActivityLocked(r);            &#125;        &#125;    &#125;    //...    return r;&#125;//查找操作waitingStop符合条件finish的final ArrayList&lt;ActivityRecord&gt; processStoppingActivitiesLocked(ActivityRecord idleActivity,                                    boolean remove, boolean processPausingActivities) &#123;    ArrayList&lt;ActivityRecord&gt; stops = null;//这个时候没有Activity可见，nowVisible为false    final boolean nowVisible = allResumedActivitiesVisible();    for (int activityNdx = mStoppingActivities.size() - 1; activityNdx &gt;= 0; --activityNdx) &#123;        ActivityRecord s = mStoppingActivities.get(activityNdx);//找到UserCallActivity        //waitingVisible为true，一直等待显示        boolean waitingVisible = mActivitiesWaitingForVisibleActivity.contains(s);        if (DEBUG_STATES) Slog.v(TAG, &quot;Stopping &quot; + s + &quot;: nowVisible=&quot; + nowVisible                + &quot; waitingVisible=&quot; + waitingVisible + &quot; finishing=&quot; + s.finishing);        if (waitingVisible &amp;&amp; nowVisible) &#123;//不会进入这个分支            mActivitiesWaitingForVisibleActivity.remove(s);            waitingVisible = false;//当InCallActivity show出来，置false，            if (s.finishing) &#123;                //...                s.setVisibility(false);            &#125;        &#125;        if (remove) &#123;                final ActivityStack stack = s.getStack();            final boolean shouldSleepOrShutDown = stack != null                    ? stack.shouldSleepOrShutDownActivities()                    : mService.isSleepingOrShuttingDownLocked();            //waitingVisible为true，进入不了这个分支            if (!waitingVisible || shouldSleepOrShutDown) &#123;if (!processPausingActivities &amp;&amp; s.state == PAUSING) &#123;                    //...                    continue;                &#125;                if (DEBUG_STATES) Slog.v(TAG, &quot;Ready to stop: &quot; + s);                if (stops == null) &#123;                    stops = new ArrayList&lt;&gt;();                &#125;                stops.add(s);                mStoppingActivities.remove(activityNdx);            &#125;        &#125;    &#125;    return stops;&#125;</code></pre><p>由于此时的topActivity (InCallActivity)一直没有show出来，就会导致UserCallActivity一直处于waitingToStop的状态，直到InCallActivity show出来之后，才会destroy UserCallActivity。</p><p>下面是日志，验证上面的分析：</p><pre><code>LOG06-02 09:54:44.464 V/ActivityStackSupervisor(  777): Stopping ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288&#125;: nowVisible=false waitingVisible=false finishing=false06-02 09:54:45.073 V/ActivityStack_States(  777): Moving to STOPPING: ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288 f&#125; (finish requested)06-02 09:54:45.283 V/ActivityStackSupervisor(  777): Stopping ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288 f&#125;: nowVisible=false waitingVisible=true finishing=true06-02 09:54:47.607 V/ActivityStackSupervisor(  777): Stopping ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288 f&#125;: nowVisible=false waitingVisible=true finishing=true06-02 09:54:51.186 V/ActivityStackSupervisor(  777): Stopping ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288 f&#125;: nowVisible=true waitingVisible=false finishing=true06-02 09:54:51.187 V/ActivityStackSupervisor(  777): Ready to stop: ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288 f&#125;06-02 09:54:51.287 V/ActivityStack_States(  777): Moving to FINISHING: ActivityRecord&#123;5db03d9 u0 com.android.server.telecom/.components.UserCallActivity t288 f&#125;</code></pre><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>由于在锁屏界面启动Activity导致触发了WMS的 UnknownAppVisibilityController防止闪烁(显示Launcher之后又快速切换到目标Activity)的机制， UserCall Activity不能及时finish，就会导致一直处于卡屏状态，直到AppTransition超时机制才强制显示InCallActivity。</p><p>UserCallActivity是Telecomm服务里面的组件，但是它又不是真正显示UI的Acivity，针对这种情况可以使用Telecom的placeCall接口可以规避掉这种情况。但是，不能保证所有启动的Acitivty都直接显示，比如原生的Google日历也会出现卡屏5秒现象，目前看来是原生Android的bug，对于这种情况，finish之后没有将不显示的窗口及时地从UnknownAppVisibilityController移除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android锁屏下启动应用卡屏5秒的原因分析&quot;&gt;&lt;a href=&quot;#Android锁屏下启动应用卡屏5秒的原因分析&quot; class=&quot;headerlink&quot; title=&quot;Android锁屏下启动应用卡屏5秒的原因分析&quot;&gt;&lt;/a&gt;Android锁屏下启动应用卡屏5
      
    
    </summary>
    
    
      <category term="transition,ams,wms" scheme="http://wujingchao.github.io/tags/transition-ams-wms/"/>
    
  </entry>
  
  <entry>
    <title>详解Socket编程---连接与断开</title>
    <link href="http://wujingchao.github.io/2018/07/22/tcp_connect/"/>
    <id>http://wujingchao.github.io/2018/07/22/tcp_connect/</id>
    <published>2018-07-21T16:00:00.000Z</published>
    <updated>2024-12-07T09:31:57.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="详解Socket编程—连接与断开"><a href="#详解Socket编程—连接与断开" class="headerlink" title="详解Socket编程—连接与断开"></a>详解Socket编程—连接与断开</h3><p>由于Java的Socket接口简单易用得多，为了简单起见，都是使用Java做示例，但是它和Unix C的接口都是类似，Java接口只是使用JNI对底层接口的一个封装。</p><h4 id="ServerSocket监听端口"><a href="#ServerSocket监听端口" class="headerlink" title="ServerSocket监听端口"></a>ServerSocket监听端口</h4><p>Socket编程使用的都是C/S的模式，先从ServerSocket说起，先来看下ServerSocket最多参数的构造方法：</p><pre><code>public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException</code></pre><ul><li>port: 第一个参数port就是进程要监听的端口。在TCP协议中，端口又被称为进程的地址，用于OS向上层分发数据的标识。<br>向某个没有监听的端口发送，数据，建立连接会受到TCP的RST报文，这种情况常常出现在对端的进程crash之后或者进程压根就没有监听这个端口，而你又去尝试连接或者发送数据。</li></ul><p><img src="/assets/tcp_connect_rst.png" alt="tcp_connect_rst"></p><p>对应就会抛出IO异常:</p><pre><code>java.net.ConnectException: Connection refused (Connection refused)    at java.net.PlainSocketImpl.socketConnect(Native Method)    at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)    at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)    at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)    at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)    at java.net.Socket.connect(Socket.java:589)</code></pre><ul><li>backlog：中文翻译叫积压值，不是很好理解。对应的注释：</li></ul><pre><code>requested maximum length of the queue of incoming connections</code></pre><p>当我们执行了监听端口的操作，就需要调用accpet方法去接收客户端TCP连接的请求，当客户端发起三次握手建立请求，我们就会accpet到一个Socket，就可以使用这个Socekt的输入输出流与对端通信。这里要强调一点，accept到的连接一定是完成了一次三次握手。如果我们处理接收Socket的速度较慢，例如使用单线程去处理，那么就会使建立完三次握手的连接在OS内部队列积压着，这个backlog就是限制积压这一类Socket的个数，如果我们不指定，默认就是50。</p><p>下面来做实验观察一下超过backlog大小会出现什么情况：</p><p>Server端代码，backlog的值为2：</p><pre><code>try (ServerSocket serverSocket = new ServerSocket(10086, 2)) &#123;    Socket socket = serverSocket.accept();    System.out.println(&quot;Accept New Socket&quot;);    TimeUnit.MINUTES.sleep(10);&#125;</code></pre><p>Client代码，设置了一个连接超时时间：</p><pre><code>for (int i = 0; i &lt; 5; i++) &#123;    Socket socket = new Socket();    try &#123;        socket.connect(new InetSocketAddress(&quot;192.168.1.7&quot;, 10086), 2_000);        System.out.println(&quot;Connect Success:&quot; + i);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>按照前面的理解，客户端应该能够连接成功三次，通过打印的日志确实如此，当连接第四个Socekt的时候会出现超时：</p><pre><code>07-22 22:27:56.973 7193-7562/com.wujingchao.android.demo I/System.out: Connect Success:007-22 22:27:56.983 7193-7562/com.wujingchao.android.demo I/System.out: Connect Success:107-22 22:27:56.983 7193-7562/com.wujingchao.android.demo I/System.out: Connect Success:207-22 22:29:00.181 7193-7562/com.wujingchao.android.demo W/System.err: java.net.ConnectException: failed to connect to /192.168.1.7 (port 10086): connect failed: ETIMEDOUT (Connection timed out)</code></pre><p>抓取客户端的TCP报文：<br><img src="/assets/tcp_connect_backlog.png" alt="tcp_connect_backlog"></p><p>报文 1 ~ 3， 4 ~ 7， 8 ~ 11就是前三次连接成功的报文(另外两个窗口大小更新的报文先不去理会)，从12个报文开始，客户端的SYN握手请求，服务端就不在理会了，再下来红字黑底的报文触发了客户端的超时重传。这里服务端的实现就是大于backlog的时候就丢弃SYN握手请求。</p><p>这里有一点需要注意，不同的OS平台对backlog的实现不太一样，上面测试的Server端是在Mac OS-HotSpot的环境下测试的，但是如果在Ubuntu-OpenJDK上测试，会得到不一样的结果，经过在Ubuntu上测试，服务端貌似没有对backlog有限制，连接了一百多个socket都还能连接。</p><p>很早之前OpenJDK上的issue中就讨论过这个问题：</p><p><a href="https://bugs.openjdk.java.net/browse/JDK-6258215">Num of backlog in ServerSocket(int, int) should be mentioned more explicitly in API document</a></p><blockquote><p>However, even if we specify preferable number as the number of backlog ,<br>actual number depends on underlying Opreationg System.<br>The documnet should say the below(just example).<br> “Parameters:<br>    port - the specified port, or 0 to use any free port.<br>    backlog - Request of size of the backlog is just passed to underlying OS.<br>              How the OS performs with the request depends on each OS.”</p></blockquote><p>下面接着看最后一个参数：</p><ul><li>InetAddress： 表示监听IP层协议的ip地址，这是一个抽象类，有两个子类Inet4Address和Inet6Address，分别代码ipv4和ipv6的地址，我们不能实例化这两个类的，一般情况下我们使用InetAddress的静态方法getByName(String host)获得实例，API会根据我们传入的地址类型实例化出对应的ipv4或者ipv6地址对象。如果我们传入为空表示监听所有的网卡接口。<br>可以通过NetworkInterface.getNetworkInterfaces()方法获取系统上所有的网卡接口。</li></ul><p>在TCP/IP协议中，通过5个元素可以确定一条连接:</p><table><thead><tr><th>源端IP地址</th><th>源端Port端口</th><th>目的端IP地址</th><th>目的端Port端口</th><th>协议类型</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>所以可以有以下结论：<br>1.我们可以同时监听同一个端口的不同ip地址，在ip地址相同的情况还可以监听不同的协议类型(TCP or UDP)<br>2.客户端在IP地址相同的情况下可以使用不同的端口接入(同一个节点)，端口相同的情况不同的IP可以接入(不同的节点)<br>3.当服务端accept到一个Socket可以通过getLocalSocketAddress()和getRemoteSocketAddress得到本地和远端的ip/port信息<br>4.如果我们要过滤客户端的地址或者端口，从协议上来说，服务端应该是可以限制客户端的IP或者port，但是API并没有提供这样的接口给我们使用，只能accept到Socket后再根据3中所述的方法得到远端的ip和port进行过滤。</p><p>通过这种方式，可以限制接入IP报文中目的地址的报文，假如我们有多个网卡即多个IP地址，通过监听特定的网卡即可实现，如果我们只监听127.0.0.1的回环地址，那么就只有本地的进程能够接入。</p><p>下面的示例代码监听了ipv4,ipv6,通配符方式的地址。如果我们监听了特定的网卡，那么就会优先接入该网卡的ip，不匹配就会接入到通配符的地址，通配符地址监听了系统上的所有网卡，包括ipv4,ipv6。</p><pre><code>ServerSocket serverSocket = new ServerSocket(10086, 2, InetAddress.getByName(&quot;::1&quot;));ServerSocket serverSocket2 = new ServerSocket(10086, 2, InetAddress.getByName(&quot;127.0.0.1&quot;));ServerSocket serverSocket3 = new ServerSocket(10086, 2, null);</code></pre><p><img src="/assets/tcp_connect_listen.png" alt="tcp_connect_listen"></p><p>通过上面的构造方法创建ServerSocket如果成功，就是一个绑定状态的socket，调用isBound()方法返回的就是true，另外其他的几个有参构造方法都是基于这个构造方法，通过netstat命令就可以直接看到效果。<br>API还提供了另外一种无参创建ServerSocket的方法，支持延迟绑定端口：</p><pre><code>public ServerSocket() throws IOException</code></pre><p>提供这个接口是有原因的，为了支持端口重用的选项 SO_REUSEADDR （这个选项下面讲到客户端Socket的时候再详细说明这个选项），要让ServerSocket支持这个选项，必须先设置，然后才能执行绑定操作，否则就是一个未定义的行为：</p><blockquote><p>The behaviour when SO_REUSEADDR is enabled or disabled after a socket is bound (See isBound()) is not defined.</p></blockquote><p>无参构造方法创建的实例代码:</p><pre><code>ServerSocket serverSocket = new ServerSocket();serverSocket.setReuseAddress(true);serverSocket.bind(new InetSocketAddress(InetAddress.getByName(&quot;127.0.0.1&quot;), 10086));</code></pre><h4 id="客户端Socket连接"><a href="#客户端Socket连接" class="headerlink" title="客户端Socket连接"></a>客户端Socket连接</h4><p>客户端创建Socket的方式比较简单：</p><pre><code>Socket socket = new Socket();//创建一个 unbound状态的Socketsocket.connect(new InetSocketAddress(&quot;192.168.1.7&quot;, 10086), 0);//第二个参数为超时的时间，默认情况下为0，表示无限等待</code></pre><p>采用无参的方式创建Socket，OS为自动给我们分配一个合适的端口和网卡接口去连接目的端，网卡接口是通过主机的路由表确定的。</p><p>另外一个构造方法在创建Socket的时候，可以指定源端ip和port，目的端的ip和port，Socket对象创建成功后，得到的Socket就已经是三次握手成功过了，可以进行数据传输。</p><pre><code>public Socket(InetAddress address, int port, InetAddress localAddr,                  int localPort) throws IOException</code></pre><p>调用方法后抓包，就是三次握手的过程，协商MSS，以及是否支持[SACK（Selective ACK）)]等(<a href="https://blog.csdn.net/Mary19920410/article/details/72820477">https://blog.csdn.net/Mary19920410/article/details/72820477</a>)</p><p><img src="/assets/tcp_connect_handshake.png" alt="tcp_connect_handshake"></p><p>三次握手是最小的代价确认对方的网络环境是否OK，是否能进行TCP通信，第一二次客户端为了确定服务端是否OK，第二三次是服务端确定客户端的环境是否OK。</p><h4 id="Socket断开连接"><a href="#Socket断开连接" class="headerlink" title="Socket断开连接"></a>Socket断开连接</h4><p><img src="/assets/tcp_connect_4dis.png?imageView2/2/w/550/h/420/q/100" alt="tcp_connect_4dis"></p><p>涉及Socket断开连接的方法有:</p><ul><li>Socket.shutdownInput();</li><li>Socket.shutdownOutput();</li><li>Socket.close();</li><li>Socket.setLinger(boolean on, int linger);</li></ul><p>由于TCP的传输是双向传输，Socket提供了关闭输入流与输出流的方法，可以使连接处于半关闭的状态，只有两端都关闭了输出流，才是一个TCP连接的正常关闭状态。</p><p>shutdownInput并不会发送TCP相关的断开连接报文，会导致的InputStream读到EOF(-1)，OS会继续接收报文，确认收到的数据并默默地丢弃。</p><p>shutdownOutput会发送一个FIN报文给对端，表示主动关闭的这一方已经没有数据需要发送，然后对端对FIN报文进行确认，被动关闭端依旧可以继续发送数据，主动关闭的一方继续读取数据。</p><p>Server端代码（主动关闭）</p><pre><code>try (ServerSocket serverSocket = new ServerSocket(10086, 2)) &#123;    Socket socket = serverSocket.accept();    socket.shutdownOutput();//FIN    InputStream is = socket.getInputStream();    while (is.read() != -1);//continue read, 此时socket处于FIN_WAIT2    TimeUnit.MINUTES.sleep(10);&#125;</code></pre><p>Client端代码（被动关闭）</p><pre><code>Socket socket = new Socket();socket.connect(new InetSocketAddress(&quot;212.64.20.XX&quot;, 10086));if (socket.getInputStream().read() == -1) &#123;    System.out.println(&quot;read EOF&quot;);//被动关闭，读到EOF， 此时socket处于LAST_ACK的状态&#125;for (int i = 0; i &lt; 5; i++) &#123;    socket.getOutputStream().write(&#39;A&#39;);//依旧可以写数据&#125;</code></pre><p>对于的TCP报文：</p><p><img src="/assets/tcp_connect_half_close.png" alt="tcp_connect_half_close"></p><p>Socket.close() 操作同时将InputStream与OutputStream都关闭，并释放OS分配的资源。<br>由于</p><p>….</p><p>(2021年01月09日更新)一直懒得写完….不过最近看到一本书很好地描述的Java Socket的网络编程，要是以前早点看到这本书就好了，少走一些弯路，不过《TCT/IP卷一》也是必不可少的：</p><p>&lt;&lt;TCP/IP Sockets in Java, Second Edition&gt;&gt;</p><p><a href="https://book.douban.com/subject/3616173/">https://book.douban.com/subject/3616173/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;详解Socket编程—连接与断开&quot;&gt;&lt;a href=&quot;#详解Socket编程—连接与断开&quot; class=&quot;headerlink&quot; title=&quot;详解Socket编程—连接与断开&quot;&gt;&lt;/a&gt;详解Socket编程—连接与断开&lt;/h3&gt;&lt;p&gt;由于Java的Socket接
      
    
    </summary>
    
    
      <category term="socket,tcp" scheme="http://wujingchao.github.io/tags/socket-tcp/"/>
    
  </entry>
  
  <entry>
    <title>详解Socket编程---TCP_NODELAY选项</title>
    <link href="http://wujingchao.github.io/2018/07/22/tcp_nodelay/"/>
    <id>http://wujingchao.github.io/2018/07/22/tcp_nodelay/</id>
    <published>2018-07-21T16:00:00.000Z</published>
    <updated>2024-12-07T09:32:13.097Z</updated>
    
    <content type="html"><![CDATA[<h3 id="详解Socket编程—TCP-NODELAY选项"><a href="#详解Socket编程—TCP-NODELAY选项" class="headerlink" title="详解Socket编程—TCP_NODELAY选项"></a>详解Socket编程—TCP_NODELAY选项</h3><h4 id="Nagle算法描述"><a href="#Nagle算法描述" class="headerlink" title="Nagle算法描述"></a>Nagle算法描述</h4><p>Socket编程中，TCP_NODELAY选项是用来控制是否开启Nagle算法，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数，完整描述：</p><blockquote><p>该算法要求一个TCP连接上最多只能有一个未被确认的小分组，在该小分组的确认到来之前，不能发送其他小分组。</p></blockquote><p>这里的小分组指的是报文长度小于MSS(Max Segment Size)长度的分组（MSS是在TCP握手的时候在报文选项里面进行通告的大小，主要是用来限制另一端发送数据的长度，防止IP数据包被分段，提高效率，一般是链路层的传输最大传输单元大小减去IP首部与TCP首部大小）。</p><p>如果小分组的确认ACK一直没有回来，那么就可能会触发TCP超时重传的定时器。</p><p>下面是一个简单的示意图，开启了Nagle算法与没有开启：</p><p><img src="/assets/nagle_1.png?imageView2/2/w/500/h/420/q/100" alt="nagle"></p><h4 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h4><h5 id="默认开启Nagle算法"><a href="#默认开启Nagle算法" class="headerlink" title="默认开启Nagle算法"></a>默认开启Nagle算法</h5><p>由于局域网内延迟低，不容易看到开启Nagle算法的效果，所以专门整个腾讯云的服务器测试，延迟在40毫秒左右。</p><p><img src="/assets/tcp_nodelay_ping.png" alt="ping"></p><p>Java代码与Unix C的Socket接口类似，这里使用Java代码作为示例简单一点。默认情况下Nagle算法是开启的，即socket.getTcpNoDelay()返回的数值为false，我们先分析这种场景。</p><p>Receiver的代码：</p><pre><code>try (ServerSocket serverSocket = new ServerSocket()) &#123;    serverSocket.bind(new InetSocketAddress(10086));//wildcard ip    Socket socket = serverSocket.accept();    System.out.println(&quot;Accept New Socket&quot;);    System.out.println(&quot;Tcp No Delay : &quot; + socket.getTcpNoDelay());    InputStream is = socket.getInputStream();    OutputStream os = socket.getOutputStream();    int result;    while((result = is.read()) != -1) &#123;        System.out.println((char)result);    &#125;    TimeUnit.MINUTES.sleep(1);&#125;</code></pre><p>Sender的代码：</p><pre><code>try(Socket socket = new Socket()) &#123;    socket.connect(new InetSocketAddress(&quot;212.64.20.XX&quot;, 10086));    System.out.println(&quot;Tcp No Delay : &quot; + socket.getTcpNoDelay());    InputStream is = socket.getInputStream();    OutputStream os = socket.getOutputStream();    for (byte c : &quot;TCP_NO_DELAY&quot;.getBytes()) &#123;        TimeUnit.MILLISECONDS.sleep(10);        os.write(c);        os.flush();    &#125;    TimeUnit.MINUTES.sleep(1);&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><p>与服务器的延时在40毫秒左右，所以Sender这里每隔10毫秒就发送一次就可以演示出累计的小分组在收到ACK后才发送。注意如果是TCP发送的数据延迟还包含链路来回的延迟与Receiver捎带确认的延迟。</p><p>这里抓包工具使用的是tcpdump，导出pcap文件后再使用wireshark观察发送与接收数据的过程。</p><pre><code>$ sudo tcpdump -v port 10086 -w TCP_DELAY.pcap</code></pre><p><img src="/assets/tcp_nodelay_cap1.png" alt="cap"></p><ul><li><p>首先第一行到第三行是TCP三次握手的报文，可以看到双方都各自通告的MSS大小，发送端的报文小于这个大小就可以理解为小分组</p></li><li><p>第四行是Sender向Receiver发送的第一个字符’T’，对应的Len=1</p></li><li><p>第五行是Receiver回来对第四行发送消息的确认ACK</p></li><li><p>第六行，前面使用ping测试的延迟在40毫秒左右，而我们每10毫秒就会一个字符写到OS维护的发送缓冲区，所以确认ACK回来后，就已经累计了4个字符”CP_N”，发送的数据就是这4个字符</p></li><li><p>之后的流程和上面的类似，可能会出现发送不是4个字符的情况，出现的原因就是延迟可能小于或者大于40毫秒</p></li></ul><p>下面是使用wireshark导出的时序图帮助进一步帮助理解这个流程。</p><p><img src="/assets/tcp_nodelay_flow1.png?imageView2/2/w/474/h/375/q/100" alt="flow"></p><h5 id="关闭Nagle算法"><a href="#关闭Nagle算法" class="headerlink" title="关闭Nagle算法"></a>关闭Nagle算法</h5><p>只需要在发送数据之前对Socket调用一个简单的方法就可以关闭Nagle算法：</p><pre><code>socket.setTcpNoDelay(true);</code></pre><p>直接抓包，看下报文：</p><p><img src="/assets/tcp_nodelay_cap2.png" alt="cap"></p><p>可以看到，在Sender每10毫秒发送一个字符，不需要等到Receiver发送确认ACK，就继续发送，没有将数据放到OS维护的缓冲区。</p><p>下面是使用wireshark导出的时序图：</p><p><img src="/assets/tcp_nodelay_flow2.png?imageView2/2/w/800/h/800/q/100" alt="flow"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个选项应该根据适合的场景进行判断关闭与否，例如实时性要求比较高的场景，类似用户鼠标操作，键盘输入，触摸屏事件输入，状态更新等这种连续的小分组数据，需要在对端立刻呈现，让用户尽可能感受不到延迟。但是如果网络延迟比较高，采用这种方式，那么会导致网路利用率下降。</p><p>一般类似HTTP协议请求响应的模型的场景不太需要考虑禁用这个算法，因为在一条TCP连接上发送小报文，不管多小都代表了服务端任务执行的指示，完成了这个请求之后才能继续执行下一个请求，即使Sender端提前发送过去也没有作用，所以开启Nagle算法是能够优化网络传输的，并且在Receiver端有捎带延迟确认，省掉单独的ACK确认进一步优化小分组传输。</p><p>另外HTTP2与HTTP协议不同，HTTP2是在一条TCP连接上进行所有HTTP请求，并且请求头部是压缩的就进一步加大了请求小分组的可能性，多个小分组HTTP请求并且分组大小的和小于MSS就会导致有延迟的现象，所以HTTP2的实现TCP_NODELAY选项是默认开启的。关于这点可以<a href="(https://http2.github.io/faq/#Will%20I%20need%20TCP_NODELAY%20for%20my%20HTTP/2%20connections">参考HTTP2对TCP_NODELAY的描述</a>)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;详解Socket编程—TCP-NODELAY选项&quot;&gt;&lt;a href=&quot;#详解Socket编程—TCP-NODELAY选项&quot; class=&quot;headerlink&quot; title=&quot;详解Socket编程—TCP_NODELAY选项&quot;&gt;&lt;/a&gt;详解Socket编程—TCP
      
    
    </summary>
    
    
      <category term="socket,tcp" scheme="http://wujingchao.github.io/tags/socket-tcp/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化相关</title>
    <link href="http://wujingchao.github.io/2018/07/02/android-optimize/"/>
    <id>http://wujingchao.github.io/2018/07/02/android-optimize/</id>
    <published>2018-07-01T16:00:00.000Z</published>
    <updated>2024-12-07T08:58:42.050Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android性能优化相关"><a href="#Android性能优化相关" class="headerlink" title="Android性能优化相关"></a>Android性能优化相关</h3><h4 id="Android官方的性能优化指南"><a href="#Android官方的性能优化指南" class="headerlink" title="Android官方的性能优化指南"></a>Android官方的性能优化指南</h4><p>Android Performance Patterns Season 1 [<a href="http://hukai.me/android-performance-patterns//">Article</a>|<a href="https://www.youtube.com/watch?v=R5ON3iwx78M&amp;t=44s&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&amp;index=45">Video</a>]</p><p>Android Performance Patterns Season 2[<a href="http://hukai.me/android-performance-patterns-season-2/">Article</a>|<a href="https://www.youtube.com/watch?v=fEEulSk1kNY&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&amp;index=38">Video</a>]</p><p>Android Performance Patterns Season 3[<a href="http://hukai.me/android-performance-patterns-season-3/">Article</a>|<a href="https://www.youtube.com/watch?v=ORgucLTtTDI&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&amp;index=28">Video</a>]</p><p>Android Performance Patterns Season 4[<a href="http://hukai.me/android-performance-patterns-season-4/">Article</a>|<a href="https://www.youtube.com/watch?v=7lxVqqWwTb0&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&amp;index=11">Video</a>]</p><p>Android Performance Patterns Season 5[<a href="http://hukai.me/android-performance-patterns-season-5/">Article</a>|<a href="https://www.youtube.com/watch?v=qk5F6Bxqhr4&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Video</a>]</p><p>Android Performance Patterns Season 6[<a href="http://hukai.me/android-performance-patterns-season-6/">Article</a>|<a href="https://www.youtube.com/watch?v=AkafJ6NdrhY&amp;list=PLWz5rJ2EKKc-9gqRx5anfX0Ozp-qEI2CF">Video</a>]</p><p><a href="http://hukai.me/android-performance-render/">Android性能优化之渲染篇</a></p><p><a href="http://hukai.me/android-performance-compute/">Android性能优化之运算篇</a></p><p><a href="http://hukai.me/android-performance-memory/">Android性能优化之内存篇</a></p><p><a href="http://hukai.me/android-performance-battery/">Android性能优化之电量篇</a></p><p><a href="http://hukai.me/android-performance-oom/">Android内存优化之OOM</a></p><h4 id="精简安装包"><a href="#精简安装包" class="headerlink" title="精简安装包"></a>精简安装包</h4><ul><li><a href="https://developer.android.com/topic/performance/reduce-apk-size">https://developer.android.com/topic/performance/reduce-apk-size</a></li><li><a href="https://www.diycode.cc/topics/586">Android 应用瘦身，从 18MB 到 12.5MB</a></li><li><a href="https://www.youtube.com/watch?v=AdfKNgyT438&amp;index=18&amp;list=PLWz5rJ2EKKc-odHd6XEaf7ykfsosYyCKp">Google I/O ‘17</a></li></ul><h4 id="Android性能检测工具"><a href="#Android性能检测工具" class="headerlink" title="Android性能检测工具"></a>Android性能检测工具</h4><p><a href="https://developer.android.com/studio/command-line/systrace">Systrace</a></p><ul><li><a href="https://developer.android.com/topic/performance/vitals/render">Slow Rendering</a></li><li><a href="https://www.youtube.com/watch?v=Qfo5fdoXrTU">Android Performance: Overview (Google I/O ‘17)</a></li><li><a href="https://www.youtube.com/watch?v=9HtTL_RO2wI&amp;list=PLWz5rJ2EKKc-odHd6XEaf7ykfsosYyCKp&amp;index=46">Android Performance: UI (Google I/O ‘17)</a></li><li><a href="http://gityuan.com/2016/01/17/systrace/">性能工具Systrace</a></li><li><a href="https://zhuanlan.zhihu.com/p/27331842">手把手教你使用Systrace（一）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android性能优化相关&quot;&gt;&lt;a href=&quot;#Android性能优化相关&quot; class=&quot;headerlink&quot; title=&quot;Android性能优化相关&quot;&gt;&lt;/a&gt;Android性能优化相关&lt;/h3&gt;&lt;h4 id=&quot;Android官方的性能优化指南&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="android" scheme="http://wujingchao.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>阅读Binder代码的一些疑问</title>
    <link href="http://wujingchao.github.io/2018/05/01/binder_question/"/>
    <id>http://wujingchao.github.io/2018/05/01/binder_question/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2024-12-07T09:22:19.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="阅读Binder代码的一些疑问"><a href="#阅读Binder代码的一些疑问" class="headerlink" title="阅读Binder代码的一些疑问"></a>阅读Binder代码的一些疑问</h3><p>1.BinderInternal.getContextObject(null)的时候，有没有发binder命令？</p><p>有，会使用PING_TRANSACTION，检查ServieManger Binder对象是否还活着，如果还活着的话，就给上层返回一个BpBinder对象。</p><p>2.Service将自己加到ServerManager里面，在Service里面存的是什么东西？</p><p> 存放在ServiceManager维护的svcinfo的链表里，主要的信息有两个，一个是uint32类型的handle，以及Service的Name</p><p> 那这个handle到底是什么东西，表示什么？</p><p> BBinder对象的地址</p><p> 3.对binder驱动做mmap系统调用的作用是什么？</p><p> 将一页物理内存映射到内核的虚拟地址空间和进程的虚拟地址空间，并把该空闲的内存块加到binder_proc维护的链表里面。有其他进程往该进程发数据，驱动直接把其他进程空间的数据往这块内存拷贝，这样，都能该进程就可以直接访问该内存里面的数据。</p><p> 4.Parcel.remove部分数据是怎么实现的?</p><p> 5.应用的Binder线程是怎么启动的，在哪里启动的？</p><p> 6.servicemanager以什么形式在系统中存在？</p><p> 后台进程的形态，在内核启动的时候，解析init.rc脚本的时候，就把位于/system/bin/servicemanager可执行程序启动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;阅读Binder代码的一些疑问&quot;&gt;&lt;a href=&quot;#阅读Binder代码的一些疑问&quot; class=&quot;headerlink&quot; title=&quot;阅读Binder代码的一些疑问&quot;&gt;&lt;/a&gt;阅读Binder代码的一些疑问&lt;/h3&gt;&lt;p&gt;1.BinderInternal.g
      
    
    </summary>
    
    
      <category term="binder" scheme="http://wujingchao.github.io/tags/binder/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 14.04 x64 搭建SS服务</title>
    <link href="http://wujingchao.github.io/2018/04/23/ss/"/>
    <id>http://wujingchao.github.io/2018/04/23/ss/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2024-12-07T09:31:24.475Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ubuntu-14-04-x64-搭建SS服务"><a href="#Ubuntu-14-04-x64-搭建SS服务" class="headerlink" title="Ubuntu 14.04 x64 搭建SS服务"></a>Ubuntu 14.04 x64 搭建SS服务</h3><p>最近找到一个比较好的<a href="https://qaz.cloud">梯子</a>，速度也很快，可以看YOUTU，而且可以按月付，不用担心跑路，最便宜的套餐只要¥10!</p><p>每次科学上网的ip出现了问题，就需要去销毁原来的服务器，重新申请ip，然后又重新搜一遍ss搭建的流程，下次不搜了，自己记录一下，后续有时间打算弄个脚本。（已有现成的脚本<a href="https://github.com/teddysun/shadowsocks_install）">https://github.com/teddysun/shadowsocks_install）</a></p><h4 id="shadowsocks-服务器安装"><a href="#shadowsocks-服务器安装" class="headerlink" title="shadowsocks 服务器安装"></a>shadowsocks 服务器安装</h4><p>更新软件源</p><pre><code>sudo apt-get update</code></pre><p>然后安装 PIP 环境</p><pre><code>sudo apt-get install python-pip</code></pre><p>直接安装 shadowsocks</p><pre><code>sudo pip install shadowsocks</code></pre><h4 id="运行-shadowsocks-服务器"><a href="#运行-shadowsocks-服务器" class="headerlink" title="运行 shadowsocks 服务器"></a>运行 shadowsocks 服务器</h4><p>配置文件进行配置，方法创建/etc/shadowsocks.json文件，填入如下内容：</p><pre><code>&#123;    &quot;server&quot;:&quot;&quot;,    &quot;server_port&quot;:10086,    &quot;local_address&quot;: &quot;127.0.0.1&quot;,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;&quot;,    &quot;timeout&quot;:30000,    &quot;method&quot;:&quot;aes-256-cfb&quot;&#125;</code></pre><p>各字段的含义：</p><table><thead><tr><th>name</th><th style="text-align:center">info</th></tr></thead><tbody><tr><td>server</td><td style="text-align:center">服务器 IP (IPv4/IPv6)，注意这也将是服务端监听的 IP 地址</td></tr><tr><td>server_port</td><td style="text-align:center">服务器端口</td></tr><tr><td>local_port</td><td style="text-align:center">本地端端口</td></tr><tr><td>password</td><td style="text-align:center">用来加密的密码</td></tr><tr><td>timeout</td><td style="text-align:center">超时时间（秒）</td></tr><tr><td>method</td><td style="text-align:center">加密方法，可选择 “bf-cfb”, “aes-256-cfb”, “des-cfb”, “rc4″, 等等。默认是一种不安全的加密，推荐用 “aes-256-cfb”</td></tr></tbody></table><p>创建完毕后，赋予文件权限：</p><pre><code>sudo chmod 755 /etc/shadowsocks.json</code></pre><p>为了支持这些加密方式，你要需要安装</p><pre><code>sudo apt–get install python–m2crypto</code></pre><p>然后使用配置文件在后台运行：</p><pre><code>sudo ssserver -c /etc/shadowsocks.json -d start</code></pre><h4 id="配置开机自启动"><a href="#配置开机自启动" class="headerlink" title="配置开机自启动"></a>配置开机自启动</h4><p>bash shell 启动时会执行/etc/rc.local这个脚本，所以在该脚本里面加入启动命令，就可以实现自启动。</p><pre><code>sudo vi /etc/rc.local</code></pre><p>在 exit 0 这一行的上边加入如下</p><pre><code>/usr/local/bin/ssserver –c /etc/shadowsocks.json</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Ubuntu-14-04-x64-搭建SS服务&quot;&gt;&lt;a href=&quot;#Ubuntu-14-04-x64-搭建SS服务&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 14.04 x64 搭建SS服务&quot;&gt;&lt;/a&gt;Ubuntu 14.04 x64 
      
    
    </summary>
    
    
      <category term="科学上网, shadowsocket" scheme="http://wujingchao.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-shadowsocket/"/>
    
  </entry>
  
  <entry>
    <title>使用数字电路的基础逻辑门搭建计算机</title>
    <link href="http://wujingchao.github.io/2018/04/05/gate/"/>
    <id>http://wujingchao.github.io/2018/04/05/gate/</id>
    <published>2018-04-04T16:00:00.000Z</published>
    <updated>2024-12-07T09:24:19.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用数字电路的基础逻辑门搭建计算机"><a href="#使用数字电路的基础逻辑门搭建计算机" class="headerlink" title="使用数字电路的基础逻辑门搭建计算机"></a>使用数字电路的基础逻辑门搭建计算机</h3><blockquote><p>逻辑门（Logic Gates)是在集成电路(Integrated Circuit)上的基本组件。简单的逻辑门可由晶体管组成。这些晶体管的组合可以使代表两种信号的高低电平在通过它们之后产生高电平或者低电平的信号。高、低电平可以分别代表逻辑上的“真”与“假”或二进制当中的1和0，从而实现逻辑运算。</p></blockquote><p>此外，逻辑门也可以使用继电器实现，早期的计算机就是使用它来完成的。</p><h4 id="基础逻辑门"><a href="#基础逻辑门" class="headerlink" title="基础逻辑门"></a>基础逻辑门</h4><p>先介绍基本的逻辑门，并附上它们的真值表，虽然很简单，但是计算机复杂的功能都是由这些简单的逻辑门组成的。</p><h5 id="与门（AND-Gate）"><a href="#与门（AND-Gate）" class="headerlink" title="与门（AND Gate）"></a>与门（AND Gate）</h5><p>与门</p><table><thead><tr><th>A</th><th>B</th><th>out</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>即只有同时输入都为真是，输出才为真，门里面的真假值是使用高低电平来表示的，例如0V为低电平表示假，5V为高电平表示为真， A，B表示输入，out表示输出。</p><h5 id="或门（OR-Gate）"><a href="#或门（OR-Gate）" class="headerlink" title="或门（OR Gate）"></a>或门（OR Gate）</h5><p><img src="/assets/or_gate.png" alt="或门"></p><table><thead><tr><th>A</th><th>B</th><th>out</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>即有一个为真，输出就为真。</p><h5 id="非门（NOT-Gate）"><a href="#非门（NOT-Gate）" class="headerlink" title="非门（NOT Gate）"></a>非门（NOT Gate）</h5><p><img src="/assets/not_gate.png" alt="非门"></p><table><thead><tr><th>A</th><th>out</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr></tbody></table><p>即输入与输出相反</p><p>其实到这里，逻辑基本的门就已经介绍完了，剩下的门只不过这三种门的组合。</p><h5 id="或非门（NOR-Gate）"><a href="#或非门（NOR-Gate）" class="headerlink" title="或非门（NOR Gate）"></a>或非门（NOR Gate）</h5><p><img src="/assets/nor_gate.png" alt="或非门"></p><table><thead><tr><th>A</th><th>B</th><th>out</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>由或门，非门组成，只有两个输入都为假时，输入才为真。</p><h5 id="与非门（NAND-Gate）"><a href="#与非门（NAND-Gate）" class="headerlink" title="与非门（NAND Gate）"></a>与非门（NAND Gate）</h5><p><img src="/assets/nand_gate.png" alt="与非门"></p><table><thead><tr><th>A</th><th>B</th><th>out</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>由与门，非门组成，只有两个输入都为真时，输出才为假。</p><h5 id="异或门（XOR-Gate）"><a href="#异或门（XOR-Gate）" class="headerlink" title="异或门（XOR Gate）"></a>异或门（XOR Gate）</h5><p><img src="/assets/xor_gate.png" alt="异或门1"></p><table><thead><tr><th>A</th><th>B</th><th>out</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>异或门由或门，与非门，与门组成，有特定的电气符号：</p><p><img src="/assets/and_gate2.png" alt="异或门2"></p><h4 id="二进制加法器"><a href="#二进制加法器" class="headerlink" title="二进制加法器"></a>二进制加法器</h4><p>利用上面介绍的基础逻辑门，就可以实现二进制加法器，先来看一下一位的二进制加法器怎么实现。<br>一位二进制加法很简单，可以将结果分为进位位与加和输出为：</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">加和位</th><th style="text-align:center">进位</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p>观察加和位的输出与进位的输出，加和位可以使用异或门来实现，进位可以使用与门来实现，将这两个门连接在一起就是这个样子：</p><p><img src="/assets/half_plus1.png" alt="半加器1"></p><p>刚好和上面的真值表的输出一致。</p><p>这个被称为半加器，因为大多数二进制加法都是多于一位的，要考虑其低位的进位。</p><p>为了简单，简化的半加器的符号：</p><p><img src="/assets/half_plus2.png" alt="半加器2"></p><p>利用两个半加器就可以组成一个全加器：</p><p><img src="/assets/full_plus1.png" alt="全加器1"></p><p>为了简单，简化的全加器的符号：</p><p><img src="/assets/full_plus2.png" alt="全加器2"></p><p>得到了这全加器，很容易就可以扩展二进制加法器的位数8位，16位，32位….例如扩展为8位，8个全加器“串联”在一起即可，每一位的进位输出是下一位的进位输入。下图表示8位的加法器图示：</p><p><img src="/assets/8_bit_plus.png" alt="8位加法器"></p><h4 id="二进制减法的实现"><a href="#二进制减法的实现" class="headerlink" title="二进制减法的实现"></a>二进制减法的实现</h4><p>由于二进制的减法涉及借位复杂的操作，实现起来电路较为复杂，通常是利用加法来实现，没错了，就是利用将减数求补码与被减数相加来实现，可以将符号位与数值域统一处理。下面介绍实现的原理。</p><pre><code>求253-176的运算结果：  1111 1101 - 1011 0000= 1111 1101 - 1011 0000 + 1 0000 0000 - 1 0000 0000= 1111 1101 - 1011 0000 + 1111 1111 + 1 - 1 0000 0000= 1111 1101 + (1111 1111 - 1011 0000 + 1) - 1 0000 0000//被括弧的这个式子就是176的补码= 1111 1101 + 0100 1111 + 1 - 1 0000 0000//其实加法器只做到了这一步，进位后最高为溢出，剩下的就是我们想要的结果= 1 0100 1101 - 1 0000 0000= 0100 1101</code></pre><p>所以我们只需要在原来加法器的基础上，将减数进行补码运算即可。</p><p><img src="/assets/8_bit_dec.png" alt="8位减法器"></p><h4 id="RAM实现"><a href="#RAM实现" class="headerlink" title="RAM实现"></a>RAM实现</h4><p>上面我们已经完成了二进制的加法与减法，现在我们需要将我们的运算结果存储起来。</p><h5 id="振荡器-时钟"><a href="#振荡器-时钟" class="headerlink" title="振荡器(时钟)"></a>振荡器(时钟)</h5><p>我们将非门的输入与输出连接起来，得到这样的一个电路：</p><p><img src="/assets/oscillator.png" alt="振荡器"></p><p>由于非门是利用继电器的机制实现的，所以这个电路出现01交替的输出，频率取决于非门通断的速度。</p><p>可以得到这样一个过程：</p><p><img src="/assets/oscillator_out.png" alt="振荡器输出"></p><h5 id="RS触发器"><a href="#RS触发器" class="headerlink" title="RS触发器"></a>RS触发器</h5><p>可以使用触发器来保存位的信息，能够保存一位的信息，就可以扩展到保存多位的信息。</p><p>RS触发器的电路如下，由两个或非门组成：</p><p><img src="" alt="RS触发器"></p><p>真值表：</p><table><thead><tr><th>S</th><th>R</th><th>Q</th><th>Q`</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>0</td><td>Q</td><td>Q`</td></tr><tr><td>1</td><td>1</td><td>NA</td><td>NA</td></tr></tbody></table><p>输入端S可以用来置位，输入端R可以用来复位。当我们向输入端输入信息之后，RS触发器就可以记住其状态。</p><p>待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用数字电路的基础逻辑门搭建计算机&quot;&gt;&lt;a href=&quot;#使用数字电路的基础逻辑门搭建计算机&quot; class=&quot;headerlink&quot; title=&quot;使用数字电路的基础逻辑门搭建计算机&quot;&gt;&lt;/a&gt;使用数字电路的基础逻辑门搭建计算机&lt;/h3&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MTP协议总结与Android源码分析</title>
    <link href="http://wujingchao.github.io/2018/01/28/mtp/"/>
    <id>http://wujingchao.github.io/2018/01/28/mtp/</id>
    <published>2018-01-27T16:00:00.000Z</published>
    <updated>2024-12-07T09:26:43.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MTP协议与Android源码分析"><a href="#MTP协议与Android源码分析" class="headerlink" title="MTP协议与Android源码分析"></a>MTP协议与Android源码分析</h3><p>前段时间有做MTP协议扩展的相关的内容，在这里总结一下。</p><p>（注意协议方面有很多细节一篇简短的文章是不可能面面俱到，这里只是学习总结，本人接触协议的时间也不是很长，难免有纰漏，有错误之处请不吝指教）。</p><h4 id="协议部分"><a href="#协议部分" class="headerlink" title="协议部分"></a>协议部分</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>Media Transfer Protocol即媒体传输协议，主要是用来管理移动设备上的图片、视频、音频等媒体信息，典型的有Android设备，相机设备。</p><p>MTP协议是应用层协议，底层协议可以走USB或TCP/IP协议，只要能够无差错传输即可。</p><p><img src="/assets/tcp_underlying_.png" alt="tcp_underlying"></p><p>MTP协议框架上面定义了很多多媒体相关的命令，例如获取设备信息，获取对象信息，本文着重介绍MTP协议框架，然后举例特定的命令帮助理解。</p><h5 id="协议模型"><a href="#协议模型" class="headerlink" title="协议模型"></a>协议模型</h5><p>MTP协议有两个角色，类似于客户端与服务端，在MTP协议里面有特定的称号，发起请求的叫Initiator,对请求进行响应的叫Responder。Initiator通常对应于PC/MAC宿主机，Responder对应于被管理的设备，例如Android手机。任何操作都需要Inititaor发起，然后Reponder进行响应。</p><p>Initiator对Reponder的大多数请求都是需要打开一个Session会话，类似于HTTP里面的Session，用于保存上下文相关的环境信息，例如，在MTP传输媒体文件过程中，Inititor传输媒体文件到Reponder是需要发送两次请求才能完成的，第一次请求发送SendObjectInfo的消息，告诉Reponder即将要发送的媒体信息，包括大小，格式，媒体文件名称等；第二次请求发送SendObject传输实际的文件，在这两次请求中第二次请求需要使用第一次请求保存的相关信息，所以就需要保持在一个Session会话里面。MTP按理论上说是可以支持多Session会话的。</p><p>还有另一个关键的概念，就是Transaction，对应于Initiator发起请求，然后数据传输，Responder响应一次完整的过程，有点类似于数据库里面的事务，比如Initiator发起一次请求，在Reponder没有响应之前，是不能进行另一次请求。所以在USB单Session实现中，Initiator是不能同时发送多次请求的。</p><h5 id="传输模型"><a href="#传输模型" class="headerlink" title="传输模型"></a>传输模型</h5><p>前面介绍到Transaction对应于Initiator发起请求，然后数据传输，Responder响应。所以对于的请求，数据，响应传输分为三个阶段：</p><ul><li>Request Phase</li><li>Data Phase</li><li>Reponse Phase</li></ul><p>其中Data Phase是<strong>可选</strong>的，并且是<strong>单向</strong>的。<br>单向的定义就规定了Data Phase的数据流要么是Initiator到Reponder(以下简称I-&gt;R),要么是Reponder到Initiator(以下简称R-&gt;I)。<br>MTP协议也规定Data Phase是可选的，就是意味着Initiator发送完成请求后，Reponder就直接响应，不需要传输数据，因为有的MTP消息不需要传输数据，Request与Repond本身就可以传递少量的参数。</p><p>下图就是传输的三种情况：</p><p><img src="/assets/mtp_transfer_nodata.png?imageView2/2/w/656/h/500/q/100" alt="mtp_transfer_i-r"></p><p><img src="/assets/mtp_transfer_i-r.png?imageView2/2/w/656/h/500/q/100" alt="mtp_transfer_i-r"></p><p><img src="/assets/mtp_transfer_r-i.png?imageView2/2/w/656/h/500/q/100" alt="mtp_transfer_i-r"></p><p>数据流的字段是有Request的字段OperationCode决定的，根据不同的功能决定Data阶段的数据流向。比如Initiator读取媒体信息GetObjectInfo的数据流向就是R-&gt;I；Initiator发送媒体文件信息SenObjectInfo的数据流向就是I-&gt;R; 读取设备上媒体文件的个数GetObjectNum由于Reponse中携带的参数已经能够满足表示数量，所以就不需要Data Phase。</p><p>下面来说一下Request与Reponse的Dataset，用来表示能够携带哪些参数。Request与Response的Dataset是一样的。需要特别注意的是，不同的底层协议对于Dataset的存放方式是不同的，MTP SEPC只给出的是USB的实现方式。</p><p><img src="/assets/mtp_req_resp_dataset.png" alt="mtp_req_resp_dataset"></p><p>最关键的是操作码OperationCode定义Request请求要进行什么样的操作，MTP Responder 该处理什么样的任务，然后根据功能决定Data的数据流向。<br>对于USB来说是单Session的实现方式，在其实现的数据集是不包含sessionID这个字段的，但是在发送大多数Request之前，也还是需要发送OpenSession这个Request请求。</p><p>TransactionID由Initiator指定，在一次完整的Request到Response都要指定相同的值，不需要每一次都相同。</p><p>Request与Response可以携带0到5个参数，根据OperationCode的功能来决定。</p><p>还有一种比较特殊的消息就是Reponder可以直接发送Event给Initiator，用来通知Initiator，Reponder出现了一些状况或者发生了一些变化，可以与Transaction关联，也可以不可Transaction关联，根据Event的事件来定。比如设备上新增了一条媒体文件的信息，就需要通过Event事件来通知Initiator来更新。</p><p><img src="/assets/mtp_transfer_event.png?imageView2/2/w/656/h/400/q/100" alt="mtp_transfer_event"></p><p>Event是不能传递二进制数据的，只能携带0到3个参数，其Dataset为:</p><p><img src="/assets/mtp_transfer_event_dataset.png?imageView2/2/w/656/h/400/q/100" alt="mtp_transfer_event_dataset"></p><p>常用功能的Request与Reponse的OperationCode，Event的EventCode，在MTP Spec规格文档里面有定义，不同的Code对应什么样含义以及携带什么样的参数，还给出了要厂商可以扩展的Code范围。</p><p>之前看Android源码的时候就有点懵，spec上面的定义的Dataset与源码里面的对不上，后来看到sepc文档最后的这个表格才知道不同的实现方式数据的存放是不一样的，下面这个就是USB定义的MTP数据包，Request，Data，Response都要携带定义的头部信息，Initator与Responder都要读取USB数据包来解析MTP数据包。</p><p><img src="/assets/mtp_transfer_usb_container_dataset.png?imageView2/2/w/656/h/400/q/100" alt="mtp_transfer_usb_container_dataset"></p><p>Request与Response的Payload就是携带的那0到5个参数，Data的Payload就是二进制数据，可能是媒体文件，也有可能是自定义的数据格式。</p><h5 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h5><p><img src="/assets/mtp_transfer_objectinfo.png?imageView2/2/w/656/h/420/q/100" alt="mtp_transfer_objectinfo.png"></p><p>StorageID：对应一个设备上的存储<strong>分区</strong>，表现形式就是无符号32位的整数uint32, 高16位表示存储设备，低16位表示对应存储设备的分区。例如Android设备，有内部存储与外置SD卡，SD卡可能有多个分区，就对应不同的StorageID。</p><p>ObjectHandle:实际就是一个int32的对象id，对应设备上的一个个媒体文件对象，可能是文件夹或者是媒体文件，MTP读取文件或者发送文件都需要这个id，其通常包含一个父Object，类似于文件系统的目录树，根路径的值比较特殊，0xFFFFFFFF</p><p>ObjectFormat：媒体类型</p><p>….其余的不难理解，需要时查询文档</p><h4 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h4><p>Android源码的处理过程：</p><p>处理MTP请求的应用就是提供媒体数据库的MediaProvider，对应的包名为com.android.providers.media，对于源码树的位置packages/providers/MediaProvider。<br>其本身是一个系统应用，在AndroidManifest里面监听USB状态变化的广播：</p><pre><code>&lt;receiver android:name=&quot;.MtpReceiver&quot;&gt;   &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;   &lt;/intent-filter&gt;   &lt;intent-filter&gt;        &lt;action android:name=&quot;android.hardware.usb.action.USB_STATE&quot; /&gt;   &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><p>当连上USB数据线，就会将MtpService.java启动，然后加载动态库，开启一个线程,jni调用MTPServer.cpp的run方法，不断地从mtp驱动读消息，处理，响应。而MTP的Object对应的就是文件数据里面的一个个文件。</p><p><img src="/assets/mtp_transfer_mtpserver_main_flow.png?imageView2/2/w/656/h/420/q/100" alt="mtp_transfer_mtpserver_main_flow"></p><p>MtpServer.cpp的run方法:</p><pre><code>void MtpServer::run() &#123;    int fd = mFD;//打开的mtp驱动文件描述符    while (1) &#123;        int ret = mRequest.read(fd);//读取Request请求，放到mRequest封装的类里面        //...        MtpOperationCode operation = mRequest.getOperationCode();        MtpTransactionID transaction = mRequest.getTransactionID();        // FIXME need to generalize this        bool dataIn = (operation == MTP_OPERATION_SEND_OBJECT_INFO                    || operation == MTP_OPERATION_SET_OBJECT_REFERENCES                    || operation == MTP_OPERATION_SET_OBJECT_PROP_VALUE                    || operation == MTP_OPERATION_SET_DEVICE_PROP_VALUE);//根据OperationCode来处理Data Phase的数据流向        if (dataIn) &#123;            int ret = mData.read(fd);            //...        &#125; else &#123;            mData.reset();        &#125;        if (handleRequest()) &#123;//handleRequest根据不同的OperationCode功能处理不同的任务            if (!dataIn &amp;&amp; mData.hasData()) &#123;                mData.setOperationCode(operation);                mData.setTransactionID(transaction);                ALOGV(&quot;sending data:&quot;);                ret = mData.write(fd);            &#125;            mResponse.setTransactionID(transaction);            ret = mResponse.write(fd);//响应            const int savedErrno = errno;        &#125; else &#123;            ALOGV(&quot;skipping response\n&quot;);        &#125;    &#125;    //....&#125;</code></pre><p>对照MTP SEPC文档的附录接口看代码比较简单，就是读取解析结构化数据或者封装需要发送的结构化数据，但是有一点需要特别注意，<br>处理发送文件与读取文件的操作不是在用户空间完成的，而是通过IOCTL，调用驱动接口在内核空间完成，这样会比较高效，不用再用户空间拷贝一份处理给内核空间，而是有内核空间直接发送。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MTP协议与Android源码分析&quot;&gt;&lt;a href=&quot;#MTP协议与Android源码分析&quot; class=&quot;headerlink&quot; title=&quot;MTP协议与Android源码分析&quot;&gt;&lt;/a&gt;MTP协议与Android源码分析&lt;/h3&gt;&lt;p&gt;前段时间有做MTP协
      
    
    </summary>
    
    
      <category term="MTP" scheme="http://wujingchao.github.io/tags/MTP/"/>
    
  </entry>
  
  <entry>
    <title>快速排序的另一种简单写法</title>
    <link href="http://wujingchao.github.io/2017/05/14/quick-sort/"/>
    <id>http://wujingchao.github.io/2017/05/14/quick-sort/</id>
    <published>2017-05-13T16:00:00.000Z</published>
    <updated>2024-12-07T09:29:40.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速排序的另一种简单写法"><a href="#快速排序的另一种简单写法" class="headerlink" title="快速排序的另一种简单写法"></a>快速排序的另一种简单写法</h3><p>最近在看<a href="https://book.douban.com/subject/1139336/">TCPL</a>，第四章的函数与程序结构里面有一个快速排序的例子，并且几句话就把快速排序总结了，非常精炼。快速排序利用的是分治的思想(Divide Conquer)，理解了分治，就能理解快排。这里记录一下，并且讲解一下程序的原理。</p><blockquote><p>对于一个给定的数组，从中选择一个元素，以该元素为界将其余元素划分为两个子集，一个子集中的所有元素都小于该元素，另一个子集中的元素都大于或等于该元素。对这两个子集递归执行这一过程当子集中的元素小于2时，这个子集就不需要再次排序，终止递归。</p></blockquote><pre><code>static void sortRecursively(int[] arr, int left, int right) &#123;    if (left &gt;= right) &#123;        return;    &#125;    int pivot = (left + right)/2;    swap(arr, left, pivot);    int last = left;    for (int i = left + 1; i &lt;= right; i++) &#123;        if (arr[left] &gt; arr[i]) &#123;            swap(arr, ++last, i);        &#125;    &#125;    swap(arr, left, last);    sortRecursively(arr, left, last - 1);    sortRecursively(arr, last + 1, right);&#125;</code></pre><p>其中交换数组元素的代码被抽取出来：</p><pre><code>static void swap(int[] arr, int k, int j) &#123;    int tmp = arr[k];    arr[k] = arr[j];    arr[j] = tmp;&#125;</code></pre><p>首先选取枢纽点，这里选取的是元素中心位置，然后交换到最左侧的left，这样做的目的便于后面双指针的移动。</p><p><img src="/assets/quick_sort1.png?imageView2/2/w/400/h/200/q/100" alt="quick_sort1"></p><p>交换后并定义last指针指向left位置，这里的last指针表示last之前并且包括last的元素都小于枢纽元素pivot。</p><p><img src="/assets/quick_sort3.png?imageView2/2/w/400/h/230/q/100" alt="quick_sort1"></p><p>之后便开始通过对比枢纽元素与枢纽元素后面的元素，将小于枢纽元素的元素交换到前面，并移动last指针，由于24与67都比23大，所以last就保持不变，也没有任何交换的操作。</p><p><img src="/assets/quick_sort4.png?imageView2/2/w/400/h/210/q/100" alt="quick_sort1"></p><p>当遇到i移动到3的时候，便交换24与3，并且移动last指针指向3。</p><p><img src="/assets/quick_sort5.png?imageView2/2/w/400/h/200/q/100" alt="quick_sort1"></p><p>之后继续移动i，直到最后一个元素。这样，last之前的元素都小于枢纽元素，last之后的元素都大于等于枢纽元素。</p><p><img src="/assets/quick_sort6.png?imageView2/2/w/400/h/200/q/100" alt="quick_sort1"></p><p><img src="/assets/quick_sort7.png?imageView2/2/w/400/h/230/q/100" alt="quick_sort1"></p><p>然后再恢复划分的子集，让枢纽元素之前的子集和枢纽元素之后的子集分别递归调用排序，递归的终止条件就是子集只有一个元素的时候，这时子集当然是有序的。这样就完成了对整个数组的排序。</p><p>对于快速排序排序还有一些复杂的细节，比如枢纽元素的选择等。关于时间复杂度与空间复杂度的分析可以参考<a href="https://zh.wikipedia.org/wiki/快速排序">维基百科</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;快速排序的另一种简单写法&quot;&gt;&lt;a href=&quot;#快速排序的另一种简单写法&quot; class=&quot;headerlink&quot; title=&quot;快速排序的另一种简单写法&quot;&gt;&lt;/a&gt;快速排序的另一种简单写法&lt;/h3&gt;&lt;p&gt;最近在看&lt;a href=&quot;https://book.doub
      
    
    </summary>
    
    
      <category term="排序， 算法" scheme="http://wujingchao.github.io/tags/%E6%8E%92%E5%BA%8F%EF%BC%8C-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
